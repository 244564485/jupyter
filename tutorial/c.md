# C语言知识点总结

一, 	常量	2
二, 	标识符	2
三, 	变量	2
四, 	表达式	3
五, 	输入输出函数	4
六, 	C语言的语句	5
七, 	C程序的基本结构	5
八, 	选择结构语句	5
  	if(表达式) 语句1 else 语句2	5
  	条件运算符 表达式1? 表达式2 : 表达式3	6
  	switch语句	6
九, 	循环结构	6
  	for循环语句	6
  	while循环语句 do while循环语句	6
十, 	数组	7
十一, 	字符串函数	7
十二, 	函数	8
十三, 	指针	9
十四, 	宏定义	10
十五, 	结构体, 共用体, 枚举类型	10

## 一, 常量
  数字常量 
i.普通数字:1, 35, 2.7
ii.指数形式:2.45e-2等价于2.45*10-2 注意e大小写皆可, e前面的数字不能省, 就算是1也不能省, 后面的数字一定要是整数
iii.长整型, 单精度浮点型:3235L, 32.5F 分别表示3235是长整型数据, 32.5是单精度浮点型左, 若不写上L, F则表示3235是整型, 32.5是双精度浮点型, L, F大小写皆可
  字符常量
i.普通字符常量:用单引号把一个字符括起来, 如'A','@'
ii.转义字符常量:一对单引号括起来并以"\"开头的字符序列, 如'\n'(回车), '\123'(8进制123对应的字符), '\x23'(16进制23对应的字符)
  字符串常量
用一对双引号把一个字符序列括起来, 如"ABCef",  系统存放字符串常量, 每个字符分配一个字节, 各字符所占字节紧邻, 并且字符串末尾会给再开一个字节里面放一个'\0'做为结束标志. 
  符号常量
定义格式 #define 符号常量名 符号常量值, 如#define N 20则定义了符号常量N, 其值为20, 注意符号常量名和符号常量值之间是用空格隔开, 而不是写上=号, #define和符号常量名之间也有空格的. 

## 二, 标识符
  命名规则
以数字, 字母, 下划线这三类字符组成, 但只能以字母或下划线开头, 而不能也数字开头, 另外不能将关键字做为标识符. 
  变量名, 函数名, 符号常量名全都是标识符

## 三, 变量
  变量的定义格式
类型名 变量名;
如 int  a;定义了一个整型常量a. 变量名是由人类随便定义的, 符合命名规则的前提下, 爱写啥就写啥. 所以什么flag, cc, y1或者函数名fun,find等全部是自定的用来做为名字而已, 没有更特别的意义. 
  类型名
int 整型, long 长整型: 用于存放整数, 只是数值范围不同
float 单精度浮点型 double 双精度浮点型:用于存放实数, 数值范围, 精度不同
char字符型:用于存放字符
  变量赋值, 初始化
int  a=3;定义的同时初始化
a=6*9;定义后在程序中进行赋值
  变量的值
只有在赋值操作时才会被改变, 即将其放在等号左边时才会改变它的值, 或自增自减操作:a=5,a++,a--, 像a+3并未改变a的值, 只是使用了a的值而已.
  自增自减运算
变量++,++变量, 变量--, --变量  使变量的值自增1或自减1
等价于 变量=变量+1  变量=变量-1
++, --放于变量前后效果的区别:
当自增自减运算做为表达式的一部分时, ++, --放在变量前面是先自增自减再使用变量的值, 放在变量后面则是先使用变量的值, 再自增自减. 
如x=3; printf("%d",++x);则相当于执行了++x; printf("%d",x);这样的操作所以打印出4
再如x=3; printf("%d",x++);则相当于执行了printf("%d",x); x++;这样的操作, 则打印出3, 当然最后x的值还是4. 

## 四, 表达式
  运算符和运算对象
一个运算符都有若干个运算对象, 如 + 必然要跟两个运算对象才能进行加法运算:3+5. C语言里称需要跟n个运算对象的运算符为n元运算符. 
一元运算符有:!, (类型名)
二元运算符有:+,-,*,/,%(求余), =,+=, -=, *=, /=,%=,< , > , <=, >=, = =(等于), !=(不等于), &&(且) , ||(或)
多元运算符有: , 
  运算符的优先级和结合性
i.优先级:同一个运算对象左右两边若同时有两个运算符, 则这两个运算符优先级高的先进行运算. 
ii.结合性:若同一个运算对象左右两边的两个运算符优先级相同, 则根据结合性判断先进行哪个运算, 自左自右结合性的先算左边的运算符, 自右自左的先算右边的运算符. 
iii.各运算符的优先级和结合性见P365附录C
  强制类型转换
格式: (类型名) 表达式 . 将后跟的表达式的值的数据类型转换为与圆括号内的类型名一致的类型. 注意类型名一定要用() 括起来. 
  算术表达式
i.算术运算符:+,-,*,/,%(求余)
ii.由算术运算符加上运算对象构成算术表达式,如3+3*6-9/2
iii.值:跟我们小学时学的一样, 就是表达式的计算结果
iv.整数除以整数结果取整数部分, 故1/3得到的值是0
v.5%3 结果为2, 想想小学除法, 求余得到的是余数不是商. 
  赋值表达式
i.赋值运算符:=, +=, -=, *=, /=,%=
ii.赋值表达式:变量=表达式, 如x=3+6, x+=6-9, x+=x*=3+4 注意等号左边只能是变量
iii.复合赋值运算符的运算:以/=为例:x/=表达式 等价于 x=x/(表达式)
iv.值:=号左边的变量最终的值
  关系表达式
i.关系运算符:< , > , <=, >=, = =(等于), !=(不等于)
ii.由关系运算符加上运算对象构成关系表达式,如3>=4, 2==a
iii.值:满足相应运算符所指定的关系的值为1, 否则为0
  逻辑表达式
i.逻辑运算符:&&(且) , ||(或) , !(非)
ii.由逻辑运算符加上运算对象构成逻辑表达式,如3&&4, x||!y
iii.值:满足相应运算符所指定的关系的值为1, 否则为0
iv.进行 ||或 运算时, 若||左边的表达式值为1, 则不再对右边的表达式进行运算. 
v.进行 &&且 运算时, 若&&左边的表达式值为0, 则不再对右边的表达式进行运算. 
  逗号表达式
i.逗号运算符: , 
ii.用逗号将各种表达式连续起来构成逗号表达式, 如3+4,a=9,8*a
iii.值:组成逗号表达式的各个表达式中的最后一个的值, 如上例为8*a
  题目:P7—11~17 	P8—18~33

## 五, 输入输出函数
  scanf("格式控制串", 变量地址表列);
如scanf("%d%c%d",&a,&ch,&b);    scanf("%4f",&x);
注意:
i.格式控制串可控制截取用户输入的前几个字符给变量, 但不能控制输入几位小数给变量, 如不能写成scanf("%4.2f",&x);
ii.第二个参数给的是地址, 即要么是&+变量名或数组元素名的形式, 要么就是一个数组名或指针变量名, 如int *p,a; p=&a; scanf("%d",p);
iii.考试时注意看题目给你写好的scanf的格式
1.若其格式控制串内各格式符用", "隔开如scanf("%d, %c, %d",&a,&ch,&b);那输入时也要用逗号隔开, 如此例输入时应:3,+,5
2.若是这种格式scanf("%d %d",&a,&b);则输入时应:3 5;
3.若是这种格式scanf("%d%c%d",&a,&ch,&b);则输入时应3+5, 若写成3 + 5则a=3,ch=' '(空格), b=任意值      (自己上机运行看看结果)
  printf("格式控制串", 输出项表列);
如float x=7.5; printf("%8.2f",x);此处的意思是将x打印出来, 且占8列, 保留两位小数. 自己上机运行看看效果. 
  常用格式符汇总:
i.%d:输入输出整型数据, %ld:输入输出长整型数据
ii.%c:输入输出字符型数据
iii.%f:输出单(双)精度浮点型数据, 输入单精度型数据.             %lf:输入双精度型数据
iv.%s:输入输出一个字符串, 用printf输出字符串时, 输出项书写时可为字符串常量, 或字符数组名. 如printf("%s","hello");或char str[10]="hello"; printf("%s",str);
v.%u:输入输出无符号整型, %o:输入输出八进制数,              
%x:输入输出十六进制数
  getchar();
函数调用后返回用户输入的一个字符, 故需再定义一个变量来存放这个字符, 即使用时应 char c; c=getchar();意思就是接收用户输入的一个字符, 并将其赋值给变量c. 
  putchar(字符常量或字符变量名);
如char c='A'; putchar(c);或putchar('A');都会向屏幕输出字符A. 

## 六, C语言的语句
  表达式语句:由表达式末尾加上分号构成. 
  函数调用语句:由函数调用表达式加上分号构成. 
  空语句: ;
  选择结构语句:if语句 switch语句
  循环语句:for语句 while语句 do while语句
  复合语句:用花括号｛｝将以上任意语句括起来构成一条复合语句. 

## 七, C程序的基本结构
void main()
{  声明部分:用来定义变量和声明自定义函数的原型, 需以";"结尾, 如int x;
   执行语句部分:第六点里介绍的各种语句, 如x=3;printf("%d",x);
}
main函数外可写自定义函数. 如
int max()
{
   return 0;
}

## 八, 选择结构语句
  if(表达式) 语句1 else 语句2 
如果if语句的圆括号内的表达式值为非0, 则执行语句1, 值为0则执行语句2. 
i.表达式可为任意表达式, if语句执行的实质是判断表达式的值是否为0来决定执行语句1还是语句2. 另外请在此处表达严重关切, 不管是高手还是菜鸟经常会把判断两个数相等的符号"=="写成了一个等号"="成为了赋值运算, 这样的写法不会引发编译错误, 但结果会与原意大大不同, 所以考试前请再三提醒自己. 
ii.语句1和语句2都只能是一个语句, 若要跟多条语句, 切记用一对{}括起来, 构成复合语句;也不要随便在圆括号后加";" , 因" ;"构成一条空语句, 这会使后面跟的语句1不再属于if语句的组成部分. 
iii.if语句的三种结构
1.单边: if(表达式) 语句
2.双边:if(表达式) 语句1 else 语句2
3.多层(重点掌握):
if(表达式1) 语句1 
else if(表达式2) 语句2 
else if(表达式3) 语句3
…
else 语句n
  条件运算符 表达式1? 表达式2 : 表达式3 
若表达式1的值非0, 则取表达式2的值做为整个表达式的值, 否则取表达式3的值为整个表达式的值. 如 3>4? 1:2  该表达式的值为2
  switch语句
switch(表达式)
{
	case 表达式1:语句
	case 表达式2:语句
	…
case 表达式n:语句
	default: 语句
}
语句执行过程:先计算表达式的值, 然后判断该值与表达式1到表达式n中的哪个相等, 若与表达式i的值相等, 则执行表达式i后的所有语句, 当遇到break;语句时结束整个switch语句的执行. 表达式1到表达式n的值都不相等的情况下执行default后跟的语句. 每个case后可跟多条语句. 

## 九, 循环结构
  for循环语句
for(表达式1;表达式2;表达式3) 循环体语句
语句执行过程:
1.计算表达式1
2.判断表达式2的值是否为0, 若为0, 语句执行结束, 若不为0, 进入步骤3
3.执行循环体语句(需注意的是循环体语句只能有一个语句, 若要包含多个语句要用一对{}括起来, 构成一条复合语句, 此处也不要随便加上 " ; ", 因一个";"可构成一条空语句, 这会使得后面真正的循环体语句不属于for循环语句的部分). 进入步骤4
4.计算表达式3, 然后重新进入步骤2
  while循环语句 do while循环语句
i.while(表达式) 循环体语句
执行过程:
1.判断表达式的值是否为非0, 若是进入步骤2, 否则结束语句执行. 
2.执行循环体语句, 重新回到步骤1. 
ii.do  循环体语句  while(表达式);
执行过程:
1.执行循环体语句, 进入步骤2
2.判断表达式的值是否为非0, 若是重新回到步骤1, 否则结束语句执行. 

这里要注意的地方跟for语句一样, 即循环体语句只能有一个语句, 若要包含多个语句要用一对{}括起来, 构成一条复合语句, 此处也不要随便加上 " ; ", 因一个";"可构成一条空语句, 这会使得后面真正的循环体语句不属于while循环语句的部分, 另外do while循环的while(表达式)后是要加";"的. 
  break语句:放在循环体内实现的功能是结束其所在的那层循环的执行. 

## 十, 数组
  定义格式:数据类型   数组名[整型常量];如 int a[10]; 定义了一个整型数组, 数组名为a, 这个数组含有10个元素. 
  引用数组元素: 格式:数组名[下标]   切记下标值从0开始. 下标可为常量, 表达式, 变量等, 如int i=3; a[0]=5;a[3*2]=9; a[i]=7;
  初始化:数据类型   数组名[整型常量]={数据表列};将数据表列的各个值依次赋值给数组的各个元素. 如int a[5]={0,1,2,3,4};则数组a各元素a[0]到a[4]的值分别为0, 1, 2, 3, 4
  遍历数组元素
数组定义后, 我们不能对数组进行整体的操作, 如int a[10];不能用a=3这样的操作将数组的各元素都赋值为3;而只能一个一个元素的进行赋值, 如a[0]=3;a[1]=3;a[2]=3…a[9]=3; 当然此时我们就可以借助于一个for循环来控制下标的变化从而对数组的各个元素进行赋值
for(i=0;i<10;i++) a[i]=3; 
当然这只是用for循环遍历数组各元素的最简单的例子, 一般考试考的是找出数组元素的某种特性的极值, 比如最大值, 最小值, 或对数组各元素进行排序, 这时我们就可以使用for循环来遍历数组的各元素, 然后在当前循环中得到一个元素再对其进行处理. 如i=2时访问到的元素是a[2], 你就可以问问它, 你是不是最小值啊. 
  整型数组
int a[10]; 整型数组里的各个元素存放的是整数. a[3]=3;
  字符型数组
char  str[20];字符型数组里的各个元素存放的是字符.    str[3]='A';

## 十一, 字符串函数 
  gets(字符数组名或字符指针变量);
如char str[10],* str2; str2=str;则gets(str);或gets(str2);都是接收用户输入的字符串如"ABC"存入到字符数组str中
  puts(字符数组名或字符指针变量或字符串常量);
如char str[10]="china";	char *str2;str=str2;  则puts(str); 或puts(str2); 或 puts("china");都会在屏幕上打印出 china
  strlen(字符数组名或字符指针变量);字符串测长函数
char str[20]="hello world!";  
int len;len=strlen(str);得出的结果是len的值为12
  strcat(字符串1的地址, 字符串2的地址);
将字符串2的内容连接到字符串1的尾部. 
char str1[20]="ABC",str2[20]="xyz"; 
strcat(str1,str2); 
则程序运行的结果是str1内存放的字符串变为ABCxyz, 当然str2存放的字符串还是xyz. 
  strcmp(字符串1的地址, 字符串2的地址);
比较串1和串2哪个比较大. 比较大小的依据是, 两个字符串从左往右相应位置上第一个不相等的字符ASCII码值之差. 
char str1[20]="ABCE",str2[20]="ABDE"; 
int i;
i=strcmp (str1,str2);
第一个不相等的字符为str1的'C'和str2的'D', 而二者相差-1, 故-1做为strcmp函数执行的结果返回到被调用的位置, 该位置位于赋值表达式内, 故将其值赋值给i, 即此时i的值就是-1.
  strcpy(字符串1的地址, 字符串2的地址);
将字符串2的内容复制到字符串1内. 
char str1[20]="ABC",str2[20]="xyz";
strcpy(str1,str2);此时str1的内容为"xyz", 当然str2的内容没变
strcpy(str1,"uvw");此时str1的内容又变成了"uvw". 

## 十二, 函数
  函数定义
函数类型  函数名( 形式参数列表 )
 {
        内部变量定义和声明部分
	     执行语句
 }
如:
int  max (int  x , int  y )
{  int  z ;
    z= x > y ? x : y ;
    return  ( z ) ;
}
注意点:
1.函数类型是指返回值的类型, 即要与return语句后跟的表达式的值的类型一致. 若函数类型为void则说明该函数无返回值, 即函数体里不能出现return 语句. 
2.形式参数列表里定义的变量要记得给它们指定类型, 而且如果同时要定义多个, 应在每个前面都分别指定类型名, 而不能写成int x,y;
3.函数体里能写的语句跟main函数一样, 在开头可定义所需要的变量, 后面跟上一堆执行语句. 
  函数调用流程
以上面的函数为例, 在main函数进行调用:
void main()
{ int a,b,c;
  scanf("%d%d",&a,&b);
  printf("%d",max(a,b));或 c=max(a,b);printf("%d",c)以上两种方法都会在屏幕中打印出a, b间的较大值. 
调用函数的格式 函数名(实际参数列表);调用的时候像什么函数类型, 形式参数的类型就不要加上去了. max(a,b)中max就是函数名, 写上变量名a,b是实际参数列表, 执行这个调用语句时, 会先把a,b的值给相应位置的形式参数即执行了x=a,y=b这样的操作, 然后开始执行max函数的函数体的语句. 当max函数体里执行到一个return语句时, 则max函数结束执行, 将return后的表达式的值返回给main函数调用max函数的那个位置, 即若上面a=3,b=5则max(a,b)return后的表达式的值应该是5也就是说执行完max后把5返回到调用max的位置可看成printf("%d", 5);或另一种解法的c=5. 
}

## 十三, 指针
  指针变量的声明: 类型名 * 指针变量名;
  通过指针变量访问它所指向的普通变量的值
先将普通变量的地址赋值给指针变量, 再通过指针运算符* 得到普通变量的值. 
int *p,x,y;
x=3;
p=&x;
则printf("%d",*p);会打印出3即x的值
y=*p;则y的值变为3
*p=5;则x的值变为5
  指针变量加上(减去)一个位移的效果
若指针变量存入的是数组元素的地址, 则其加一减一得到的是那个数组元素下一个或前一个元素的地址. 
int a[10]; p=&a[3];
*p得到的是a[3]的值. 
若p++;此时p存放的是a[4]的地址&a[4]; *p得到的就是a[4]的值. 
或p--;此时p存放的是a[2]的地址&a[2], *p得到的就是a[2]的值. 
  行指针
i.主要是对于二维数组来说的, 二维数组每行都有自己的地址, 第0行地址用 数组名 表示, 第i行地址为 数组名+i;而想要得到二维数组里一个元素的地址, 必需先得到其所在行的地址, 然后再由那个地址得到元素的地址, 比如说 int  a[3][4];定义了一个二维数组, 该二维数组第0行的地址为a, 第1行的地址为a+1, 第2行的地址为a+2, 想从行的地址得到元素的地址, 需在行地址前加上指针运算符"*", 即*a就是第0行首个元素的地址即a[0][0]的地址, 而a[0][2]的地址就是在a[0][0]的地址基础上加上位移量2, 即*a+2, 然后想得到a[0][2]这个元素的值呢就再加上一个指针运算符"*", 即*(*a+2), 类似地, 想得到a[2][2]这个元素的值呢就是*(*(a+2)+2)
ii.定义行指针变量: 类型名  (*变量名)[数组长度];
如int (*p)[4],a[3][4]; p=a;此时就可把p当成a来用, 用法同上所述. 
  判断是否合法访问数组元素:若是指针法访问, 判断指针后跟的是否地址;若是下标法访问, 判断下标有无越界. 
  函数指针:函数名即为函数的地址(指针)
i.函数指针变量的定义: 类型名 (*变量名) (形参列表);如 int (*p)();
ii.赋值:指针变量=函数名;设有个函数其函数名为max,则要将该函数的地址给p的话只要执行如下语句即可 p = max;
  指针数组:指针数组的数组元素都是指针变量, 是用来存放变量的地址的, 定义格式为 类型名 * 变量名[数组长度]; 如int * p[10];
  指向指针的指针:指针变量也是一种变量, 故在内存中也有对应的一个地址, 而要存放指针变量的地址, 就要求助于用来存放指针变量的地址的指针变量, 定义格式  类型名 ** 变量名;如 int *p1; int **p2; int a=3;可进行赋值p1=&a; p2=&p1; 则a , *p1和 **p2的值都是3.

## 十四, 宏定义
  无参宏定义 #define  标识符  值   定义后, 出现所定义的标识符的地方都将以定义时指定的值来代替. 
#define  M  2+3
main()
{  int x;
   x=M*M;  则x的值为2+3*2+3=11若想得到的结果是(2+3)*(2+3)则定义时也写成这样 #define M (2+3)
}
注意#define, 标识符, 值之间都要用空格隔开, 且宏定义结尾不需加分号. 
  带参宏定义  #define 标识符(参数表)  值
#define  S(x,y)  x*y
main( )
{  int a=3,b=4,c=5,d=6;
    printf("a*b=%d\n", S(a,b));  此时会打印出 a*b=12
    printf("a+b*c+d=%d\n" , S(a+b,c+d)); 此时会打印出a+b*c+d=29, 带参宏定义执行时是将a+b这样一个表达式代替x, c+d这样一个表达式代替y, 所以S(a+b,c+d)进行的是a+b*c+d的运算, 而不是将a+b的值给x, c+d的值给y然后再做x*y, 这点跟函数调用传递参数是不一样的. 
}
  自定义类型名typedef:对已存在的类型名取一个外号. 
i.基本格式:typedef  原类型名  新类型名;
ii.typedef  int INTEGER; 则int a,b;等价于INTEGER a,b;
iii.typedef  int  NUM[10]; 则 int a[10];等价于 NUM a; a即为一个有10个元素的数组的数组名. 
iv.typedef int * INTEGER; 则int *a,*b;等价于INTEGER a,b;

## 十五, 结构体, 共用体, 枚举类型
  结构体
i.结构体类型的定义及变量的定义
struct  结构体名
 {类型 成员1;
  类型 成员2;
  ……
  类型 成员n;
 }变量名;
如
struct student
{  long  num;
char name[10];
int score[4];
}st1;定义类型时同时定义变量
struct student st2;定义类型后, 用类型名定义变量
还有一种
struct 
{  long num;
char name[10];
int score[4];
}st3;不给类型名, 直接定义变量
ii.结构体变量所占字节数:各成员各占字节数之和, 如以上st1,st2,st3的字节数皆为10+20+2*4=38
iii.结构体变量初始化:struct student a={20030001, "张三", 70,75,80,85};
iv.结构体数组定义及初始化:
struct student a[3]={{20030001,"zhang",89,90,91,92},
            {20030002,"liu",68,69,70,71},
            {20030003,"li",57,58,59,60} };
v.结构体变量成员的访问
1.结构体变量名. 成员名 如st1.num
2.使用结构体类型的指针:
(*结构体指针名) . 成员   或    结构体指针名–>成员名
struct student *st;  st=&st1;  st->num 或(*st).num
  共用体
i.共用体类型的定义及变量的定义
union  共用体名
{ 类型  成员名1;
  			…
  			类型  成员名n; 
};
变量的定义与结构体类似, 也有三种方法. 
union data
{
  	int i;
	char ch;
	float f;
}d1; 定义类型时同时定义变量
union data d2; 定义类型后, 用类型名定义变量
union 
{
  	int i;
	char ch;
	float f;
}d3; 不给类型名, 直接定义变量
ii.共用体变量所占字节数:各成员所占字节数的最大值,如上d1,d2,d3所占字节数皆为4.(单精度浮点型变量所占字节数最多为4).
iii.共用体变量成员的访问
1.共用体变量名. 成员名 如d1.i
2.使用共用体类型的指针:
(*共用体指针名) . 成员   或    共用体指针名–>成员名
union data *dd;  dd=&d1;  dd->i 或(*dd).i
iv.共用体成员的值:由于共用体各成员共用同一段内存区, 故同一时刻只有一个成员的值是正确的. 如d1.i=5;d1.ch='a';则此时d1.i的值就不是5了, 而是其他值了, d1.ch的值是'a'
  枚举类型
i.枚举类型的定义:                                                  enum 枚举名{枚举元素名1, 枚举元素名2, …, 枚举元素名n};
ii.枚举元素的值:
默认值分别为0, 1, …, n-1. 枚举元素的值也可在定义时重指定, 对于没有指定值的元素, 按顺序加1
如enum weekday{sun=7,mon=1,tue,wend,thur,fri,sat};则sun值为7, mon值为1, tue值为2, wend值为3, thur值为4, fri值为5, sat值为6



# C语言整理笔记
1)变量为什么必须初始化
   所谓初始化就是赋值的意思. 
2)常量在C语言中是如何表示
   整数:
     十进制: 传统写法 例:int a = 123;
     十六进制: 前面加0X(0是数字零, X可以大小写)
     八进制: 前面加0(0是数字零)
  浮点数:
传统写法 例:float  a = 3.2;
科学计数法 例:float a = 3.2e3; 或 float a = 3.2e-2;(e表示为10)
     浮点数的存储所带来的问题
       Float和double都不能保证可以精确的存储一个小数. 
  字符:
单个字符用单引号括起来;字符串用双引号括起来
     例:'A'表示字符A.(注意:'AB'是错误的, 正确写法"AB". )
         "A"是正确的, 因为"A"代表了'A''\0'的组合(0是数字)
3)常量以什么样的二进制代码存储在计算机中
   整数是以补码的形式转化为二进制代码存储在计算机的
   实数是以IEEE754标准转化为二进制代码存储在计算机的
   字符的本质实质也是与整数的存储方式相同
4)什么是字节
   字节就是存储数据的单位, 并且是硬件所能访问的最小单位. (一个字节 =  8个位)
5)什么是ASCII
   ASCII不是一个值, 而是一种规定. ASCII规定了不同的字符是使用哪个整数值去表示. 
   'A' ——  65; 'B' ——  66; 'a'—— 97; 'b' —— 98;
'0' —— 48 (0是数字)
6)运算符
   算术运算符
     +   —   *   /(除)  %(取余)
 除法 / 的运算结果和运算对象的数据类型有关, 两个数都是int, 则商就是int, 若商有     小数, 则截取小数部分;被除数和除数中只要有一个或两个都是浮点型数据, 则则商也是浮 点型, 不截取截取小数部分. 
   例: 16 / 3 == 5; 16 / 5.0 ==3.20000; 16.0 / 5 == 3.20000
         3 / 5 == 0;  5 / 3 == 1
 取余 % 的运算对象必须是整数, 结果是整除后的余数, 其余数的符号和被除数相同. 
   例: 13 % 3 == 1;  13 % —3 = 1; —13 % 3 == —1; —13 % —3 == —1
   关系运算符
 >    >=    <     <=   !=     =
逻辑运算符
     !(不等于)  &&(并且)    ||(或)
 && 左边的表达式为假, 右边的表达式肯定不执行
  | |  左边的表达式为真, 右边的表达式肯定不执行
   赋值运算符
     =  *=(a *= 3等价于a = a * 3)
   优先级别
     算术 > 关系 >  逻辑 > 赋值
三目运算符
  A ? B :C  等价于  if (A) B; else  C;
逗号表达式
  (A, B, C, D) 功能:从左到右执行, 最终表达式的值是最后一项的值
7)如何使用scanf编写出高质量代码
   1. 使用scanf之前最好先使用printf提示用户以什么样的方式输入
     如:printf("请输入两个值(中间用空格分隔):\n");
         scanf("%d %d", &a, &b);
         printf("a = %d, b = %d\n", a, b);
   2.  Scanf中尽量不要使用非输入控制符, 尤其不要 \n
        Scanf  (" %c", ch); / /  %c 前面必须加一个空格
   3. 应该编写代码对用户的非法输入做适当的处理
     如: char ch;
          While ( ( ch = getchar( ) )  != '\ n')
             Continue;
     例:
# include <stdio.h>
int main(void)
{
   int a;
   int b;
   char ch;
   scanf("%d", &a);
   printf("a = %d\n", a);
   while ( (ch = getchar()) != '\n' )
	   continue;
   scanf("%d", &b);
   printf("b = %d\n", b);
   return 0;
}
8)if的范围问题
   1. If (表达式)
        语句A;
        语句B;
 If默认只控制语句A的执行或不执行, if 无法控制语句B. 
   2. If (表达式)
       {
          语句A;
          语句B;
        }
     此时if可以控制语句A和语句B
由上可知:if默认只能控制一个语句, 如果想控制多个语句, 就必须把这些语句用{}括起来
9)if的常见问题解释
  1. 空语句的问题
      If ( a > b);
   等价于
      If ( a > b
        ; / / 这是一个空语句
  2. If ( a > b);/ / 这里不应该加分号
       A;
else
   B;
这是错误的语句
   3.  If (表达式1)
          A;
      Else if (表达式2)
          B;
      Else if (表达式3)
          C;
      Else
          D;
 即便表达式1和2都成立, 也只会执行A语句
   4.  If (表达式1)
          A;
      Else if (表达式2)
          B;
      Else if (表达式3)
          C;
     这样写法不会出错, 但逻辑上有漏洞
   5.  If (表达式1)
          A;
      Else if (表达式2)
          B;
      Else if (表达式3)
          C;
      Else  (表达式4)/ / 正确写法要么去掉表达式4, 要么在else后面加if
          D;
     这样写是错误的
   6.  If (表达式1)
          A;
      Else if (表达式2)
          B;
      Else if (表达式3)
          C;
      Else  (表达式4);/ / 无实际意义的语句
          D;
      这样写法不会出错, 但逻辑上有漏洞
       Else  (表达式4);/ / 无实际意义的语句
          D;
       等价于
        Else
         (表达式4);
          D;
10)前自增和后自增的异同
相同
  最终结果i的值加1
不同
  前自增整体表达式的值是i加1之后的值
  后自增整体表达式的值是i加1之前的值
11)for和while可以相互转换
For ( 1;  2;  3)
    A;
等价于
1;
While ( 2 )
{
   A;
   3;
}
12)do……while
   格式: do
          {
            ……
          } while (表达式);
      do……while 不等价于for和while
         主要用于人机交流
 例:
# include <stdio.h>
int main(void)
{
	char ch;
    do
    {
        int n;
		int i = 0;
        int sum = 0;
		printf("请输入你要求和的数:");
        scanf("%d", &n);
        for (i; i < n; ++i)
			sum +=i;
        printf("sum = %d\n", sum);
        printf("你想继续吗?继续请输入Y或y, 退出请输入任意键 \n");
        scanf(" %c", &ch);   / /  %c 前面必须加一个空格
    } while (ch == 'Y' || ch == 'y');
    return 0;
}
13)switch 语句
例:
# include <stdio.h>
int main(void)
{
	int num;
	printf("请选择你的楼层数: ");
	scanf("%d", &num);
	switch (num)
	{
	case 1:
		printf("第一层到!\n");
		break;
	case 2:
		printf("第二层到!\n");
		break;
	case 3:
		printf("第三层到!\n");
		break;
	case 4:
		printf("第四层到!\n");
		break;
	default:
		printf("还没有盖到这一层!\n");
		break;
	}
	return 0;
}
Switch是选择不是循环, 如果在switch中出现了break语句. 该语句的功能只是退出switch语句转去执行它下面的语句. 在switch中出现continue是错误的, 除非switch本身属于for或while 循环的一部分. 
14)break 和 continue
Break的用法
  Break如果用于循环是用来终止循环
  Break如果用于switch, 则是用于终止switch
  Break不能直接用于if, 除非if属于循环内部的一个字句
例:
for (i = 0; i < 3; ++i)
	{
	      if (3 > 2)
			  break; // break虽然是if内部的语句, 但break终止的是if外部的for循                 环
		  printf ("哈哈!\n"); // 永远不会输出
	}
在多层switch嵌套中, break只能终止距离它最近的那个switch
在多层循环中, break只能终止距离它最近的那个循环
例:
    for (i = 0; i < 3; ++i)
	{
	      for (j = 1; j < 4; ++j) / / 被break终止了
			  break; / / break只能终止距离它最近的那个循环
		  printf ("哈哈!\n");
	}
Continue的用法
  用于跳过本次循环余下的语句, 转去判断是否需要执行下次循环
 例:
For ( 1;  2;  3)
{
   A;
   B;
    Continue; / / 如果执行该语句, 则执行完该语句后, 会执行语句3, C和D都会被
                跳过去, C和D不会被执行. 
    C;
    D;
}
15)数组
一维数组
  怎样定义一个一维数组
      为n个变量连续分配存储空间
      所有的变量数据类型必须相同
      所有变量所占的字节大小必须相等
  不初始化, 所有元素是垃圾值
     int a [5] ;
 错误写法:
     int a [5] ;
      a [5] = {1, 2, 3, 4, 5};
  只有在定义数组的同时才可以整体赋值, 否则, 是错误的. 
      正确写法:int a [5] = {1, 2, 3, 4, 5};
int a [5] = {1, 2, 3, 4, 5};
int a [5] = 100;/ / 错误, 因为没有int a [5]这个元素
int a [5] = {1, 2, 3, 4, 5};
int a [b] ;
如果要把a数组中的值全部赋值给b数组
错误写法:b = a;
正确写法:
  For ( i = 0; i < 5; ++i )
    b[i] = a[i] ;
二维数组
  int a[3][4];
  总过有12个元素, 可以看做3行4列. 这12个元素如下:
  a[0][0]  a[0][1]  a[0][2]  a[0][3]
  a[1][0]  a[1][1]  a[1][2]  a[1][3]
  a[2][0]  a[2][1]  a[2][2]  a[2][3]
  初始化
    int a[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,12};
     int a[3][4] = {
          {1, 2, 3, 4}, 
          {5, 6, 7, 8, }, 
          {9, 10, 11,12}
    };
   输出数组元素:
     For (i = 0; i < 3; ++i)
     {
           For ( j = 0; j < 4; ++j)
             Printf ("%d",  a[i][j]);
      }
  多维数组
    是否存在多维数组
      不存在, 因为内存是线性一维的
      n维维数可以当做每个元素是n — 1维数组的一维数组
      如:
        int a[3][4] ;
          该数组是含有3个元素的一维数组, 
          只不过每个元素都可以再分为4个小元素
        int a[3][4][ 5];
           该数组是含有3个元素的一维数组, 
           只不过每个元素都是4行5列的二维数组
16)函数
        什么事函数
           逻辑上:能够完成特定功能的独立代码块
           物理上:  能够接受数据
                     能够对接受的数据进行处理
                     能够将数据处理的结果返回[也可以不返回]
    函数是个工具, 它是为了解决大量类似问题而设计的, 它可以当做一个黑匣子. 
    int  f ( void ) / / 括号中的void表示该函数不能接受数据, 
                    int表示该函数返回值类型值是int类型
void g( void ) / / 函数名前面的void表示该函数没有返回值
函数返回值的类型也称为函数的类型, 如果函数名前面的返回值类型
和函数执行体中的return表达式中表达式类型不同时, 最终函数返回
值的类型以函数名前面的返回值类型为准
例:
# include <stdio.h>
int f()
{
	return 9.6; //因为函数的返回值类型是int, 所以最终f返回的是9而不是9.6
}
int main(void)
{
	int i = 15;
	double j = 5.5;
    j = f();
	printf("%lf",  j);
	return 0;
}
return 表达式的含义
  1, 终止被调函数, 向主函数返回表达式的值
  2, 如果表达式为空, 则只终止函数, 不向主函数返回任何值
  3, break是用来终止循环和switch的, return是用来终止函数的
例:
void f()
{
	return; / /只终止函数, 不向主函数返回任何值
}
    int f()
{
	return 10; / /第一, 终止函数, 第二, 向主调函数返回10
}
   一个程序必须有且只有一个主函数, 主函数可以调用普通函数, 普通函数不能调用
   主函数, 普通函数可以相互调用, 主函数是程序的入口, 也是程序的出口. 
 如何在软件开发中合理的设计函数来解决实际问题
     一个函数的功能尽量独立, 单一. 多学习, 多模仿牛人的代码. 
 函数是C语言的基本单位
17)指针
    指针就是地址, 地址就是指针, 地址就是内存单元的编号, 从零开始的非负整数
指针变量是存放地址的变量, 指针和指针变量是两个不同的概念
但是, 通常我们叙述是会把指针变量简称为指针
指针的本质就是一个操作受限的非负整数
重要性:
  表示一些复杂的数据结构
  快速的传递数据, 减少内存的耗用
  使函数返回一个以上的值
  能直接访问硬件
      能够方便的处理字符串
      是理解面向对象语言引用的基础
 总结:指针是C语言的灵魂. 
指针基本问题:
int * p; // p是变量的名字, int *表示P变量存放的是int类型的变量
	int i = 3;
	int j;
  p = &i; // OK
	  /*
	     1. p保存了i的地址, 因此p指向i
		 2.p不是i, i也不是p,更准确地说:
		  修改p的值不影响i的值, 修改i值也不影响p的值
	     3.如果一个指针变量指向了某个普通变量, 则
	       * 指针变量 就完全等同于 普通变量
		 例子:
		    如果p是个指针变量, 并且存放了普通变量i的地址
			则p指向了普通变量i
			*p就完全等同于i
			  或者说:在所有出现*p的地方都可以替换为i
			          在所有出现i的地方都可以替代*p
           *p就是以p的内容为地址的变量
	  */
	j = *p; // 等价于 j = i
指针常见错误:
int i = 5;
int * p;
int * q;
p = &i;
// *q = p // error 语法编译会出错
// *q = *p // error
p = q; // q是垃圾值, q赋值给p, p也变成垃圾值
printf("%d\n", *q);// 13行
/*
     q的空间是属于本程序的, 所以本程序可以读写q的内容
     但是如果q内容是垃圾值, 则本程序不能读取*q的内容
     因为此时*q所代表的内存单元的控制权限并没有分配给本程序
     所以本程序运行到13行就会立即出错
*/
指针和数组
    指针和一维数组
       一组数组名是个指针常量
       它存放的是一维数组第一个元素的地址
    下标和指针的关系
       如果p是个指针变量, 则p[i]永远等价于*( p + i )
   确定一维数组需要数组第一个元素的地址和数组的长度
指针变量的运算
    指针变量不能相加, 不能相乘, 也不能相除
    如果两个指针变量指向的是同一块连续空间中不同存储单元, 
    则两个指针变量才可以想减
    如:
    int a[5];
    int * p;
    int * q;
    p = &a[1];
    q = &a[4];
    printf("p和q所指向的单元相隔%d个单元",  q - p);
一个指针到底占几个字节
   预备知识:
       sizeof(数据类型)
       功能:返回值就是该数据类型所占的字节数
     如:sizeof(int) = 4; sizeof(char) = 1; sizeof(double) = 8
 一个指针变量, 无论它指向的变量占几个字节, 该指针变量本身只占四个字节
动态内存
  用malloc()分配的空间, 在程序结束之前不会自动释放, 必须调用free()函数释放
malloc的用法
# include <stdio.h>
# include <malloc.h>// 不能省去
int main(void)
{
	int i = 5;  // 分配了4个字节, 静态分配
	int * p = (int *)malloc(4); // 12行
	  /*
	        1. 要使用malloc函数, 必须添加malloc.h这个头文件
			2. malloc函数只有一个形参, 并且形参是整型
			3. 4表示请求系统为本程序分配4个字节
			4. malloc函数只能返回一个字节的地址
			5. 12行分配了8个字节, p变量占4个字节, p所指向的内存也占4个字节
			6. p本身所占的内存是静态分配的, p所指向的内存是动态分配的
	  */
	*p = 10;
	free(p);  // 把p所指向的内存给释放掉
	printf("%d\n", *p);// 不能输出10, 因为p所指向的内存给释放掉
	return 0;
}
又如:
# include <stdio.h>
# include <malloc.h>
void f(int * q)
{
	*q = 20;
}
int main(void)
{
	int * p = (int *)malloc(sizeof(int));
	*p = 10;
    printf("%d\n", *p); // 输出10
	f(p); // p是int *类型
	printf("%d\n", *p); // 输出20
	return 0;
}
动态内存和静态内存的比较
静态内存是由系统自动分配, 由系统自动释放, 静态内存是在栈分配的. 
动态内存是由程序员手动分配的, 手动释放, 动态内存是在堆分配的. 
多级指针
int i = 10;
int * p = &i;
int ** q = &p;
int *** r = &q;
printf("%d, %d, %d",  *p, **q, ***r); //结果输出的都是10
经典例题:冒泡排序
/*
      时间:2011年4月18日
	  输入一个一维数组, 并将数组里面的元素进行升序输出
	  一定要分清动态内存的分配
*/
# include <stdio.h>
# include <malloc.h>
//函数功能是排序
void sort(int * q, int len)
{
	int j, k,t;
	for (j=0; j<len-1; ++j)
		for (k=0; k<len-1-j; ++k)
		{
			if (q[k] > q[k+1])// q[k] > a[j+1]表示升序;q[k] < q[k+1]表示降序
			{
				t = q[k];
				q[k] = q[k+1];
				q[k+1] = t;
			}
		}
}
int main(void)
{
	int len;
	int * p;
	int i;
	printf("请输入元素个数:");
	scanf("%d", &len);
	p = (int *)malloc(4 * len); // 此语句不能省去
	printf("请输入各个元素:");
	for (i=0; i<len; ++i)
		scanf("%d", &p[i]);
	sort(p, len);
	printf("\n");
	for (i=0; i<len; ++i)
		printf("%d  ", p[i]);
	printf("\n");
	return 0;
}
18)结构体
     如何定义结构体
     1, struct student
        {
             int age;
             float score;
             char sex;
         };
        推荐使用第一种
      2, struct student2
        {
             int age;
             float score;
             char sex;
         } st2;
       3, struct
        {
             int age;
             float score;
             char sex;
         } st3;
   赋值和初始化
      定义的同时可以整体赋初值
      如果定义完之后, 则只能单个的赋值
如:
# include <stdio.h>
struct student
{
	int age;
	int score;
	char sex;
};
int main(void)
{
	struct student st = {24, 75, 'M'}; //初始化 定义的同时可以整体赋值
	struct student st1;
	st1.age = 25;
	st1.score = 84;
	st1.sex = 'F';
	printf("age = %d, score = %d, sex = %c\n", st.age, st.score, st.sex);
	printf("age = %d, score = %d, sex = %c\n", st1.age, st1.score, st1.sex);
	return 0;
}
  如何取出结构体变量中的每个成员
     1, 结构体变量名.成员名
     2, 指针变量名—>成员名
例:
int main(void)
{
	struct student st = {24, 66.6, 'M'}; //初始化 定义的同时可以整体赋值
	struct student * p = &st;
	p->age = 25;
	st.age = 28;
	return 0;
}
   p->age 在计算机内部会转化为(* p).age , 这也等价于st.age
          含义是p所指向的那个结构体变量中的age这个成员
   推荐使用结构体指针变量作为函数参数来传递
    结构体变量不能相加, 不能想减, 也不能相互乘除, 但可以相互赋值
19)枚举
      什么事枚举
         把一个事物所有可能的取值一一列举出来
例:
// 时间:2011年4月19日
# include <stdio.h>
void f(enum weekday);
// 只定义了一个数据类型, 并没有定义变量
enum weekday
{
	Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday
};
int main(void)
{
	f(Friday);
	//enum weekday day = Friday;
	//printf("%d\n", day); // 输出结果是 4
	return 0;
}
void f(enum weekday i) // 本函数的目的主要是接受0 - 6之间的数字
{
	switch (i)
	{
	case 0:
		printf("Monday!\n");
		break;
	case 1:
		printf("Tuesday!\n");
		break;
	case 2:
		printf("Wednesday!\n");
		break;
	case 3:
		printf("Thursday!\n");
		break;
	case 4:
		printf("Friday!\n");
		break;
	case 5:
		printf("Saturday!\n");
		break;
	case 6:
		printf("Sunday!\n");
		break;
	}
}
 枚举优缺点:代码更安全, 但书写更麻烦. 
20)补码
     原码:也叫 符号 — 绝对值码, 最高位0位表示, 正1表示负, 
           其余二进制位是该数字的绝对值的二进制位. 
           原码简单易懂
           加减运算复杂
           存在加减乘除四种运算, 增加了CPU的复杂度
           零的表示不唯一
           原码在计算机中不被使用
     反码:反码运算不便, 也没有在计算机中应用
     移码:表示数值平移n位, n称为移码量
           移码主要用于浮点数的阶码的存储
    补码:在计算机应用最多
           已知十进制求二进制
               求正整数的二进制:除2取余, 直至商为零, 余数倒叙排序
               求负整数的二进制:先求与该负数相对应的正整数的补码, 然后
                               将所有位取反, 末尾加1, 不够位数时, 左边补1
               求零的二进制:全是零
           已知二进制求十进制
               如果首位是0, 则表明是正整数, 按普通方法求. 
               如果首位是1, 则表明是负整数
                   将所有位取反, 末尾加1, 所得数字就是该负数的绝对值
8位二进制所代表的十进制
0000 0000                  0
0000 0001                  1
…………                 ……
0111 1111                  127
1000 0000                 — 128
1000 0001                 — 127
1000 0010                 — 126
…………                 ……
1111 1111                 0
int类型所能存储的最大整数用十六进制表示是:7FFFFFFF
int类型所能存储的绝对值最大负整数用十六进制表示是:80000000
21)链表(想系统学习,  看数据结构)
    算法:
       通俗定义:解题的方法和步骤
       狭义定义:对存储数据的操作
       广义定义:也叫泛型. 无论数据如何存储, 对该数据的操作都是一样的
   我们至少可以通过两种结构来存储数据
       数组
         优点:存储速度快
         缺点:需要一个连续的很大的内存, 插入和删除元素的效率很低
       链表
         优点:插入和删除元素效率高, 不需要一个连续的很大的内存
         缺点:查找某个位置的元素效率低
   专业术语:
         头结点:头结点的数据类型和首节点的数据类型是一摸一样
                 头结点是首节点前面的那个节点
                 头结点并不存放有效数据
                 设置头结点的目的是为了方便对链表的操作
         头指针:存放头结点地址的指针变量
         首节点:存放第一个有效数据的节点
         尾结点:存放最后一个有效数据的节点