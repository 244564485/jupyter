
# 算法交易

## VWAP算法:
VWAP策略，它依据历史交易量的分布，根据指定的买入数量现有的交易时间、下单的间隔时间，计算每个间隔时间内应该下单的数量。从确定委托的时间开始，每经过一个下单间隔时间，进行一次买入或卖出，直到交易结束时间。

## TWAP算法:
TWAP将交易时间进行均匀分割，并在每个分割节点上将均匀拆分的订单进行提交。TWAP 策略设计的目的是在使交易对市场影响最小化的同时提供一个较低的平均成交价格，从而达到减小交易成本的目的。

## 冰山算法
冰山算法，通过把一个很大的单子拆分成几个小的单子。每次只提交一个小单，等该小单全部成交后，再提交下一个小单，直到整个大单成交完成为止。

## MVWAP算法:
基于对传统的MVWAP算法进行优化和改进。当市场实时价格小于此时的VWAP市场价时，在原有计划交易量的基础上进行放大（*1.7），如果能够将放大的部分成交或部分成交，则有助于降低VWAP成交价；反之，当市场实时价格大于此时的VWAP市场价时，在原有计划交易量的基础上进行缩减（*0.3），也有助于降低VWAP成交价，从而达到控制交易成本的目的。

## VP算法:
该策略可以帮助投资者在要求的时间范围内完成规模相当于市场交易量指定比例的委托交易，该指定比例称作参与率，投资者可以通过设定不同的参与率来控制自己的交易节奏，跟踪市场行情。

## Step算法:
Step算法实际上是一种对价格进行分层成交的策略，目标是在买入（卖出）交易中尽可能地压低（提升）成交均价。简单来讲，Step就是在不同的价格区间进行不同成交量比例的配置。

## HIDDEN算法:
HIDDEN策略是一种主动成交型算法交易策略，当市场盘口中出现了期望价格的委托单，并且达到预定的买入或卖出数量时，则进行委托；否则再继续等待，直到满足条件的机会出现为止。



## 算法交易步骤 
步骤 1：对股票等证券的历史行情数据进行分析，结合交易的思想，设计出交易策略。本步是算法交易的核心。
步骤 2：将交易策略编写成计算机程序，并把这些程序整合成一个交易系统来操作这些策略。根据股票的品种等因素确定好交易参数。 
步骤 3：将设计好的交易系统上接行情数据，下连下单接口以报单。实际交易时，让程序根据行情的变化自动选择股票的买卖点。 
步骤 4：程序根据产生的买卖点来对股票进行买卖操作。 
算法交易可以使用在任何交易策略，包括做市、跨市场价差套利、统计套利及纯投机(包括趋势跟随)等。算法交易日益受到投资银行、对冲基金、养老基金、共同基金等机构投资者的青睐。 

## 被动型
被动型算法交易除利用历史数据估计交易模型的关键参数外，不会根据市场的状况主动选择交易的时机与交易的数量，而是按照一个既定的交易方针进行交易。该策略的核心是减少滑价（目标价与实际成交均价的差）。被动型算法交易最成熟，使用也最为广泛，如在国际市场上使用最多的成交量加权平均价格（VWAP）、时间加权平均价格（TWAP）等都属于被动型算法交易。

## 主动性
主动型算法交易也叫机会型算法交易。这类交易算法根据市场的状况做出实时的决策，判断是否交易、交易的数量、交易的价格等。主动型交易算法除了努力减少滑价以外，把关注的重点逐渐转向了价格趋势预测上。如判断市场价格在向有不利于交易员的方向运动时，就推迟交易的进行，反之加快交易的速度。当市场价格存在较强的均值回归现象时，必须迅速抓住每一次有利于自己的偏移。

## 综合型
综合型算法交易是前两者的结合。即包含既定的交易目标，具体实施交易的过程中也会对是否交易进行一定的判断。这类算法常见的方式是先把交易指令拆开，分布到若干个时间段内，每个时间段内具体如何交易由主动型交易算法进行判断。两者结合可以达到单独一种算法所无法达到的效果。
VWAP 策略是最常用的交易策略之一，具有简单易操作等特点，基本思想就是让自己的交易量提交比例与市场成交量比例尽可能匹配，在减少对市场冲击的同时，获得市场成交均价的交易价格。
标准的VWAP 策略是一种静态策略，即在交易开始之前，利用已有信息确定提交策略，交易开始之后按照此策略进行交易，而不考虑交易期间的信息。
改进型的VWAP策略的基本原理是：在市场价格高于市场均价的时候，根据市场价格的走势，不同程度地减少提交量，在保证高价位的低提交量的同时，能够防止出现价格的持续上涨而提交量过度向后聚集；在市场价格低于市场均价的时候，根据市场价格的走势，不同程度地增加提交量，在保证低价位的高提交量的同时，能够防止价格的持续走低而提交量过度提前完成。

## 套利
典型的套利策略通常包含三、四个证券，譬如根据外汇市场常用的利率平价理论，国内债券的价格、以外币标价的债券价格、汇率现货及汇率远期合约价格之间将产生一定的关联。如果市场价格与该理论隐含的价格偏差很大，大得超过其交易成本，那么可以用四笔交易来确保无风险利润。算法交易允许类似的套利使用更复杂的模型，其中可以包含四个以上的证券。股指期货的期现套利也可以用算法交易来完成。

## 做市
做市包括在当前市场价格之上挂一个限价卖单或在当前价格之下挂一个限价买单，以便从买卖差价中获利。花旗集团在2007年7月购买的自动化交易平台（Automated Trading Desk）就是一个活跃的做市商，它占到了纳斯达克和纽约证券交易所总成交量的6%。

## 复杂策略
“基准点”算法被交易员用来模拟指数收益，而“嗅探器”算法被用来发现最动荡或最不稳定的市场。
任何类型的模式识别或者预测模型都能用来启动算法交易。神经网络和基因编程也已经被用来创造算法模型。
麻省理工学院金融工程实验室主任Andrew Lo表示，“现在算法交易开始成为一场军备竞赛，每个人都在设计更复杂的算法，而且竞争越多，利润空间越小。”


交易量加权平均价格算法VWAP
保证成交量加权平均价格算法Guaranteed VWAP
时间加权平均价格算法TWAP
交易量固定百分比算法TVOL
基准价交易算法PriceInLine
执行差额算法IS
隐藏交易单算法Hidden
游击战算法Guerrilla
狙击手算法Sniper
搜寻者算法Sniffers
复杂事件处理算法CEP
模式识别算法Pattern Recognition 

网格交易法了，后来才开始逐渐想其他交易模型转。从我所知，主要的交易方式分为：趋势型，网格型，剥头皮，概率法则，高频交易，神经网络，基因算法


# 算法交易策略简介
    算法交易的核心在于交易策略的构建，好的算法交易策略能够有效控制交易成本，实现交易价格的最优化。接下来我们就简单介绍一下市场上最为常见的一些算法交易策略。

## （一）TWAP策略
    TWAP（Time Weighted Average Price），时间加权平均价格算法，是最为简单的一种传统算法交易策略。该模型将交易时间进行均匀分割，并在每个分割节点上将均匀拆分的订单进行提交。例如，A 股市场一个交易日的交易时间为4 小时，即240 分钟。首先将这240 分钟均匀分为N 份（或将240 分钟中的某一部分均匀分割），如240份。TWAP 策略会将该交易日需要执行的订单均匀分配在这240 个节点上去执行，从而使得交易均价跟踪TWAP


    TWAP 策略设计的目的是在使交易对市场影响最小化的同时提供一个较低的平均成交价格，从而达到减小交易成本的目的。在分时成交量无法准确估计的情况下，该模型还是较好地实现了算法交易的基本目标。但是TWAP 遇到比较大的问题是，在订单规模很大的情况下，均匀分配到每个节点上的下单量仍然较为可观，仍有可能对市场造成一定的冲击。另一方面，真实市场的成交量是在波动变化的，将所有的订单均匀分配到每个节点上显然是不够合理的。因此，人们很快建立了基于成交量变动预测的VWAP 模型。不过，由于TWAP 操作和理解起来非常简单，因此其对于流动性较好的市场和订单规模较小的交易仍然较为适用。

## （二）VWAP策略
    VWAP（Volume Weighted Average Price），成交量加权平均价格算法，是目前市场上最为流行的算法交易策略之一，也是很多其它算法交易模型的原型。首先定义VWAP，它是一段时间内证券价格按成交量加权的平均值

    其中 price 和 volume 分别是某个时点上证券的成交价格和成交量。

VWAP 算法交易策略的目的就是尽可能地使订单拆分所成交的VWAP成交盯住市场的VWAP市场。从VWAP 的定义（2）式来看，若希望能够跟住VWAP市场，则需要将拆分订单按照市场真实的成交量分时按比例进行提交，这就需要对市场分时成交量进行预测。通常来说，VWAP 策略会使用过去M 个交易日分段成交量的加权平均值作为预测成交量，这里就要涉及到M 和权数的确定，这里我们暂不进行深入探讨。更为严格地说，假设需要在某段时间买入一定数量的股票，采用算法交易将这段时间分为N 部分，并预测每部分时间的成交比例（占所需成交量）为 vp ，而市场真实的分段成交比例（占市场真实成交量）为 vm ，市场在每个时点的真实成交价格为 P ，则可以定义跟踪误差


    从TE 的定义（3）式可以看出两点：1、跟踪误差与成交量预测的关系非常紧密，预测结果的好坏直接影响到VWAP 算法交易的结果。2、当某段时间的 vp 超过市场真实 vm 时，有可能造成订单无法全部成交，这样就会造成算法交易执行效率的下降，因此，更为常用的是被称为“带反馈的”VWAP 算法交易策略。 
    所谓带反馈的VWAP 算法交易策略，是指在原有VWAP 跟踪的基础之上，将每个时段未成交的订单按比例分摊至后面的时间段中，这样可以有效提高成交比率。之前所讨论的TWAP 策略也可以采用该类反馈技术，使执行效率大幅提升。
 
## （三）MVWAP策略

    MVWAP（Modified Volume Weighted Average Price），成交量加权平均价格优化算法。其实VWAP 有很多优化和改进的算法，但是最为常见的一种策略是根据市场实时价格和VWAP（市场）的关系，对下单量的大小进行调整与控制，因此我们统一将这一类算法称为MVWAP。

    当市场实时价格小于此时的VWAP（市场）时，在原有计划交易量的基础上进行放大，如果能够将放大的部分成交或部分成交，则有助于降低VWAP（成交）； 反之，当市场实时价格大于此时的VWAP（市场）时，在原有计划交易量的基础上进行缩减，也有助于降低VWAP（成交），从而达到控制交易成本的目的。

    在MVWAP 策略中，除了成交量的预测方式之外（通常也是按照历史成交量加权平均进行预测），同样很重要的是对于交易量放大或减小的定量控制。一种简单的办法是在市场 实时价格低于或高于VWAP（市场）时，将下一时段的下单量按固定比例放大或缩小，那么这个比例参数就存在一个最优解的问题。如果考虑得更为复杂和细致， 这个比例还可以是一个随价格偏差（市场实时价格与VWAP市场之差）变化的函数。由于这里只是对各交易策略做一个简要的介绍，量化处理的细节我们暂不进行 深入讨论。

## （四）VP策略

    VP（Volume Participation），固定百分比成交策略，与VWAP 策略类似，都是跟踪市场真实成交量的变化，从而制定相应的下单策略。所不同的是，VWAP 是在确定某个交易日需要成交数量或成交金额的基础上，对该订单进行拆分交易；而VP 则是确定一个固定的跟踪比例，根据市场真实的分段成交量，按照该固定比例进行下单。
 
    例如，将某个交易日均分为48 段，每段5 分钟。根据预测成交量，按照10%的固定比例进行下单。这样的策略所带来的结果是，当所需要成交的订单金额较小时，可能会在交易时间结束之前就完成所有交 易，从而造成对市场均价跟踪偏离的风险。因此我们认为，该策略适用于规模较大、计划多个交易日完成的订单交易，此时若能选择合适的固定百分比，使得成交能 够有效完成，则VP 是一种可以较好跟踪市场均价的算法交易策略。

## （五）IS策略

    IS（Implementation Shortfall），执行落差交易策略，是以执行落差为决策基础的一种算法交易策略。执行落差被定义为目标交易资产组合与实际成交资产组合在交易金额上的差异。IS 策略的目标是执行落差最小化，或者说是在综合考虑冲击成本和市场风险后，通过需找寻找最优解来跟踪价格基准的一种策略。假设目标交易价格为P0 ，实际交易价格为P ，则IS 策略的最终目标为
 
    为了达到这个目的，目前无论是投资界还是学术界，已经衍生出了各种各样复杂的模型，我们在这里不做详细讨论，只对IS 的基本流程做简要介绍：
1、确定目标交易价格P0 ，作为交易基准，这个价格可以是到达价、开盘价、前一日收盘价等。再设定一个容忍价格 Pr ，作为交易的边界条件。
2、当市场实际价格低于或高于P0 时，按一定的策略下单进行买入或卖出交易。
3、当市场实际价格高于或低于r P 时，不进行买入或卖出交易。
4、当市场实际价格处于P0 和 Pr 之间时，可以按照介于积极和消极交易策略之间的策略进行交易。

    使用IS 的优点包括：

1、IS 策略较为全面地分析了交易成本的各个部分，在冲击成本、时间风险、价格增长等因素之间取得了较好的平衡，更加符合最优交易操作的目标。
2、IS 策略根据目标价格对交易过程的优化，更加符合投资决策的过程。
3、IS 策略多用于组合交易，而对于组合交易来说该算法能够利用交易清单上股票间的相关性更好地控制风险。

## （六）Step策略
    Step 策略实际是一种对价格进行分层成交的策略，目标是在买入（卖出）交易中尽可能地压低（提升）成交均价。简单来讲，Step 就是在不同的价格区间进行不同成交量比例的配臵。例如在VWAP 或TWAP 策略中，通常按照预测成交量的一定比例k 进行实际下单。假设在开市前预计要买入某支前收盘价为20 元的股票，则对其进行成交量分层设定：

 
    开盘后在VWAP 或TWAP 的基础之上，当价格在19 至21 元浮动时，按预测成交量的10%进行成交；当价格超过21 元时则不做任何交易；当价格小于等于19 元时，按预测成交量的30%买入。

    更为激进的一种是称为Aggressive Step 的策略，这种策略在价格低于最优交易区域边界时会将所有市场上的订单统统吃掉。具体来说，Aggressive Step 策略同样在买入（卖出）交易中进行分层，例如在上述交易方案中，前两个区域的策略不变，当价格小于等于19 元时，不管市价跌到多少，都按19 元的限价报单成交，直至价格回升至19 元以上或拟交易订单全部完成。不过这种策略不容易对交易量进行控制，并且容易造成价格异动，增加证券交易的隐形成本。
 
## （七）Sniffers策略

    Sniffers 策略是一类策略的统称。通常该策略会开发一些较为复杂的算法去监控盘口和成交数据，以发现市场参与者中是否存在其他的算法交易者。例如通过少量的试探性下 单，结合一定的算法和成交情况去判断有没有订单是通过算法交易而成交的。如果有其他的算法交易参与者，则通过计算判断，跟随这些算法交易或通过相反的操 作，能否以较大的概率获取绝对收益。如果获利概率较大，则通过有针对性的算法交易策略进行下单。该策略与传统的算法交易不同，不以执行订单为主要目的，而 是以获利为主，属于算法交易中较为高级的一种策略，适用于算法交易已经大规模普及的市场。我国市场无论是从交易制度，还是从算法交易的普及程度来看，目前 都还暂时难以运用该类策略。

## （八）盘口策略
    国外目前很多较为高级的算法交易策略对数据的要求都已不仅仅限于成交量和成交价两个指标，而更多关注的是市场微观结构，特别是盘口中出现的一些重要信息。
 
    举一个最简单的算法例子，称之为盯住盘口策略（PEG），该策略随时根据目标股票的盘口情况进行下单。 PEG 首先会实时监测盘口中的最低卖出价格或最高买入价格，并按照一定的策略（或比例）下达买入限价指令或卖出限价指令。如果交易指令未能完成，并且市场价格开 始偏离限价指令的价格，则对上述订单进行撤单，并且根据最新的盘口信息重新发出相应的限价指令；如果交易指令全部完成，继续按照上述策略（比例）发出买入 限价指令或卖出限价指令，直至订单全部完成或交易时间结束。该策略的优点在于对市场的冲击可以做出较好的定量控制，而缺点在于跟踪市场均价容易出现偏离， 并且每个交易日的成交量不可控。

## （九）W&P策略

    Work and Pounce 策略，简称W&P 策略，是在一般算法交易策略的基础之上，通过市场盘口及流动性情况对算法交易进行进一步优化的一种策略。具体来讲，当执行某种算法交易策略时，系统会将拆分后的订单在一定的时间按一定的价格进行挂单。
 
    此时如果跟踪盘口数据，会发现所提交的下单价格有可能是主动成交（例如在VWAP策略中就有出现这种机会）。在这种情况下，可以观察相应价格的盘口是否具 有较大数额的挂单，即观察市场在一定的价格范围内是否有多余的流动性存在。如果存在这种流动性，则可以放大交易数量，将市场流动性横扫一空，或仅留存少量 残余流动性。

    W&P 策略适合于有大量订单需要在短期内完成的情况，使用该策略能够有效提高执行效率，但同样对于价格的跟踪可能将产生相对较大的偏差，增加了交易成本的不确定性。从W&P 策略衍生出的策略还包括LMX Hydra、Options Work and Pounce 等，主要关注点都是市场多余的流动性，这里我们不再进行逐一介绍。

## （十）Hidden策略
    Hidden 策略实际上是一种主动成交型算法交易策略。对于传统的TWAP、VWAP 等策略，由于下单时往往是按市价下单，因此可能会夹杂有主动成交和被动成交两种交易。但是当被动挂单和撤单次数较多的时候，特别是在较为发达的金融市场 中，算法交易者甚至算法交易策略本身容易被其他竞争对手观察和监测到，从而使得竞争对手可以针对算法本身开发出具有针对性的策略。Hidden 策略就是这样一种反侦察的算法交易策略——当市场盘口中出现了希望成交价位的委托单，并且达到一定数量时，则主动出击将委托单吃掉；否则伺机而动，直到满 足条件的机会出现为止。总体上来说，Hidden 策略也是一种对原有算法交易策略进行再优化的策略，其主要运用在欧美等较为发达的金融市场上，在隐藏自己的行动的同时也付出一部分跟踪市场均价准确性的代 价。

## （十一）Guerrilla策略
    Guerrilla 也是在一些原有算法交易策略的基础之上进行进一步优化的一种策略，其目的同Hidden 策略一样，都是为了隐藏自己的策略和交易行为。不同的是，Hidden 是在主、被动成交及下单数量方面进行考虑，而Guerrilla 的出发点仅仅是下单数量。通过一定的随机算法，Guerrilla 策略会将每个时段应该提交的订单数量
进一步打散成为不同尺寸的部分，从而使得其他竞争对手在交易明细中不容易看出算法交易者和相应算法的存在。

## （十二）其他策略
    除了上述介绍的一些常用算法交易策略以外，在国外市场上目前还存在非常多的策略，例如仅VWAP 一种基础的算法交易策略就可以衍生出几十种甚至上百种策略；再例如在国外做市商制度的存在下，市场上还有一批基于该交易制度的常用算法交易策略，如 Guaranteed VWAP、SOR 策略等，我们在本篇报告中不逐一介绍。总而言之，很多算法交易策略在使用一段时间后往往由于信息的泄露或者市场微观结构的改变而不再适用，投资者就需要继 续开发新的策略。因此，各种算法交易策略总是如雨后春笋一般在市场上出现，然后消失，轮回。但无论如何，各类算法交易策略的出现都是为了对交易成本进行有 效控制，因此，这类交易策略在计算机和网络技术突飞猛进的今天，将会越来越多地占领整个市场的交易份额，目前来看这是一个不会改变的大趋势。因此，各种各 样新的策略也需要不断被开发，不断去适应新的市场环境。我们的算法交易系列报告也会在回顾传统交易策略的同时，不断开发新的策略，从而使投资者能够紧跟市 场的步伐，有效、合理地控制交易成本。

# 程序化交易系统大全

一、趋势跟踪类
1、海龟交易系统
2、趋势线突破交易系统
3、波动性突破交易系统
4、通道突破交易系统
5、四周规则
6、NEWS交易系统
7、MACD交易系统
8、EMA交易系统
9、均线交易系统
10、三重滤网交易系统
11、SAR交易系统
12、OBV交易系统
（另有：双均线交易系统、克罗均线系统、时间价格突破、LSS多空强弱、单均线交易系统、趋势跟踪类全套产品、不动如山SAR、浮动波动性突破、、鳄鱼法则等系统）
二、反趋势振荡类
1、网格交易法
2、海岸线交易系统
3、假突破交易系统
4、布林带交易系统
5、薛斯通道交易系统
6、经典K线交易系统
7、RSI交易系统
8、KDJ交易系统
9、乖离率交易系统
10、江恩回调带交易系统
11、技术背离交易系统
12、量价背离交易系统
（另有：维克多123法则、BOLL通道交易、反四周规则、SLOWKD、单摆震荡原理、LSS轴点封套、BIAS交易系统、价格通道交易、CROC动能震荡、分形交易系统等系统）
三、波段交易类
1、海浪交易系统
2、天堂地狱交易系统
3、矩形交易系统
4、旗形交易系统
5、楔形交易系统
6、三角形交易系统
7、八段交易系统
8、波浪理论交易系统
9、123法则交易系统
10、跳空交易系统
11、江恩轮中轮交易系统
12、时间周期交易系统
（另有：二浪底公式、KDJ半空反转、ADX两栖交易、RSI半空反转等系统）
四、套利套保类
1、无风险跨期套利交易系统（分品种）
2、跨品种套利交易系统
3、大豆提油套利交易系统
4、跨市场套利交易系统（分品种、分市场）
5、蝶式套利交易系统
6、企业套期保值交易系统
7、价差趋势交易系统
五、日内短线交易类
1、早盘心理交易系统
2、缺口交易系统
3、早盘突破交易系统
4、横盘突破交易系统
5、日内海浪交易系统
6、高低点交易系统
7、日内趋势线交易系统
8、分时图三角形交易系统
9、日内网格交易系统
10、BTOB交易系统
11、100%回撤交易系统
12、成交量交易系统



# 回测问题

1、交易成本
交易成本除了显式的佣金、印花税等外，还有一些隐式的成本。在回测中，隐式交易成本容易被忽视。隐式交易成本主要有流动性成本、机会成本。
流动性成本（冲击成本）：大规模市价买入或卖出时，由于大单对市价的冲击从而未按照预定指令价位成交。
机会成本：限价买入时，不会产生流动性成本，但可能会因为指令不执行错过获利机会。
降低交易成本的方法有：
降低佣金：避免交易低价股
降低市场冲击成本：限制单个指令的交易规模（单个指令不超过日均交易量的1%，将大额指令拆成小额分别执行）
2、滑点
滑点指的是开仓点位和成交点位之间的差异，前面说到的流动性成本是形成滑点的一种。除此之外，滑点还可能因为网络延迟、交易平台不稳定等情况导致。
实盘中处理滑点的方法需要在下单交易的时候做算法处理，并且选择交易一些流动性较高的品种。在回测中，我们一般会在程序中设置固定数值的滑点。
3、幸存者偏差
产生'幸存者偏差'的原因是“死人不会说活”。在对策略回测的时候，我们一般只会选择那些在回测期有数据的股票，那些在回测期或者在回测期前就退市了的公司默认被排除了。于是回测的结果是对仍存活的公司而言，破产、退市、兼并、收购而消失的公司并不会在回测中体现。
避免“幸存者偏差”的简单方法是使用近期数据进行回测；如果需要使用较远期的时段进行回测，那么需要选择没有遗漏“非幸存者”的数据集。
4、未来函数
未来函数是指在进行买卖信号判断的时候，利用了未来不确定的行情信息。使用了'未来函数'的策略能够预知未来，得到极其夸张的收益率也不足为奇。未来函数的错误在策略设计的时候就能避免，判断信号是否出现的时候只能使用已有的行情信息。
5、过拟合
过拟合产生于策略模型中过多的规则和参数。过拟合使得策略在回测期表现非常好，但将模型和参数用到当前行情时却十分糟糕。
Machine Learning中判断过拟合问题的方法同样也可以用于量化模型中，主要有交叉检验，模拟测试以及敏感性测试等办法。采用这些方法可以对量化策略模型是否存在过拟合问题进行检验，若存在过拟合问题则必须对模型进行调整。
6、偷价格
未来函数是采用未来的信息进行交易，而偷价格则是利用信号触发前的价格进行交易。在信号被触发时，我们只能使用信号触发时的价格进行交易，而不能用已经成为过去的价格。
在一般的情况下，偷价格是很容易避免的，但是如果跳空和交易信号同时出现时很容易犯偷价格的错误。由于跳空造成的价格不连续，指定的价格不会触达策略设置交易的价格，如果使用该价格下单那么会出现偷价格的现象。
7、复权
由于股票存在股利分配等股本的变动，其价格会做一定的调整，这种非正常的价格变动在回测中是要被排出的，因此需要使用复权后的数据进行回测。在拿到历史数据集时，一定需要了解价格数据是否做了复权的处理。
一般来讲，在回测中采用前复权的数据，前复权是保持现有价位不变，将以前的价格进行缩减，这种处理是以当前价格为基准进行调整，较后复权更直观一些。当然，采用用向后复权也不会有太大问题，在计算策略收益率的时候两者结果是一致的。



因子选股

机构有三宝，选股，择时，风控好。


量化选股
多因子模型总体分为基本面选股、市场行为选股。
基本面选股包括：多因子模型，风格轮动模型，行业轮动模型。
市场行为选股包括：资金流选股，动量反转模型，一致预期模型，趋势追踪模型和筹码选股


# 庄股
　　无论是这次的济民制药，还是之前的中潜股份(124.860, -4.62, -3.57%)（维权），都具有典型的“庄股”特征。
　　一是看成交量能，“庄股”成交量、换手率均极低。
　　济民制药在6月11日爆出历史天量前的一年内，虽然股价累计涨幅超过45%，但日均换手率仅为0.41%。

　　同理，中潜股份在股价见顶前的4个月内，虽然股价大涨超过250%，但日均换手率仅为0.52%。

　　可供参照的是，所有A股在过去一年内，单日换手率的算术平均值为3.23%。
　　二是看股东户数，“庄股”在庄家吸筹过程中，股东户数会急剧缩减。
　　济民制药自2018年半年报至今，股东户数持续大幅缩减。2018年半年报公司股东户数19061户，2019年年报股东户数最低至4336户，一年半间缩水达77%。

　　济民制药股东户数变化
　　中潜股份2018年三季报股东户数17903户，今年3月10日公司公布的数据最低到3711户，不到一年半间缩水79%。

　　中潜股份股东户数变化
　　三是股价走势。“庄股”一般无视大盘走势，庄家吸筹过程股价几乎不调整；庄家派发筹码过程中，股价往往出现日内“锯齿形震荡”。
　　6月11日，济民制药在股价高位爆出历史天量，全天成交15.54亿元。回顾济民制药当天走势，日内分时图呈现连续“锯齿形震荡”。

　　济民制药6月11日分时走势
　　市场人士分析，类似的“锯齿形震荡”，实际上是由于庄家“左手倒右手”所致，目的是带动股票放量，吸引散户高位接盘，从而派发手中筹码，投资者看到类似走势务必要十分谨慎。




# 交易策略性能测试报告

净利润： 绝对值（总盈利金额 - 总亏损金额） （盈利为黑色数字，亏损为红色）
总盈利： 总交易盈利金额 - 手续费
总亏损： 绝对值（总交易亏损金额 - 手续费）显示为红色
总盈利/总亏损： 绝对值（总盈利 / 总亏损）

交易手数： 总的交易数量
盈利比率： 盈利手数 / 总交易手数
盈利手数： 盈利交易的总手数
亏损手数： 亏损交易的总手数
持平手数： 持平交易的总手数

平均利润： 净利润 / 交易手数
平均盈利： 总盈利金额 / 盈利交易手数
平均亏损： 总亏损金额 / 亏损交易手数  （显示为红色）
平均盈利/平均亏损： 绝对值（平均盈利/平均亏损）

最大盈利： 盈利最大的单次交易的盈利金额
最大亏损： 绝对值（亏损最大的单次交易的亏损金额）
最大盈利/总盈利： 如字面所示
最大亏损/总亏损： 如字面所示
净利润/最大亏损： 如字面所示

最大连续盈利手数： 若将手数设为固定一手，则此手数也就是最大连续盈利次数
大连续亏损手数： 若将手数设为固定一手，则此手数也就是最大连续亏损次数
平均持仓周期：总交易的bar的总数 / 交易次数
平均盈利周期：总盈利交易的bar的总数 / 盈利交易次数
平均亏损周期：总亏损交易的bar的总数 / 亏损交易次数
平均持平周期：总持平交易的bar的总数 / 持平交易次数

最大使用资金： 以bar的收盘价来计算的最大持仓保证金（组合测试时为多个策略共同 计算的最大使用资金量）
佣金合计： 总共的佣金金额

收益率： 净利润 / 初始资金
年度收益率：有效收益率 / （总交易的天数 / 365）
有效收益率： 净利润 / 最大使用资金
月度平均盈利： 净利润 / 总交易的天数 × 30.5 

收益曲线斜率： 根据交易盈亏曲线拟合的趋势线的斜率
收益曲线截距： 根据交易盈亏曲线拟合的趋势线的截距 
收益曲线R平方值： 根据交易盈亏曲线拟合的趋势线与收益曲线之间相关系数的平方（具体计算方式可查阅EXCLE表格中R平方值的算法）

总交易时间： 参与测试的全部bar数据的天数
持仓时间比率： 持仓BAR数量 / 总bar数量
持仓时间： 总交易时间 * 持仓时间比率
最大空仓时间： 没有持仓的天数
持仓周期： 持仓的BAR数量

资产最大升水：  最高点金额 - 前期低点的金额
发生时间：  高点发生的所在BAR的日期与时间
最大升水/前期低点： 如字面所示

最大资产回撤值（按Bar收盘计算）
回撤值： 前期高点 - 低点
发生时间： 低点发生所在bar的日期与时间
回撤值/前期高点：（前期高点 - 低点） / 前期高点
净利润/回撤值： 净利润 / 回撤值

最大资产回撤值比例（按Bar收盘计算）
回撤值：前期高点 - 低点
发生时间： 低点发生所在bar的日期与时间
回撤值/前期高点：（前期高点 - 低点） / 前期高点
净利润/回撤值： 净利润 / 回撤值

注意：上述两个回撤的区别在于，前者是按回撤金额的最大值来计算，而后者是按回撤比例的最大值来计算的。比如说，一个原始金额
为10万的帐户，在刚开始交易的一段时间就发生了一个4万的回撤。而此帐户在交易一段时间后，总金额增长到了50万，此时发生了一个8万的回撤。如果
以金额回撤来计算，是后面这个8万的回撤大。但是以比例来计算，则是前面那个4万的回撤大。

# 交易策略参数优化报告

净利润： 绝对值（总盈利金额 - 总亏损金额）
年化收益： 净利润 / 总交易的天数 × 365
盈利比率： 盈利手数 / 总交易手数
平均利润： 净利润 / 交易手数
交易手数： 总交易手数
最大资产回撤：低点-前期高点
TB系数： （平均利润×平均利润×交易次数）/（平均盈利×平均亏损）
增长系数： 根据交易盈亏曲线拟合的趋势线的斜率
收益风险比：年度收益 / 最大资产回撤 
R平方值： 根据交易盈亏曲线拟合的趋势线与收益曲线之间相关系数的平方（具体计算方式可查阅EXCLE表格中R平方值的算法）
置信度： 根据测试的交易次数计算的置信水平，计算公式为：1-1/Sqrt(交易次数);
头寸系数： 收益风险比*R平方值*置信度 / 最大资产回撤
资产回撤计数： 资产回撤发生的次数（是以超过最大回撤基准线以上的回撤来计算的，此基准线在“全局交易设置中”进入设置）
平均资产回撤： 资产回撤总金额 / 资产回撤计数（都是以超过最大回撤基准线以上的回撤来计算的，此基准线在“全局交易设置中”进入设置）
调整收益风险比： 年度收益 / 平均资产回撤 (年度收益 = 净利润 / 总交易时间 * 365)
夏普比率：量化收益与风险的比值，具体算法参考互联网上的夏普比率计算方法
盈亏比： 平均盈利 / 平均亏损
总盈利： 总交易盈利金额 - 手续费
总亏损： 总交易亏损金额 - 手续费
盈利手数： 盈利交易的总手数
亏损手数： 亏损交易的总手数
连续盈利手数： 如字面所示
连续亏损手数： 如字面所示
最大盈利： 盈利最大的单次交易的盈利金额
最大亏损： 亏损最大的单次交易的亏损金额
平均盈利： 总盈利 / 盈利交易手数
平均亏损：总亏损金额 / 亏损交易手数
平均盈利周期：总盈利交易的bar的总数 / 盈利交易手数
平均亏损周期： 总亏损交易的bar的总数 / 亏损交易手数
盈利因子：  总利润 / 总亏损
最大资产回撤比率%： 最大资产回撤 / 前期高点

------------------------------------------------------------------------------
平仓效率总效率 = （平仓价-开仓价）/（最佳平仓价- 最佳开仓价）
建仓率效 = （最佳平仓价-开仓价）/（最佳平仓价- 最佳开仓价） 
平仓率效 = （平仓价 - 最佳开仓价）/ (最佳平仓价- 最佳开仓价)


# 风险回报比

"风险回报比"大概有两个作用:
1. 进行资产之间(或基金经理)之间的对比
2. 作为资产组合配比最优化算法的原函数 (objective function)
单独来讲:
夏普比率 = (平均收益 - 国债利率)/波动率
理论取值区间: 负无穷-正无穷
实际常见取值区间: 再0左右晃荡
用法: 越大越好
通俗来讲: 平均净收益与平均波动率的比值
非常过时的一个比率, 个人非常讨厌, 毁了很多代人, 能躲多远就躲多远吧...
詹森指数 = (平均收益 - 国债利率) - 股指同动率*(股指平均收益 - 国债利率)
理论取值区间: 负无穷-正无穷
实际常见取值区间: 再0左右晃荡
用法: 越大越好
通俗来讲: 这个数值代表了基金经理的"能力." 如果股指暴涨, 你的资产组合也暴涨, 那是应该的, 不算你的能力, 只能算你的运气. 如果不管股指暴涨或者暴跌, 你的资产组合总能比股指多赚一点, 那证明你有"能力."
所提诺比率 = (平均收益 - 国债利率)/损失波动率
理论取值区间: 负无穷-正无穷
实际常见取值区间: 再0左右晃荡
用法: 越大越好
通俗来讲: 平均净收益与平均损失波动率的比值
我估计没人用这个... 什么年代了... 谁会用损失波动率来作风险衡量?
Omega比率 = 赚钱几率/赔钱几率
理论取值区间: 0-正无穷
实际常见取值区间: 0.8-2之间
用法: 越大越好
本人喜欢...
Rachev比率 = 挣大钱的几率/赔大钱的几率
理论取值区间: 0-正无穷
实际常见取值区间: 0.5-1之间
用法: 越大越好
本人喜欢...
STARR比率 = (平均收益 - 国债利率)/尾部风险
理论取值区间: 负无穷-正无穷
实际常见取值区间: 很广泛, 这也是STARR的缺点之一, 很难去横向比较不同类型资产
用法: 越大越好
比较喜欢, 只是不好用, 很难比较不同类型资产, 比如说债券和股票用STARR来比较, 肯定是债券永远比股票高, 因为债券尾部风险总是比股票小. 导致无法比较...

1. 看好算这些比率所用的时间段, 就算是同一个资产, 用前五年算出来的和前两年算出来的截然不同
2. 看好用的什么模型算, 大概有条件性和非条件性. 条件性模型会反映"实时"情况, 非条件性模型会反映"平均情况"
3. 历史表现不代表任何未来表现, 在牛逼的夏普比率, 明天也能跌得像狗
4. 投资很复杂, 不可能就看一个比率定乾坤. 做组合要看: 回报, 风险和资产之间的运动关系
5. 不要太膜拜任何一个比率


# 十种日内趋势跟踪的交易方法
交易只需要解决这么三个问题：第一：何时进场？第二：每次下多少手？第三：何时出
场？
一、百变万能的十种入场模式
E1：RANGEBREAK
波动区间突破交易，根据昨天波动幅度的一定百分比，来触发当日的趋势交易，如果昨
天的波动幅度是异常的，应当对该波动幅度进行必要的调整，以保持合理性。
E2：菲阿里四价
昨天高点，昨天低点，昨天收盘，今天开盘，可并称为菲阿里四价，它是由日本期货冠
军菲阿里实盘采用的主要突破交易的参照系，此外，因菲阿里主观心智交易的模式，决
定了其在实际交易中，还大量结合应用了“阻溢线”的概念，即我们通常所说的压力、
支撑线。
E3：空中花园
开盘突破，是最快的一种入场方式，当然出错的概率也最高，开盘第一根K线是收阳，还
是收阴，是判断日内趋势可能运动方向的标准，我们发现这种入场在当天开盘高开或低
开时更为有效。在《期市截拳道》中，我把这种交易策略称为“空中花园”，有幸的是
，听说西蒙斯在早期也曾经应用过类似的交易策略。
E4：横盘突破
较易于实现量化的形态突破，有分型，窄幅横盘突破，各种K线组合、双顶、双底、缠论
三买三卖等，较难于实现量化的形态突破，有趋势线、圆孤顶底、旗型、菱形、三角形
等各种经典技术分析形态，趋势之后是盘整，盘整之后是趋势，横盘突破的交易策略，
充分体现了波动性循环的价格波动规律，我们需要做的事情就是合理量化盘整的定义：
周期跨度、波动幅度。
E5：基于固定百分比幅度的转向交易
该系统曾在某交易系统策略大赛中荣获第二名的殊荣，也是笔者最为衷情的日内突破交
易策略。相对而言，基于固定点位的突破，可能会受制于品种价格区域的变化而变迁，
基于固定百分比幅度的突破，则较少受到类似的困扰，除非该品种的波动性水平发生巨
变。
E6：HANS123
作为外汇市场上广为流传的一种突破交易策略，HANS123以其简捷的开盘后N根K线（分钟
）的高低点突破，作为交易信号触发的评判标准。这也是一种入场较早的交易模式，配
套价格包括带、时间确认、波动幅度要求等项过滤技术、或可提高其胜算。
E7：日均ATR波动性突破
我们有理由相信，当一定幅度的ATR波动性幅度已经发生，我们将更愿意去赌日内波动的
方向朝着这个已经完成一定幅度ATR的方向继续发展，比较的基准，可以是开盘价，也可
以是日内创下的新高、新低记录位置。
E8：ORB失败突破
ORB交易最早于1988年由美国基金经理托比提出，它通过衡量开盘价与最高价、最低价距
离的取小者，为失败突破幅度，后市一旦超出这个幅度，就认为真正的突破。在实际应
用过程中，早评的突破、窄幅波动日后的突破，可以作为有效的过滤条件。
E9：分时均价黄线
在此我无意讨论其它均线系统的日内表现，分时均价黄线，因其广泛出现于各类交易软
件的内置分时走势图中，因而，就交易策略的自我实现预言而论，它的地位格外突出，
醒目。
E10：日内ATR波动性突破
与E7不同，E10更侧重于短期市场波动率的变化评估，波动性突破，在一定程度上具备适
应市场的功能，在实际应用于适应不同市场环境的能力更强。
二、日内趋势交易的过滤技术
虽然我们的出发点是要回避隔夜跳空的不确定下与趋势的不连续性。因而，过滤技术，
其实是从事日内趋势交易系统设计的一项关键技术。
F1：波动性过滤
F2：价格包络带过滤
F3：时间确认过滤
F4：交易次数过滤
F5：日间时过滤
F6：周间日过滤
F7：系统策略组合过滤
三、百变万能的出场分散化战略
会买的是徒弟，会卖的是师傅。事实上，我们经常会遇到出场策略上的纠结困扰。出早
的，赚不够；出晚了，利润又面临大幅回吐。事实上，没有任何一种出场策略，是可以
让你永远占便宜的。在高度随机的日内交易中，我们能够做的事情只有承认无知，并实
施分散化战略，以求得平滑在各种走势下的资金总体曲线。
O1：固定初始止损、利润目标止盈
O2：固定初始止损+跟踪止盈（点数、幅度）
O3：不动如山的SAR抛物线出场
O4：固定初始止损+利润回撤百分比
O5：固定初始止损+定时平仓（收盘前平仓）
O6：随机出场
O7：对称的反向交易信号出场




# 回测与实盘
策略进行回测和未来效果预估。
1回测结果来看，首先如果你的策略超级赚钱，年化收益率/最大亏损值能达到20倍以上，每年获利都超过200-300%，那么最大的可能是——————你用到了未来函数。仔细检查流程，看是否在某个环节会用到了在实际情况中不可能得到的市场信息。比如在一分钟开始阶段就用到了本分钟的最高最低价，或忽略了K线内最高最低价产生的先后顺序。最好的杜绝未来函数的方法是在回测时编程采用流程控制，将行情数据每个tick推入，得到交易结果。
2检查参数使用数目。很显然，参数使用越多，策略泛化能力的越差。就日内趋势类策略而言，在回测时需要遍历的参数最好不要超过三个。当然具体还是要视策略本身的构造和样本内外测试结果而定，不能一概而定。
3交易频率判断，交易频率越低，策略的泛化能力越差。交易频率低，说明策略本身就是参数优化后找到的特例结果。
4观察本身市场结构是否发生了变化，策略本身都有自己的适应点和不适应点，进入市场后很可能正好运气不好，赶上了不适应期。所以要对本身策略有一定的宏观理解，来判断当前行情是应该赚钱还是亏钱，判断如果亏钱是因为本身行情层面不给力还是策略层面出了问题。
5其他交易细节，比如报单时延、期望成交价格拿到概率、平均滑点、其他交易规则限制等等等等就不一一列举。 
策略回测，应该是讨论编出来的模型的。辛苦编出来一个模型，一测试，嘿！简直暴富机器啊！欢天喜地去实盘，结果呵呵。我觉得这种情况是非常正常的，所以很多名家也倾向于编出模型后也是谨慎的模拟一段时间再看。至于原因，我按照发现的难易程度来说一下。
1.未来函数（E）：这个简单，自己骗自己，zig，peak，从源码来看就是，得了解常见的未来函数，别编进去。如果是别人给你的，从结果来看，好得离谱的，胜率过高的，基本要打问号怀疑未来函数了。
2.成交偷价（D）：这个貌似有好些人用的，未来函数检测不到，但我觉得应该归为未来这一类，比较隐性。比如一个做多信号出来了，我不按照当前价，而是按照之前的最低价成交，回测是完全可以的，但是显然，实际是做不到的。一来一回10个点，一年下来，啧啧啧，回测报告简直心旷神怡。
3.成交模式（D）：回测很难做到完全反应当时实盘情景，这就有基本两种模式，等收盘价成交和即时成交。即时成交的模式很难回测，因为回测都是按照固定收盘后测试的，这个也是很隐性的问题。
以上三种都是最基本的，下面就谈谈模型本身没问题情况下的一些注意点。
1.滑点问题（C）：先抛开其他不谈，既然是模型，那就实盘的时候无法避免的问题，滑点，这个是非常致命的。类似于成交偷价的概念，比如模型信号价是2000点，但是市场真能给我这么一个价格吗？成交越活跃，滑点越有可能发生，而且不小。比如一来一回算1个点，那么随着你的交易次数增加，滑点成本会越来越大。当然顺带说的还有经纪公司的手续费，这倒是可以慢慢谈妥的。
2.曲线拟合（B）：这个就真比较隐性了，貌似很多人都提到这么一个说法。其实这是一个度的问题，你说模型不去一定程度的拟合过去，那测试报告一定都不堪入目。你说模型要去最大程度的拟合过去，那可想而知你模型的脆弱性。就像回归分析，你项数设置越多，越能拟合，但对未来失效性就越大。
一般地，回测交易系统，需要从稳健性（Robustness）分析的角度特别留意以下四点。
第一，历史回测的期间必须足够长。
一般来讲，对于国内的股票、商品，应该回测5年以上的数据，对于新上市的品种，至少也要回测3年。对于上市较早的品种或国际市场的黄金、美元指数等商品，则应至少回测一个牛熊周期，一般应该在10年–15年以上。回测的期间足够长久，回测的成绩才足够可靠。对于不能满足这个要求的品种，则应在开仓时将R值适当加权处理，主动降低风险暴露。
第二，分析回测成绩，应予以“断代”处理。
一个稳定、可靠的交易系统，在一定期间范围内，成绩应该相对稳定。仅靠一两波大行情拉高整体回测成绩的，会使使用者高估系统的价值。例如，回测上证指数时，如果仅仅将2005年–2007年的大牛市纳入总成绩，而没有逐年的回测数据，很可能会因为一次牛市而高估了一个本来绩效一般的系统。我的经验是，按年予以断代，分析各年的回测绩效。完全平均的回测成绩是不可能的，一个优秀的系统应该满足两个条件：单一年度不出现巨大亏损；各年整体稳定盈利，偶尔出现超额获利。
第三，回测系统后应该防止“过度优化”，尽量减少参数变量，防止“参数孤岛”。
过度优化（Curve Fitting，也可称为“曲线拟合”）是交易系统回测的最大敌人。一个交易系统应以简洁为上，少用参数变量。对于采取了变量参数的系统，最优参数附近的参数也应具备不错的绩效，形成“参数高原”。应防止过度优化后的“参数孤岛”。
第四，交易系统应经历多品种回测检验
一个可靠的交易系统应该具备普适性，不能仅仅适用于个别交易品种。只能用于一个品种的交易系统，往往是过度优化的产物。需要特别说明的是，不同品种间可以结合品种特性进行一些针对单一品种的微调。比如结合不同品种的ATR情况，根据日K线的振幅过滤一些非常态下的开仓信号等。这种根据具体品种采取的个性化调整不属于过度优化。
压力测试包括多参数、多周期、多品种等大范围的测试。
通过以上标准，不会保证一定赚钱，但会保证在仓位管理合理的情况下，不会轻易死的很惨 
很多看似好用的标准：
参数优化的时，收益对参数变化不能太敏感。
收益在参数空间中的分布是比较连续的。
等等。
这些有用吗？我觉得未必。
但事实上，交易样本绝对数量是一个标准，还有一个标准是，交易样本占整个样本空间的比例。
比如如果，你有10亿的样本 ，
你找到了一个交易1000次的策略表现很好，
但由于1000次在10亿次当中的比例实在太小了，
我们完全有理由怀疑，这只是随机效应。
很多高频策略，失效极快，
未必是跟市场变得有效有关系，也许策略本来就无效。
这个判断标准在关联分析中叫做支持度，同样地，也有置信度。
当然，支持度，置信度也都是人为设定标准的。
那么什么标准最合适？谁都不知道，只能凭运气和经验。
编策略时的一些思考，不是科班出身，想法可能跟他们不同：
1未来函数
2过度拟合造成的样本频率太低
这两个我不说了，也遇到过。
3瞬时波动造成的k线动作。如果你是低级别k线策略，在流动性不高的市场，遇到这种波动是无法交易的，因为容量低。如果是高流动性商品，但是打压严重，或者就是对倒的利益输送，在买单卖单上你介入不进去，除非你的是是自动下单而且通道好，打个时间差。
4如果短期策略必须对介入价格非常明确，这里不是说高频，不能存在人为的干预，这种买入卖出非常明确，是cross不是大于小于。
5如果是中长期策略，经典的问题就是人的问题，能坚持么？人对他的运行影响大不大，让一个什么都不懂的能参与么？回撤你应该是考虑了，也不说了。
6买卖价位上是否存在某周期内低点，或者某周期内高点的问题，这一定意义上也是未来时，我不知道你做的什么期货或者股票，股票的话这点尤其很严重，介入点选择为当日低点，这也是用未来时，用的话必须选择很大的滑点，或者采用分批进场。
我这个民间投资者就是想到这么多，给个建议，按收益排列交易数据后，按时间排列统计，你会有别的发现。
两种可能
1. 测试的区间不够久
2. 测试的区间正好是下降通道、上升通道、波动通道中，遇到了不同的市场趋势，当然不灵了
所以建议使用固定时间段，然后做roll over测试。然后看结果。
PPS,如果仅仅回测股价，那没什么意义。因为股价以时间序列来预测的话，准确性会随时间的平方成反比。股价基本上符合随机漫步理论，或者说醉水手原理。时间越久，越难预测。反而应该预测，收益率的standard deviation。就不详细说背后的数学原理了，不信的话，自己做出图，然后看看。 
先说一下对已有回答的不同意见：
1、过去不能代表未来。事实上我们做交易大部分流派的基石就是”已有的事后必再有，已行的事后必再行，日光下并无新事（《圣经.传道书》）“。只不过策略本身可能在过度拟合等方面犯了错误。
2、滑点。策略的周期越长，越偏向于高赔率低胜率的趋势系统，滑点的影响就越小。这个一般不是实盘出问题的主要原因。
3、流动性。这个一般在回测之前就要选好，如果是高频策略且准备大资金介入，就不要在半死不活的市场品种浪费时间。
再补充几个没提到的，都是实际经验，分享讨论一下：
1、回测周期匹配的问题。如果实测周期与回测不匹配，误差就会很大。回测较短周期的数据，常常因为事件的影响或短期内大趋势的影响等，导致“效果很好”；而回测十数年以上的大周期，实盘策略短时间内又看不出效果。这是假设你模型本身没问题，且具有长生命力。
2、模型本身的问题。参数越多的模型，死的越快，需要不断更新；而非常简单的策略，却可能是市场中的”永动机“，最多沉寂几年，便又再生。所以想要策略长生不老，需在优化和过度优化中做个选择，也可能是在收益率与策略生命中的选择。
3、资金管理的问题。回测只是解决了出入场信号的问题，要把仓位管理加入到回测当中。如果回测和实盘都使用同样的资金管理系统，偏差不会太大。
4、心理。大家都提了，但是再多的强调也不为过。如果纯自动交易，则不存在。 
我的建议是，依次了解并检验下面的内容，原因是在我的经验里，这些问题出现的概率是由高到低的：
1. 算错了。不是我乱回答好嘛，是血的教训啊。在我做量化测试的历史里，回测出现有显著盈利能力结果时，95%以上是这个原因导致的错误。例如，某个负号在计算时漏掉了、百分号忘记除了、不同语言下迭代0和1起始点的混淆，等等等等，往往会给出一个好到我觉得必将改变世界的结果。所以本人现在都养成了只要结果很好，一定先彻查是否算错的习惯。
顺便给个我用来判断结果是否过好的检测手段。鉴于我的交易策略跨度比较大，因此需要一个适用性广泛的手段，我的做法是用期望为0的正态分布模拟资产回报率，首先使用历史数据估计出标准差，然后模拟n段测试期等长的回报序列，从而得到n个交易策略盈亏结果，如果实测结果在这n个结果的尾部两端，就说明结果过好或过坏。这是单资产的交易策略，如果是多资产，融合相应的组合流程即可。当然也存在一些变种，例如求得概率结果而非直观的盈亏结果等进行判断。不过本人大部分时间都不会做的那么详细，受打击的次数多了，稍微看看都知道是不是有问题了。
2. 未来函数。其他答案中多次出现了这个提法了，说明确实是一个根本性问题。未来函数的杀伤力在于，它会出现的不知不觉。例如一个著名的分析师语言：“在熊市末期积极建仓，在牛市末期卖出股票”，我要是知道这是末期了，我还听你这些话干什么啊。还比如做量化的时候对曲线的平滑、整体模型的估计、统计特征的提取等等，都应该注意未来函数的出现。
要控制它的出现，唯一要做的就是小心，因为逻辑中的错误，比前面说的“算错了”更难以检查出来。我自己的经验是，在编制测试流程时严格按照时间顺序进行，样本内的计算就强迫自己彻底屏蔽样本外的数据。一句话，经验是财富。
3. 存活者偏差。这是“未来函数”族群中的王者，单独拿出来说。下面的内容来自维基百科：
幸存者偏差（英语：survivorship bias），另译为“生存者偏差 [1]”或“存活者偏差”。常用俗语“死人不会说话”来解释其成因。 意思是指，当取得资讯之管道，仅来自于幸存者时（因为无从由死者获得来源），此资讯可能会存在与实际情况不同之偏差。常见于财务金融领域之文章。
此情况常见于投资理财之节目或文章，例如当投资理财之电视节目仅邀请投资成功者上节目谈论其成功投资之经验，观众会将该成功投资者投资之方式，视为高成功率之投资方式，但观众并不会在电视节目看到以相同或类似投资方式，但最后失败的投资者，因而高估此投资方式之成功机率。
用指数或者全市场样本进行长期交易策略测试的同志们，请一定小心指数成分股的变更和股票退市对策略的影响！
4. 过拟合。先给定义，来自百度百科：
为了得到一致假设而使假设变得过度复杂称为过拟合。想像某种学习算法产生了一个过拟合的分类器，这个分类器能够百分之百的正确分类样本数据（即再拿样本中的文档来给它，它绝对不会分错），但也就为了能够对样本完全正确的分类，使得它的构造如此精细复杂，规则如此严格，以至于任何与样本数据稍有不同的文档它全都认为不属于这个类别。
标准定义：给定一个假设空间H，一个假设h属于H，如果存在其他的假设h’属于H,使得在训练样例上h的错误率比h’小，但在整个实例分布上h’比h的错误率小，那么就说假设h过度拟合训练数据。 ----《Machine Learning》Tom M.Mitchell
好吧，数据挖掘的人写的东西，看来国内搞金融的人都高端大气不愿意用百科，有空我把wiki的英文翻译过来好了。针对量化交易的小方向来说，就是说交易策略中参数用多了、或者交易流程设置过于复杂了，导致交易策略过度提取了样本数据中的某些显性信息，而误读了整体数据中的真实信息。如果你有较好的统计基础或者计量基础，你应该明白过拟合的含义，学界为了R方和结果显著性不顾一切乱来的太多了，负面例子不胜枚举，如果不太理解请补课。
5. 泛化能力。与“过拟合”关系密切，在绝大部分情况下就是“过拟合”问题导致的结果，不过含义是截然不同的，且存在例外，因此单列出来。最出名的例外就是现在红火到爆的Deep Learning了，简单来看就是隐层数增加的人工神经网络，所以亦称Deep Neural Network，虽然由于隐层的问题，参数一度多到无法正确估计，但是有了数据量的巨大提升和Autoencoder之类的处理方法之后屌丝逆袭干掉了一众分类算法。最近去百度的吴恩达就是这方面的专家，更不用提Hinton他老人家，Google的科技吉祥物好嘛。扯远了，回来，下面的定义来自百度百科：
概括地说，所谓泛化能力（generalization ability）是指机器学习算法对新鲜样本的适应能力。学习的目的是学到隐含在数据对背后的规律，对具有同一规律的学习集以外的数据，经过训练的网络也能给出合适的输出，该能力称为泛化能力。
好吧，这还是搞数据挖掘的人写的东西。用我们这个方向上更易理解的话说就是：样本内的数据的某些特征规律，在样本外的数据中也存在，这种特征可以提取出具有盈利能力的交易策略。因此，这种存在性越强、或者说样本外盈利能力越强，泛化能力就越强。
在我个人的交易哲学中，已知数据全部都是样本内数据，人为划分样本内外的做法是学术术语，有可能会产生自欺欺人的后果。个人看法，仅供参考，而且为了交流方便我仍然会在下面使用这种学术说法。为了将这种泛化能力的欺骗性尽量降低，我的做法是在某一段样本期内划分样本内外，然后将这段样本期作为样本内，在另一段时期做样本外检验，依此迭代，能做几层做几层。抱歉我暂时没法把这个流程说清楚，有灵感了我来改答案。但是确实很有效，一般做两层，大部分好策略就不好了，根本不用实盘浪费时间浪费钱。
泛化能力是量化交易盈利的灵魂，涉及到哲学和技术两个层面。有空我会增加这部分的内容。
6. 真实交易环境限制。@Awing Xu 写的很好，请移步参考。
闪烁信号的问题主要出现在中长期交易中，大部分是使用日度数据进行回测造成的。解决方案包括设定一个与交易点差距的阈值，使得交易行为的到达条件不那么敏感；或者固定在一天的某个时间点监测并进行交易，忽略其他时段的价格变动，等等。
实际交易中不可能成交的价位。
使用市场单，价位变动，单个价位容量不能满足，市场剧烈波动影响成交价。
场内规制，庄家或报价商打止损。
这三个我统一归纳为交易中的摩擦，不知道有没有理解错，如有，致歉。第一个我展开说一下，由于下单环境的不同，单子到达交易所的时间也就不同，较大的时间差往往造成策略计算时的价位不可能成交的情况，波动大时尤甚。另一种情况则是流动性较低时，买卖单无法被对手及时匹配所导致的价位变动。这一问题可以通过提高议价能力、优化下单和计算环境等来缓解。第二个和第三个问题，主动的解决方案包括狭义的Algo Trading所代表的分单建仓等技术，以及对交易规则的合理应用等。这是另一个大的研究方向，不作展开。
与闪烁信号主要出现在长期策略不同，摩擦在高频交易中极为明显。高频中稀薄的盈利往往会被大量摩擦蚕食，进而导致理想环境下的盈利策略失去盈利能力。实践中，一个优秀的策略测试流程一定会考虑到摩擦因素，而针对套利类交易来说，对于摩擦损失的估计和预判甚至是整个策略的核心所在。
真实交易环境的限制涵盖很广。断电、断网、计算机故障等因素也是其中之一。肯定还有其他的问题限制，欢迎补充。集思广益，不甚感激。
7. 策略周期。策略是有周期的，站在风口上，猪都会飞。在趋势行情下，盘整策略会亏，在盘整行情下，趋势策略会亏。那我用技术手段，区分趋势行情和盘整行情呢？这是对未来行情的预测，提前固化的预测手段是具有时效性的，依然是一个大的周期问题。存不存在不会过期的盈利性策略呢，我认为有，具体的内容我会在后面混沌等内容中展开来讲，因为太哲学。目前而言，我寄希望于找到一个有效周期足够长的策略，我还没有找到，但会继续努力。
实际上，策略周期是“泛化能力”在时间上的着重体现，基于这个思路，我对这个性质的检测方式仍然是两层的样本内外检验，只不过会对样本期的长短、时段变化更为关注，研究这些变化带来的结果的变化。到了这里，我已经开始感到自身的软弱无力，交易是一个看天吃饭的活计，量化交易也不例外。
实盘不理想有以下几点
策略中使用了未来函数，实际交易中不可能成交的价位。
闪烁信号，回测没有闪烁的问题，实际交易中信号出现然后消失了，但仓位已建。
使用市场单，价位变动，单个价位容量不能满足，市场剧烈波动影响成交价。
手续费和价差没有包括在回测中，高频率交易尤其敏感。
使用某一时间段市场波动，不适合现市场波动，回测要检验多种市场状况。
还有因素如场内规制，庄家或报价商打止损。
长期策略问题较少，高频问题较多。
交易系统的历史回测应该注意什么
交易系统必须能通过历史回测才可以投入使用。无法通过历史回测的交易系统不可能在实际交易中获利。历史回测是交易系统投入实盘的必要前置环节。能通过历史回测的交易系统不一定是好用的交易系统，但不能通过历史回测，则一定不是好用的交易系统。
一般地，回测交易系统，需要从稳健性（Robustness）分析的角度特别留意以下四点。
第一，历史回测的期间必须足够长。
一般来讲，对于国内的股票、商品，应该回测5年以上的数据，对于新上市的品种，至少也要回测3年。对于上市较早的品种或国际市场的黄金、美元指数等商品，则应至少回测一个牛熊周期，一般应该在10年–15年以上。回测的期间足够长久，回测的成绩才足够可靠。对于不能满足这个要求的品种，则应在开仓时将R值适当加权处理，主动降低风险暴露。
第二，分析回测成绩，应予以“断代”处理。
一个稳定、可靠的交易系统，在一定期间范围内，成绩应该相对稳定。仅靠一两波大行情拉高整体回测成绩的，会使使用者高估系统的价值。例如，回测上证指数时，如果仅仅将2005年–2007年的大牛市纳入总成绩，而没有逐年的回测数据，很可能会因为一次牛市而高估了一个本来绩效一般的系统。我的经验是，按年予以断代，分析各年的回测绩效。完全平均的回测成绩是不可能的，一个优秀的系统应该满足两个条件：单一年度不出现巨大亏损；各年整体稳定盈利，偶尔出现超额获利。
第三，回测系统后应该防止“过度优化”，尽量减少参数变量，防止“参数孤岛”。
过度优化（Curve Fitting，也可称为“曲线拟合”）是交易系统回测的最大敌人。一个交易系统应以简洁为上，少用参数变量。对于采取了变量参数的系统，最优参数附近的参数也应具备不错的绩效，形成“参数高原”。应防止过度优化后的“参数孤岛”。
第四，交易系统应经历多品种回测检验
一个可靠的交易系统应该具备普适性，不能仅仅适用于个别交易品种。只能用于一个品种的交易系统，往往是过度优化的产物。需要特别说明的是，不同品种间可以结合品种特性进行一些针对单一品种的微调。比如结合不同品种的ATR情况，根据日K线的振幅过滤一些非常态下的开仓信号等。这种根据具体品种采取的个性化调整不属于过度优化。




# 量化交易十大陷阱
## 一、偷价
如果一个交易策略要求你利用信号触发前的价格进行交易，那么这个交易策略就存在偷价的问题。偷价发出的交易信号不会消失，但是你已经没有机会利 用这个信号进行交易了。例如，信号可能提示，如果当天收盘价高于前一天最高价，则利用当天开盘价进行买入，而在开盘价成交已经几乎是不可能的事情了。
很多人也许会低估偷价的危害性，事实上，固定点数的偷价相当于在原本的资金曲线上叠加了一条斜率为正的直线（在每次交易都是固定手数的情况 下）。例如，假设在股指上每次交易偷价1个点，那么一个上市至今交易2000笔的模型，会稳定净赚1*300*2000*2=120万。
下面两个图表是笔者在股指连续合约5分钟图上测试的双均线模型的交易盈亏曲线（回测时段2014年1月1日-2014年6月16日）。图1是包 含偷价的策略，即如果上一根k线上出现均线金叉，则以当前k线最低价买入，死叉则以当前k线最高价卖出。图2是没有偷价的策略，即如果上一根k线上出现均 线金叉，则以当前k线开盘价买入，死叉则以当前k线开盘价卖出。可以看出，两者资金曲线差异非常大。 

图1.策略偷价                          图2.策略没有偷价

## 二、 未来函数
交易策略中如果包含了未来函数，运行后表现是，某天出现的交易信号会在一段时间后消失，之后可能会在其他位置出现相同或不同的信号。出现这种情 况的原因是，函数在判断是否发出信号以及发出何种信号时，利用了未来还不确定的行情信息。例如，如果当前柱线上还在跳动的收盘价被用来判断是否触发信号， 则该函数是未来函数。使用这类函数的模型，会测表现胜率可能非常高，是典型的马后炮。
很多平台上都有的Zigzag指标实际上就是一个未来函数。
下面两个图表是笔者在黄金连 续合约5分钟图上测试的双均线模型的交易盈亏曲线（回测时段2014年1月1日-2014年6月16日）。图3是包含未来函数的策略，即如果当前k线上出 现均线金叉，则以当前k线开盘价买入，死叉则卖出。图4是不包含未来函数的策略，即如果上一根k线上出现均线金叉，则以当前k线开盘价买入，死叉则卖出。 可以看出，两者资金曲线差异非常大。 

图3.策略包含未来函数                图4.策略不包含未来函数

## 三、 手续费
策略进行测试时，如果不计入手续费，资金曲线可能会产生巨大差异，甚至不计手续费的盈利策略，在计入手续费后也可能产生亏损。手续费相当于在原本的资金曲线上叠加了一条斜率为负的直线（在每次交易都是固定手数的情况下）。

## 四、 滑点
滑点指的是开仓点位和成交点位之间的差异。滑点可能由网络延迟、交易平台不稳定、行情波动剧烈、市场容量不够等情况导致的，是难免会发生的情 况，因此滑点是一个合格的交易策略必须充分考虑的因素。所以，如果在一个交易策略中，将滑点数设置为0，其资金曲线就会优于同一个滑点数不为0的策略。
滑点和手续费对一个策略的资金曲线造成的影响是类似的。
下面两个图表是笔者在沪铜连续合约5分钟图上测试的双均线模型的交易盈亏曲线（回测时段2014年1月1日-2014年6月16日）。图5是手续费和滑点均为0的策略。图6是设置了2.5%%手续费和2跳滑点的策略。可见，一个盈利的无成本交易策略，在合理设置成本后却可能出现亏损。 

图5. 手续费和滑点均为0              图6. 手续费2.5%%，滑点2跳

## 五、 指数合约
有些策略回测的合约是指数合约，而指数合约是使用该品种所有合约加权平均生成的，其价格与主力连续合约有所差异，这种价格上的差异会使回测的资 金曲线不真实。例如，某个合约上的短期剧烈波动被指数合约平滑了；或者，当远月合约升水，同时与近月合约基差较大，且处于移仓换月时，由于远月权重的逐步 加大，可能会在指数合约上形成一轮涨势，而实际并不存在；再或者，实际操作中的移仓可能会产生一定的基差成本，这在指数合约却上无需支付。
下面两个图表是笔者在沪铜指数合约和沪铜连续合约5分钟图上测试的海龟交易系统的交易盈亏曲线图（回测时段2014年1月1日-2014年6月17日，参数已优化）。图7是沪铜指数合约的交易盈亏曲线。图8是沪铜连续合约的交易盈亏曲线。可以看出，图7的曲线显然更加平滑，且最终表现更优异。

图7.沪铜指数合约                       图8.沪铜连续合约

## 六、 过度优化
有些策略在公布资金曲线前可能进行了过度优化。过度优化有多种操作方法，例如，策略交易者可以针对某段特定的行情，或短时间的行情进行参数优 化，之后将分段行情对应的资金曲线拼接起来，得到一个表现更出色的资金曲线；或者，策略交易者指定过去某几个表现较差的交易日不进行交易；再或者，策略交 易者对过去的行情进行过度拟合，却并不考虑这个拟合方程不适用于未来；等等。上述种种经过加工的回测时的优异表现，都会与策略未来的运行结果存在较大差 异。
曲线拟合可以帮助我们解释过去的走势，从而推导未来的走势。然而，如果策略交易者对行情进行了过度拟合，则策略对过去行情的解释可能会非常出 色，但对于未来行情的解释却几乎肯定是非常糟糕的。下面两个图表可以阐释适当的曲线拟合和过度的曲线拟合。图9的红色曲线拟合是适当的，我们可以看到十个 离散点基本均匀的分布在曲线附近。图10的红色曲线拟合很显然是过度的，每个点都位于红色曲线上，但我们很难想象这跟曲线能够表达出下一个即将出现的点。 

图9.适当拟合                       图10.过度拟合

## 七、 市场容量
对于承载较大资金规模的策略而言，如果没有充分考虑市场容量的问题，可能会导致交易结果与预期偏差较大。例如，涨跌停和流动性中断时，大资金常 常很难成交，这在策略回测时很难纳入考量；或者，实际品种的市场容量有限，较大的单量不能全部以指定价格成交，这也会影响最终的交易结果。
下图是沥青主力合约1409在6月17日的盘口图，可以看到沥青市场容量很小，有时几分钟都没有一笔成交，所以应用在沥青上的交易策略很难按照指定价格成交。 

图11.沥青1409盘口

## 八、 样本量过少
有些策略覆盖的时间段太短，所以样本量太少，不能充分展现策略效果。这些策略在更长时间段上的资金曲线可能表现的并没有那么好。
九、 信号量过少
有些策略虽然测试了较长的时间段，但触发的交易信号很少。这些策略未来是否表现稳定也有待观察。例如，应用在日线图上的策略需要考察更长的时期。

## 十、 适用范围小
有些策略虽然覆盖了较长的时间段，或较多的品种或市场，但仅仅覆盖了一种类型的行情（例如一轮较长时间的大牛市）。这些策略在遇到截然不同的市场情况时，表现可能会大相径庭。
例如《股市实战-精准买卖点秘技大全》这本书成书于2007年底，出版于2008年5月1日。书中的股票策略（股票只有做多策略）回测胜率超过 了90%。但实际上，在这样的大牛市中，任何做多的策略都能赚钱。但该书出版后牛市就已经结束，书中的几十套策略自然无法应对08年之后的漫漫熊市与震荡。


# 场外个股期权

随着商品期权的落地，这个在国外有巨大交易量的金融衍生产品逐步得到国内投资者重视，而具有广大群众基础的股票期权却一直为少数机构把持。个股场外期权是怎样的衍生品？它是如何交易的？有什么优劣势？适合哪类别投资者哪？作为股票期权的实操者，且听我娓娓道来。
一、何为期权
又称为选择权，是指买方向卖方支付期权费(指权利金)后拥有的在未来一段时间内(指美式期权)或未来某一特定日期(指欧式期权)以事先规定好的价格(指履约价格)向卖方购买或出售一定数量的特定商品的权利，但不负有必须买进或卖出的义务(即期权买方拥有选择是否行使买入或卖出的权利，而期权卖方都必须无条件服从买方的选择并履行成交时的允诺)。
按照权利分为：看涨期权、看跌期权，简单来说就是分别用于了在一定期限内，按照某个价格来买入、卖出特定商品的权利。
按照交割时间：美式期权、欧式期权，美式期权是在合约期限内任何一个交易日都可以行权，欧式期权是只有到期日才可以行权。
二、股票期权
股票期权是一种在沪深交易所之外交易的个股期权，期权的买方(权利方)通过向卖方(义务方)支付一定的费用(权利金)，获得一种权利，即有权在约定的时间以约定的价格向期权卖方买入或卖出约定数量的特定股票。
目前国内场外股票期权的买方一般为机构投资者和个人投资者，卖方为合格的证券公司，比如：中金证券、申万宏源等资金实力雄厚的大型券商。卖方在收取了期权费用后，必须确保股票期权的有效履约，承担期权期限内股票上涨的无限亏损。股票期权的结算方式可以是股票实物交割或现金差价交割。
三、期权合约的构成要素
标的资产：沪深两市的个股股票或股票指数
行权价格：买方有权在合约期限内按照事先约定的价格买入特定股票
期权期限：一般有效期分为1个月、3个月、6个月等，过期作废
期权类型：目前仅支持看涨期权（买方支付一定权利金，有权按照一定价格事先买入一定数量股票，在合约期限内有权卖出）
到期日：期权合约约定的最后有效日期
行权方式：股票实物交割或现金差价交割
四、场外期权—看涨期权案例
五、与配资相比较
1、杠杆比例
股票期权：具有天然的高杠杆特点，不同的期权费就意味着不同的杠杆倍数。比如5%的期权费就代表杠杆为20倍，10%期权费就代表杠杆为10倍。股票期权一般期权费用在5%-10%之间，也就是杠杆为10-20倍，且没有任何配资利息成本。
股票配资：市面上大部分配资比例为1-5倍之间，配资年息在12%以上。
结论：股票期权杠杆比例一般远大于股票配资
2、风险抵抗能力
股票配资中的强平条款让很多投资人倒在了黎明来临前，国内的中小盘股在拉升之前基本都会出现大幅震荡洗盘，股票配资客户经常受资金变动影响而出局，或者陷入不断追加资金应对越来越大亏损，最终演变为赌博式风险交易中。
股票期权对大幅震荡行情中的下跌亏损无关，不需要承担价格变动中的亏损，静观行情风云变化，锁定该笔交易最大费用，良好心态持仓。
结论：股票期权风险锁定，不受行情变动影响
3、收益能力
股票配资：股票价格大于买入价即获得收益，价格出现回撤会在投资者本金内进行抵补。
股票期货：股票价格减去买入价的收益大于期权费用后才可以实现盈利。
结论：因杠杆大小不同，在上涨初期股票配资收益大，随涨幅扩大，股票期权收益率会远大于配资收益。
六、个股场外期权优势点
1、收益无限
交纳一定比例的期权费（权利金）就可以拥有其10-20倍市值股票在一定期限内的处置收益权。牛股热点到来，不再错失任何机会，加大资金放大收益。
2、亏损有限
对投资者来说最大的风险莫过于扛单，其结果无非两种：一个是扭亏为盈，一个是陷入破产式亏损状态。期权实现了最大回撤的锁定，扛单亏损与投资者无关，最大损失即期权费用，无压力扛单助力行情反弹。
3、买卖灵活
那只熟悉的股票，山雨欲来的大行情前随时入场买进，当盈利达到目标位，在合约期内根据实时价格随时卖掉，可选择空间大。
4、交易策略
投资者可以通过对不同个股进行组合购买，不同比例搭配，以达到分散风险平衡收益的目的。
5、标的范围广
除去ST外的沪深3000多只个股、股票指数，在交易日内且个股开盘的情况下报价购买。
七、哪些投资者适合做个股场外期权
1、低位补仓
投资是某几只股票的坚定持有者，已经投入大量资金，当股价出现下跌至关键支撑位，行情反弹概率极大。投资者希望抓住这波反弹增加收益以摊平资金使用成本，但又担心出现市场风险回落或者资金不充裕，这种情况下利用期权的风险有限及杠杆属性购入看涨期权。
2、抓消息面
对上市公司近期可能出现并购、增资、股份转让、财报等含有重大利好消息公告前有获取渠道，对国家产业政策、规划、扶持文件的出台有获取渠道，对热点板块轮动有一定预测能力的，对大资金的公募、私募机构对个股资金布局提前知悉。利用期权无息高杠杆属性，实现小资金大收益。
3、对冲策略
期权具有风险收益非线性的特性，在合约期限内收益可以无限而风险已经提前锁定。对于有融券业务的客户，当股票价格具有不确定反弹空间且不愿意放弃看空条件下，可以买入该个股的看涨期权，付出一定权利金来对冲风险。
4、抓黑马股
有一套专属的操盘系统和交易规则，对个股爆发前资金流动、成交量、技术形态有精准把握，预判涨停先机。
5、行情研判
对股票进行长期跟踪分析，通过基本面、技术面全方位研判，股票将于近期出现大幅反弹，因为资金成本原因不愿用大量资金购入等待，在何时时间和价位购入合理期限的看涨期权。
八、参与流程
1、询价
提交具体要购买期权的个股，等待券商给出期权费报价，询价内容包括但不限于：交易时间、交易标的、交易方向、交易价格及交易量等要素。
2、入金
询价成功后券商会对具体股票、期限报出期权费，客户准备购买的，将对应期权费转入账户。
3、买入交易
客户可以通过市价、限价方式来发出交易指令，我司接收到客户下达的交易指令后立即向券商提交买入指令，券商1天内根据交易成交状况回复是否达成买入交易，如果交易未完成，期权费退回至账户中。
4、卖出行权
客户根据自己判断可申请提前行权，客户发出交易指令后我司随即向券商提交行权指令，卖出结束后券商会通知是否达成行权。
5、结算
根据买入和卖出平仓的信息，券商将对买入期权合约进行结算，盈利部分T+1日后到账。

# 算法

## 模拟算法


    蒙特卡罗算法：采样越多，越近似最优解；
    拉斯维加斯算法：采样越多，越有机会找到最优解；

举个例子，假如筐里有100个苹果，让我每次闭眼拿1个，挑出最大的。于是我随机拿1个，再随机拿1个跟它比，留下大的，再随机拿1个……我每拿一次，留下的苹果都至少不比上次的小。拿的次数越多，挑出的苹果就越大，但我除非拿100次，否则无法肯定挑出了最大的。这个挑苹果的算法，就属于蒙特卡罗算法——尽量找好的，但不保证是最好的。

而拉斯维加斯算法，则是另一种情况。假如有一把锁，给我100把钥匙，只有1把是对的。于是我每次随机拿1把钥匙去试，打不开就再换1把。我试的次数越多，打开（最优解）的机会就越大，但在打开之前，那些错的钥匙都是没有用的。这个试钥匙的算法，就是拉斯维加斯的——尽量找最好的，但不保证能找到。

这两类随机算法之间的选择，往往受到问题的局限。如果问题要求在有限采样内，必须给出一个解，但不要求是最优解，那就要用蒙特卡罗算法。反之，如果问题要求必须给出最优解，但对采样没有限制，那就要用拉斯维加斯算法。对于机器围棋程序而言，因为每一步棋的运算时间、堆栈空间都是有限的，而且不要求最优解，所以ZEN涉及的随机算法，肯定是蒙特卡罗式的。

# 凯利公式

凯利公式如下
F = (Pw*Rw-Pl*Rl)/(Rw*Rl) = 预期收益率/(Rw*Rl) = Pw/Rl-Pl/Rw 简化为F=Pw/Rl-Pl/Rw

其中，Pw为赢的概率，Pl为输的概率，Rw是赢时的净收益率，Rl是输时的净损失率。
F是现有资金下次下注的比例，可以理解为股票的仓位。

反等价鞅”策略下，怎样下注才能实现保证长期稳定盈利？
答：K = W - (1-W)/R   K：每次下注所占总资金的比例，W：你的策略的胜率，R下注的赔率

拿投硬币游戏举例，W=0.5，R=2，那么 K = 0.5-(1-0.5)/2 = 0.25。也就是说，投硬币游戏中，只要你每次投入你的总资金的1/4，永远遵守这个几率的玩下去，那么，你将以最快的速度成为亿万富翁。

K = (W*R-1)/(R-1)，K,W, R的定义同上。
于是，我们发现，盈利有一个基本的前提，那就是你的胜率W乘以你的赔率R，结果必须大于1，否则无论如何都不可能盈利。

那现在我们用凯利基础公式来考虑我们每次投资的比例。
假设我每一单的胜率是W=0.5，每一单的止赢和止损的比例是2:1，也就是说，赔率R=3。
这样，根据剀利基础方程，K=(0.5*3-1)/(3-1) = 25%，也就是说，每一单的仓位设置为25%。如果胜率是0.4,那么K=10%；如果止赢和止损比是3:1，那么赔率R=4, 胜率W=0.4，那么，K = (0.4*4-1)/(4-1) = 20%。

看到这里，我想你应该明白了为什么分析师总告诉我们：“每次轻仓10%-20%，止赢和止损的比例设置成2:1和3:1。”这样即使你的胜率是40%甚至30%，你都可以稳定盈利！

也就是说，只要你严格执行这个公式，即使你的胜率只有10%，也是可以盈利的！这也就是为什么说技术只占20%，而资金管理占80%。你的技术，只是一个数字W而已。

在赌桌上，所有事件出现的概率是相同的，但行情却不是

许多资本管理公司死在这一误区上。假设你遇到一次“黑天鹅”大赚，但之后很久都没遇到大行情，你所设置的赔率迟迟触发不了；或是在一次大赔之后，多少单的小赚都弥补不会来。

面对这种情况，专业投资人士会调整或加入部分参数。而对于普通投资者，更简单的做法是：控制预期范围，将黑天鹅事件排除在参考范围之内。还有就是，取出每次的盈利。

W（胜率）R（赔率）不明确

这其实是第一个问题的衍生，对于胜率，只能通过长期经验积累所得。对于赔率，通过公式可得，当W约小，就要求R越大，但行情波动范围可能不支持很的R值，所以，这就要求投资者在充分认识行情的前提下，见好就收，不要执着于预设的收益率，一面转盈为亏。

德州扑克是最与投资相近的扑克游戏


大家在网上常见的凯利公式 F=(bp-q)/b，其中F为下次投注的比例，b为赔率，p为获胜的概率，q为落败的概率即1-p。需要注意的是这里的赔率b是除去本金后的赔率，跟竞彩中的赔率不一样；而且这里的获胜概率p是指你自己判断出的球队获胜概率，并不是指博彩公司或竞彩中心计算出的概率p‘，两者是不一样的。

为简化和容易理解起见，上述公式中赔率用实际赔率代替，于是b就成了b-1。为尽可能减少因子，q也用1-p代替。那么凯利公式就变成了：

F=((b-1)*p-(1-p))/(b-1)=(bp-1)/(b-1)，

可以看出你盈利的首要前提是公式中的分子bp-1>0也就是p>1/b。否则bp-1<0了，就是搬出凯利公式他爹你都赢不了。以今天凌晨竞彩中实际的赔率为例，欧联杯佛罗伦萨vs门兴，不让球的赔率为胜 2.25、平3.21和负2.68：

在这组赔率下，我们先可以根据下面的公式算出竞彩中心认为的门兴获胜的概率为33.05%。

而根据凯利公式，只有确认你自己判断综合各方面情报得出门兴获胜的概率超过1/2.68=37.31%时才会有理论上的盈利，很明显这个概率必须而且肯定的要比体彩中心算的概率高的，因为竞彩中心有抽水。如果你判断门兴获胜概率仅为30%，那么此时的门兴就没有理论上的投注价值了。

标准凯利公式的应用：

继续用上面的赔率举例，如果你认为门兴胜出的概率为50%，那么这场比赛投注的比例将是F=(2.68*0.5-1)/(2.68-1)=10%。也就是说如果你有1000块本金，凯利公式建议你用1000×10%=100块来投注门兴。

但是在实际应用中，根据我们的经验，彩民们经常会高估自己对比赛的判断能力，比如经常会出现觉得100%能胜出的的比赛。如果出现100%，那么根据凯利公式，需要投注的比例是多少呢？仍旧以门兴为例，F=(2.68*1-1)/(2.68-1)=100%，也就是清仓投注。这就有问题了，仓只能清一次，不存在多次清仓，万一输了呢？出问题的根源在于你判断失误，把本不可能100%胜出的比赛估计成了100%。

部分凯利公式的应用：

根据常年的应用，为了弥补常规凯利公式在竞彩实际投注应用中的不足，凯利公式变化出了50%凯利公式、1/4凯利公式以及等等。比如上例中，如果用1/4凯利公式，实际的投注比例就成了100%×1/4=25%，即使判断失误，还剩3/4本金，很容易回本。这就能很好的避免彩民们过高估计自己胜率的问题。

调整凯利公式的应用：

有些彩民喜欢同一时段同时投注多场比赛，那如何应用凯利公式呢？比如想同时投注A、B、C、D 4场比赛，用标准凯利公式计算出投注比例：

投注A 25%
投注B 35%
投注C 35%
投注D 40%

很明显，这比例超出100%了，此时就需要应用调整凯利公式了。把ABCD所有投注比例相加，也就是135%，然后把原先的各投注比例除以135%，比如投注A 25%/135%约为18%。B、C、D也同样，这就是调整凯利公式。

在竞彩实战中，我推荐大家使用10%凯利公式。青山常在，绿水长流。


f=\frac{ b\times p-q}{b}



式中：

f为你该用资产多少比例下注；
b为盈亏比；
p为胜率；

q为亏损概率，即q=1-p。

盈亏比=(成功率×平均获利幅度)/(败率×平均亏损幅度)，这其实是概率中“数学期望”

凯利公式是我们用来衡量进入投资组合的仓位的有效工具。这个公式着眼于关注长期回报率和风险控制。
然而，就像上面提到的，严格来讲，凯利公式上还是有很多缺点：
凯利公式适用于有顺序但无关联性的赌注。在有内在赌注的投资组合中(且内在赌注被宏观因素、市场和彼此影响)，专业操作资金池也会样做。他们之间存在些内在关联性。
赌博游戏的输赢可以统计。而投资的行为和最终价值具有特殊性。
决定赌博中的 “edge”是定量和精确的。决定赌博中的 “edge” 经常是定量且基于个人观点，因此很难去精确定义。
在寻求长期绝对回报时，专业经营投资池很少可以在不在意短期波动的情况下去押高度集中的赌注。真实世界里是存在竞争目标的。



f* = (bp - q) / b

其中，f* = 投注金额占总资金的比例
p = 获胜的概率
q = 失败的概率，q = 1-p
b = 赔率，例如在轮盘赌中押单个数字，b = 35，押红黑，b = 1。


上篇中讲到的21点下注问题，假设总赌本10,000美元，玩家取胜的概率是51%，赔率1：1（实际胜率和赔率略有偏差，但相距不大），那么凯利公式给出的最佳赌注是：

$10000 * (1 * 0.51 - 0.49)/ 1 = $200


首先，公式中分子的bp - q 代表“赢面”，数学中叫“期望值”(expectation)，凯利公式指出：正期望值的游戏才可以下注，这是一切赌戏和投资最基本的道理，也就是前面讲的“没有把握，决不下注”。
其次，赢面还要除以“b”才是投注资金比例。 也就是说赢面相同的情况下，赔率越小越可以多押注。 这一点不容易直观理解，我们用个例子来说明。 下面三个正期望值的游戏，你看看选哪个：
1.      “小博大”：胜率20%，赢了1赔5，输了全光。bp - q = 5*20% - 80% = 20%
2.      “中博中”：胜率60%，1赔1。bp - q = 1*60% - 40% = 20%
3.      “大博小”：胜率80%，1赔0.5。bp - q = 0.5*80% - 20% = 20%
三个游戏的数学期望值一样，都是20%，或者说押100元平均赢20元。 按大部分国人的赌性，恐怕会选“小博大”游戏吧？ 但是用凯利公式中的“b”一除，“小博大”游戏只能押总资金的4%，“中博中”可以押20%，“大博小”可以押40%。 赢钱速度“大博小”快多了！  前面不是讲过“久赌必赢的游戏应该选波动性小的”吗？ 说的就是这个了。
现实中，爱玩“小博大”的多半是赌客。 谁爱玩“大博小”呢？ 赌场！ 华尔街的职业投资家们很多玩的也是“大博小”，因为便于使用杠杆（押大赌注）。 关于这点后面还要详细讲。
最后，凯利公式指明了风险控制的至关重要性：即便是正期望值的游戏也不能押太大的赌注。 从数学上讲，押注资金比例超过了凯利值，长期的赢钱速度反而下降，还会大大增加出现灾难性损失的可能性。 举个极端的例子，如果你每手都押上全部资金，那么不管你赢过多少钱，只要输一次就立刻破产。正所谓：辛辛苦苦几十年，一夜回到解放前。
为什么投资界赔到倾家荡产的尽是一些局部技术不错的老手呢？ 原因多半在“赌注太大”。 上世纪初有位大宗师级别的投机客一世英名就毁在了这上面。


上次谈到，评估投资机会的优劣应该从收益期望和风险两方面综合考虑。如何量化这一思想呢？ 1950年代，有人提出用回报期望和波动性的比例作为衡量投资机会的指标。1966年，学者夏普（William Sharpe）在此基础上提出了著名的夏普比率（Sharpe Ratio）：

 
S = (R – r) / σ，  其中：

R = 投资的回报期望值（平均回报率）

r = 无风险投资的回报率（可理解为投资国债的回报率）

σ = 回报率的标准方差（衡量波动性的最常用统计指标）

 

夏普比率S越高，投资机会的“质量”越高。 举个例子：

    甲投资：超额（超出国债）回报期望10%，标准差20%，夏普比率为0.5
    乙投资：超额回报期望5%，标准差5%，夏普比率为1

 

乍一看，甲投资回报期望高，似乎是比较好的机会。其实乙投资更胜一筹（通常情况下），因为它的夏普比率高，意味着投资者用1个单位的“风险”能换取更多的回报期望。 从杠杆投资的角度也可以得出同样的结论：假设投资者以r贷款利率融资，在乙投资机会上加1倍杠杆，那么“杠杆化”的乙投资就变成了10%回报期望，10%标准差，与甲投资的回报期望相同，而风险较小。


活着最重要
没有把握，绝不出手
久赌必输, 很多玩家迷信“运气”，而经营赌场的人相信概率，这就是输家和赢家的差别。
卖铲子比挖金子容易赚钱
通过计牌估算概率，当形势有利时下大赌注
诸如赚钱时才可加码，亏钱时应当止损，不要轻信他人观点或所谓“内幕消息”
赢面大、波动性小的游戏可以押较大赌注
要在回报和风险之间寻找平衡。


	年复合回报率	回报率波动性	夏普比率	 最大跌幅（发生时间）
Bluecrest	14.15%	5.94%	1.9	-4.83%  （2003）
FORE(前沿资本)	15.17%	12.30%	1	-27.01%（2008）
Millennium(千禧年)	15.20%	4.53%	2.7	-7.24%  （1998）
Paulson Credit Opportunities	79.17%	49.83%	1.5	-10.41%（2007）
Drake	2.78%	12.21%	<0	-51.74%（2007-2009）



夏普比率多高才算“好”呢？ 我们来看一个实际的例子：美国股市的长期年平均回报率约为10%，波动性约为16%，无风险利率约为3.5%，因此夏普比率约为0.4（来源：维基百科）。 翻译成白话就是：投资美股指数的年均回报率约比无风险利率高6.5%，但平均6年中有1年的回报率低于 -6%（1倍标差之外）。对于长线投资的散户而言，投资美股的风险/回报还算说的过去。 如果是对冲基金经理，这样的夏普比率就太低了：假设你的目标是20%年回报率，就必需用2.5倍杠杆（回报期望 = 2.5*10% - 1.5*3.5% ≈ 20%），也就意味着平均6年中有1年的回报率将低于2.5*（10% - 16%）- 1.5*3.5% = -20%。你赔了超过20%，客户大概就要跑光了。


一般说来，夏普比率超过1才是“好游戏”。这种机会在“简单投资”中并不多见，因此职业投资者常常利用对冲手段“改造”投资游戏，提高夏普比率。 《乱世华尔街》中多次提到，对冲与杠杆是一对孪生姐妹，两者往往配合使用，说得就是这个原理。例如，你发明了一种方法，用各种资产相互对冲得到夏普比率为2的投资机会，那你就可以大胆加杠杆（数学好的同学们可以自己计算赔钱的概率），投资者大概要追着给你的对冲基金投钱了。 但对冲+杠杆的投资方法通常有个“练门”：需要借很多钱，对流动性要求高，因此遇到突发性危机往往会出问题，《乱世华尔街》中就分析过LTCM和高盛Global Alpha基金的例子。

 

夏普比率也存在缺陷，它假设回报是正态分布，而实际的投资回报分布有“肥尾”（赔大钱的概率高于正态分布的估计），因此单纯根据夏普比率挑选投资机会存在问题，也容易被“操纵”。 这个话题此处暂不展开讨论。

 

对普通投资者而言，夏普比率提示要从风险和回报的角度综合考虑，挑选“性价比”高的投资。这正是前面的文章中提到的观点：正回报的游戏要挑波动性小的，负回报的游戏如果非得玩，就挑波动性大的。总之，夏普比率越高越好。


夏普比率讲的是如何挑选“游戏”，而凯利公式讲的是选好了游戏后如何下注才能取得最优的长期回报率。 现在我们就把两种方法配合起来使用，看看21点计牌到底是不是条发财的路。



# 蒙特卡洛模拟方法 Monte Carlo

蒙特卡洛方法（Monte Carlo method）是指的通过大量产生随机数的模拟方法来用于数值统计计算以获得问题的近似解。蒙特卡洛方法最简单的计算就是用于pi的计算。

Pi的计算

采用蒙特卡洛方法计算Pi就是使用随机产生点（x，y），x和y均为0~1之间的数值，然后判断该点和原点之间的距离，如果少于等于1则表示其位于圆圈内，由圆的面积公式即可得pi的值就近似等于圆圈内的概率与4的积。
Python代码如下：

import math
import random

def calc_pi(times):
    """
    采用蒙特卡罗算法计算pi
    """
    random.seed()

    in_circle = 0
    for _ in range(times):
        x,y = random.random(), random.random()
        if x**2 + y**2 <= 1:
            in_circle += 1

    return 4*in_circle/times


def main():
    for i in range(2, 10):
        times = 10**i
        pi = calc_pi(times)
        sq = abs(pi - math.pi)/math.pi*100
        print("蒙特卡罗模拟次数：{}, 结果：{}, 误差：{}%".format(times, pi, sq))


if __name__ == '__main__':
    main()


其结果如下：

蒙特卡罗模拟次数：100, 结果：3.2, 误差：1.8591635788130243%
蒙特卡罗模拟次数：1000, 结果：3.224, 误差：2.6231073056541225%
蒙特卡罗模拟次数：10000, 结果：3.1512, 误差：0.3058113342361133%
蒙特卡罗模拟次数：100000, 结果：3.13928, 误差：0.073614050094963%
蒙特卡罗模拟次数：1000000, 结果：3.143012, 误差：0.045179199428836934%
蒙特卡罗模拟次数：10000000, 结果：3.1419012, 误差：0.00982133727153544%
蒙特卡罗模拟次数：100000000, 结果：3.1416454, 误差：0.0016789703829496415%
蒙特卡罗模拟次数：1000000000, 结果：3.14167924, 误差：0.002756131037808187%


蒙特卡罗模拟次数：100, 结果：3.2, 误差：1.8591635788130243%
蒙特卡罗模拟次数：1000, 结果：3.068, 误差：2.3425269188130162%
蒙特卡罗模拟次数：10000, 结果：3.1484, 误差：0.21668456610466175%
蒙特卡罗模拟次数：100000, 结果：3.13716, 误差：0.14109574596591637%
蒙特卡罗模拟次数：1000000, 结果：3.14256, 误差：0.030791592573325813%
蒙特卡罗模拟次数：10000000, 结果：3.1418752, 误差：0.008993731567454989%
蒙特卡罗模拟次数：100000000, 结果：3.14165552, 误差：0.00200109998777478%
蒙特卡罗模拟次数：1000000000, 结果：3.14161502, 误差：0.0007119449487339978%



优点和缺点

从蒙特卡洛方法的计算方法和思路可以知道如下，其本质是通过大量的模拟随机数来完成对应的近似值估计，因此其主要优点和缺点如下：

-思想较简单，易于实现，可以有广泛的应用
-部分应用问题只能通过模拟来求解
-时间复杂度和空间复杂度较高
-近似解，对于模拟的随机值必须有初步的概率了解，否则其模型的选择对结果影响很大


函数极值

蒙特卡洛模拟求函数极值，可避免陷入局部极值

#在区间[-2,2]上随机生成一个数，求出其对应的y，找出里面最大的认为是函数在[-2,2]上的极大值


[转载]python做蒙特卡洛模拟的2个小例子

import numpy as np
import random
ymax = 0 
y = lambda x: 200*np.sin(x)*np.exp(-0.05*x) #匿名函数
num = int(raw_input(u'请输入模拟数'))
for i in range(1, num+1):
	x0 = random.uniform(-2,2)
	if y(x0) > ymax:
		ymax = y(x0)
		xmax = x0

模拟1000次后发现极大值为 185.12292832389875（非常准确）



不规则几何形状的面积

这里定义了一个x一个y。在这里其实是吧一个坐标（x，y）调用出来，在计算这个随机的点在这一块面积内所出现的概率，已经是的估计出这里的概率。相同的用这样的函数和算法可以计算很多很多不规则几何形状的面积。这里也可以看作积分的另一种实现

import random  
n=1000000  
k=0  
for i in range(n):  
    x=random.uniform(0,1)  
    y=random.uniform(0,1)  
    if y<x**2:  
        k=k+1  
print float(k)/float(n) 

三门问题

　三门问题很有意思，wiki用不同方法将原理讲的很透彻了，我跟喜欢其中这种理解方式：无论参赛者开始的选择如何，在被主持人问到是否更换时都选择更换。如果参赛者先选中山羊，换之后百分之百赢；如果参赛者先选中汽车，换之后百分之百输。而选中山羊的概率是2/3，选中汽车的概率是1/3。所以不管怎样都换，相对最初的赢得汽车仅为1/3的机率来说，转换选择可以增加赢的机会。

　　原理明白了，实现就比较简单了，这次用python啦。
	
import random as rnd
 
strategy = ['stick','choose','swith']
def MC(strategy,times):
    wins = 0
    for trail in range(times):
        # 假定，实际上奖品在0号门...但是我们并不知道...
        envelops = [0,1,2]
        # 第一次随机选取一扇门
        first_choice = rnd.choice(envelops)
        # 根据第一次的选择情况的不同，第二次宣策面临两种不同的备选组合
 
        # 如果第一次选择了0号门，那么在打开另外两个门中的一个空门后
        # 第二次将要在0号门和未打开的空门（1 or 2）中作出选择
        if first_choice == 0:
            envelops = [0,rnd.choice([1,2])]
        # 如果第一次没有选中0，那么此时被打开的必然是另一个空门，那么
        # 在第二次选择时，将在0和自己现在所处的门（first_choice）作出选择
        else:
            envelops = [0,first_choice]
 
        # 采取不同的策略进行第二次选择
 
        # 保持原来位置不变
        if strategy == 'stick':
            second_choice = first_choice
        # 在除去一个空门后的两个门中，随机选择一个
        elif strategy == 'choose':
            second_choice = rnd.choice(envelops)
        # 排除一扇空门后，放弃原来的选择，直接选择另一扇门
        elif strategy == 'switch':
            envelops.remove(first_choice)
            second_choice = envelops[0]
 
        # 记得，奖品在0号门
        if second_choice == 0:
            wins += 1
    # 计算获奖的概率值
    p = wins/times
    print('第二次选择采用'+strategy+'方法，获奖的概率为：'+str(p)+'(模拟次数为'+str(times)+')')
 
MC('stick',10000)
MC('choose',10000)
MC('switch',10000)



# 普通最小二乘法（OLS）
普通最小二乘法（Ordinary Least Square，简称OLS），是应用最多的参数估计方法，也是从最小二乘原理出发的其他估计方法的基础，是必须熟练掌握的一种方法。
在已经获得样本观测值（i=1,2,…,n）的情况下（见图2.2.1中的散点），假如模型（2.2.1）的参数估计量已经求得到，为和，并且是最合理的参数估计量，那么直线方程（见图2.2.1中的直线）
          i=1,2,…,n        (2.2.2)
应该能够最好地拟合样本数据。其中为被解释变量的估计值，它是由参数估计量和解释变量的观测值计算得到的。那么，被解释变量的估计值与观测值应该在总体上最为接近，判断的标准是二者之差的平方和最小。

 (2.2.3)
为什么用平方和？因为二者之差可正可负，简单求和可能将很大的误差抵消掉，只有平方和才能反映二者在总体上的接近程度。这就是最小二乘原则。那么，就可以从最小二乘原则和样本观测值出发，求得参数估计量。
由于

是、的二次函数并且非负，所以其极小值总是存在的。根据罗彼塔法则，当Q对、的一阶偏导数为0时，Q达到最小。即
           (2.2.4)
容易推得特征方程：

解得：                   
                （2.2.5）
所以有：    （2.2.6）
于是得到了符合最小二乘原则的参数估计量。
为减少计算工作量，许多教科书介绍了采用样本值的离差形式的参数估计量的计算公式。由于现在计量经济学计算机软件被普遍采用，计算工作量已经不是什么问题。但离差形式的计算公式在其他方面也有应用，故在此写出有关公式，不作详细说明。记



（2.2.6）的参数估计量可以写成
                 (2.2.7)
至此，完成了模型估计的第一项任务。下面进行模型估计的第二项任务，即求随机误差项方差的估计量。记为第i个样本观测点的残差，即被解释变量的估计值与观测值之差。则随机误差项方差的估计量为
               (2.2.8)
在关于的无偏性的证明中，将给出（2.2.8）的推导过程，有兴趣的读者可以参考有关资料。
在结束普通最小二乘估计的时候，需要交代一个重要的概念，即“估计量”和“估计值”的区别。由（2.2.6）给出的参数估计结果是由一个具体样本资料计算出来的，它是一个“估计值”，或者“点估计”，是参数估计量和的一个具体数值；但从另一个角度，仅仅把（2.2.6）看成和的一个表达式，那么，则是的函数，而是随机变量，所以和也是随机变量，在这个角度上，称之为“估计量”。在本章后续内容中，有时把和作为随机变量，有时又把和作为确定的数值，道理就在于此。

在回归过程中，回归的关联式不可能全部通过每个回归数据点（x1,y1. x2,y2...xm,ym），为了判断关联式的好坏，可借助相关系数“R”，统计量“F”，剩余标准偏差“S”进行判断；“R”越趋近于 1 越好；“F”的绝对值越大越好；“S”越趋近于 0 越好。

总体平方和 TSS= 残差平方ESS + 回归平方和RSS
t统计量是检验系数显著性的,一般要大于2；
Sig值是t统计量对应的概率值,所以t和Sig两者是等效的,看Sig就够了.Sig值要求小于给定的显著性水平,一般是0.05、0.01等,Sig越接近于0越好；
R方衡量方程拟合优度,R方越大越好,一般地,大于0.8说明方程对样本点的拟合效果很好,0.5～0.8之间也可以接受.时间序列的话,R方很容易达到很大,如果是截面数据,R方的要求没那么严格.但要注意的是R方统计量不是检验的统计量,只衡量显著性；
F是检验方程显著性的统计量,是平均的回归平方和与平均剩余平方和之比,越大越好!
分析这些检验结果最好参照数据本身的特点进行定位,而不是规定一个死板的参照标准.


交易系统开发

交易系统开发（一）——交易系统简介

一、交易过程简介
A股市场，投资者必须通过经纪公司交易柜台才能连接交易所，即交易订单从客户策略服务器发至经纪公司交易柜台，交易柜台内部处理后发往交易所，交易所确认报单后发送回报给交易柜台，再从柜台发送至客户策略机的一来一回整体链路的耗时。

报单发往交易所和回报返回至策略服务器的链路是一致的。
二、证券交易解决方案
1、证券交易解决方案简介
完整的证券交易包括交易所、买方、卖方，证券交易解决方案架构如下：

2、卖方
卖方是把各种资产包装成产品并提供给市场的实体，如各大证券公司（中信证券、中信建投、海通证券、国泰君安证券等）、期货公司（永安期货）。
3、买方
买方是进行投资管理的实体，如公募基金、私募基金、对冲基金、保险公司、个人投资者。
4、供应商
供应商是为买方和卖方提供业务解决方案的产商，如恒生（公募基金）、金仕达（期货）、金证（证券）、通达信（网上交易）、同花顺（网上交易）、大智慧（个人资讯）、Wind（证券交易、资讯）。
三、交易所交易系统架构
1、深交所交易系统业务架构

2、深交所交易系统架构 

3、深交所交易系统网络架构
深圳证券交易所交易系统网络架构如下：

4、深交所交易系统特点
（1）一体化交易服务

（2）多元化的业务服务

（3）灵活易扩展的接入服务

（4）高效的行情服务
支持0.5秒1轮快照的高速行情
（5）高可用

（6）高性能

（7）低延时

（8）高容量

（9）易扩展
性能和容量水平容易扩展：

灵活支持新产品和新业务：

5、深交所交易系统接口
（1）同时提供更快易扩展的两种接口，用户可以自主选择STEP接口、二进制接口。
（2）文件交换接口，支持XML文件、ETF PCF文件。
（3） 基于新接口的新网关，如交易网关、行情网关、文件网关。
（4）基础数据扩位

6、gateway简介
交易单元指会员（证券公司）向交易所申请设立的、参与证券交易与接受监管及服务的基本业务单位。会员可以根据需要，向交易所申请设立一个或多个交易单元；不同的会员不得使用同一交易单元。交易所通过交易单元对会员进行业务管理，根据会员的业务许可范围和申请，按照相关业务规则开通或限制交易单元各项交易权限。
网关指放置在会员处、用于连接会员与交易所交易系统的软硬件设施。会员可同时使用多个网关进行报盘，但不允许使用他人的网关报盘。会员可根据需要将下属交易单元配置到网关上。多个交易单元可以同时配置在一个网关上，一个交易单元也可以配置在多个网关上。
交易所通过网关对会员的报盘流速进行总量控制。当实际报盘速率达到网关的流速限制值时，节流功能开启，超过限制值的报盘将被推延至下一时段传送。会员可根据需要申请对网关的报盘流速进行设定。深交所规定每份标准流速为50笔/秒。配置到网关上的流速必须是标准流速的整倍数。目前单个网关支持的最大流速为1000笔/秒。交易所每年会对标准流速值进行检测和必要的调整，确保会员拥有的总体流速与市场发展需要相适应。

交易参与人(证券公司、基金公司等)需要连接交易网关、行情网关、文件网关。
Level I行情用户(纯行情用户，高单用户)需要连接行情网关。
Level II行情用户(信息服务商)需要连接行情网关、文件网关。
基金托管行需要连接交易网关 (接收成交数据)、文件网关 (视需要)、行情网关 (视需要)。
7、交易网关

交易网关敲门机制以平台为单位，不同平台独立进行敲门在每次平台从非开放状态转到开放状态时，交易网关测量网关与撮合引擎间的网络时延，并收取(且只收取)柜台第一笔委托，根据网络时延在平台开放前提前(提前量=网络时延)上报进行敲门，如果敲门成功(即申报被接受)，则正常处理后续委托，否则交易网关将立即以第一笔委托进行重试，直到敲门成功。
平台状态是“即将开放”或“开放”时柜台系统可以报单，其它状态下向网关发送的委托都会以“平台未开放”拒绝。
敲门过程中原因为“平台未开放”的业务拒绝将由网关自动处理(继续重试)，不会送给柜台。
敲门过程中柜台可以继续报单，但委托将缓存在网关操作系统的缓冲区中，在成功后网关才会接收。
8、行情网关
行情网关用于提供行情服务。不同的行情信息被分为多个频道发送,市场参与者可以根据需要选择只接收指定频道的行情信息。
Level2行情的逐笔委托和逐笔成交合成一个数据流发送实时行情发布频率、行情快照买卖盘个数可按业务需求配置。
9、交易接入网络
深交所交易接入网络如下：
（1）业务:交易+Level I行情
广域接入:证券公司(10M)、基金公司(6M或10M)
托管接入:1G或10G局域网
（2）高速行情网络
业务: Level II行情(Level I行情作为备份)
广域接入:10M以上
托管接入:1G或10G局域网
（3）高速单向卫星
业务: Level I行情
交易参与人的备用通道;纯行情用户的主用或备用
（4）双向卫星
Ø 业务:交易业务数据的备份通道
10、服务功能
深交所交易时段如下：

深交所风控以及交易管理功能如下：

11、撮合引擎
交易所交易系统的核心，用来匹配买卖订单。由于撮合引擎需要匹配证券市场的所有买家和卖家的委托订单，因此撮合引擎的稳定运转对于确保交易所的正常运作至关重要。
撮合引擎在交易所的机房里，为了能够更快地把订单传输到交易所进行撮合，HFT公司会尽可能地把自己的主机靠近交易所的数据中心。
12、交易所机房托管
国内交易所都有自己的服务器托管中心，如上交所外高桥上证通托管机房、深交所南方中心深圳通托管机房、上交所金桥托管机房。只有证券、期货公司可以向交易所租用托管机房机柜。证券、期货公司通过提供机柜、购买设备、购买或租用软件为其客户提供服务。高端程序化交易团队通常自购设备或指定硬件配置由证券、期货公司采购，经证券、期货公司同意，放到租用的机柜内进行交易。
Co-location适用于低延时交易用户。HFT公司或自营交易团队可向证券公司或期货公司申请机柜和网络资源，将交易主机与交易所的交易主机在物理距离上尽可能近地放置在一起。
交易所提供的托管机房受制于场地及电力所限，一般资源容量有限，常常供不应求。
四、量化交易系统架构
1、交易系统简介
在美国电子交易网络中，投资者可以用电话、传真等传统方式通过经纪商中介来参与交易，也可以通过交易市场直连（DMA）等方式，跳过经纪商中介，直接参与ECN等电子交易网络，或者通过各种证券交叉网络来选择匿名性更高的交易执行。在交易执行过程中，订单管理系统（Order Management Systems，OMS）和订单执行管理系统（Execution Management System，EMS）在整个交易网络中起着重要作用。
OMS（订单管理系统）是所有买方投资者交易活动的中枢，专注于提供投资者电子的交易能力，用来让投资者管理和记录其电子化交易活动，被买方投资者用来很好的与其经纪商交互，特别是基于FIX（Financial Information Exchange）的交易记录管理系统。随着交易技术的发展，Direct Market Access（DMA）的引入、算法交易及订单路由（Order Routing）的出现，买方交易迫切需要一种新的、更侧重于管理交易执行过程而非仅仅有交互和记录功能的系统，解决方案就是随后出现的EMS（订单执行管理系统）。EMS专注于增强经纪商在直接市场（Direct Market）、算法交易等方面执行电子交易策略的功能，即通过内嵌的算法交易引擎，利用ECN、Crossing网络等项，找寻多元交易选择，从而发掘更全面的流动性来源。
随着市场的发展，执行管理系统和订单管理系统有互相靠拢的趋势，EMS和OMS也逐渐具备了对方系统的部分功能。
2、交易系统分类
目前EMS/OMS系统分类如下：
（1）OMS。
多数买方机构并不非常需要高级执行管理能力，且已有的订单管理系统已经满足所需要的功能，因而部分买方机构仅在OMS订单管理系统上运作。
（2）EMS
部分机构选择EMS，高级的执行管理能力和速度是平台的关键决定因素。积极交易策略的对冲基金多数使用EMS。
3）基于FIX整合的EMS/OMS
整合EMS和OMS的平台，客户可以在EMS上管理所有的执行功能，但依赖OMS来进行基本的订单管理、验证和结算等。
4）完全整合的EMS/OMS。
在长期来看，更稳定的交易执行平台必须完全整合EMS和OMS。但鉴于代码层整合及数据流协调等诸多方面的复杂性，整合并不容易。
OMS（Order Management System）是订单管理的核心业务系统，典型案例是各大证券公司的大集中系统。
EMS（Execution Management System）是提供更多订单类型和订单执行的核心业务系统，是OMS的强助力。
PMS（Portfolio Management System）是提供对客户的资产组合分析的系统，提供如资产报告、交易报告、组合分析、盈利分析、风险分析、交易行为分析、账户诊断、风控与合规等功能。
POMS（Portfolio and Order Management System）是PMS和OMS结合的系统的统称。
3、量化交易架构

优秀的量化交易系统拥有最快接收行情数据线路、最快数据处理与读取能力、最好的策略软件、最快的交易通道，每个环节缺一不可。
4、欧美证券市场交易系统实践
目前，欧美证券市场中的机构投资者大多根据自身需求的特点，选择适合自己的交易执行系统。根据交易频率和投资策略的复杂度可以把机构的对OMS及EMS的选择很好地划分出来。使用较复杂的交易策略，如统计套利、高频黑匣子（Black Box）等交易频繁的机构，通常偏好使用EMS；仅使用简单交易策略，如仅买入持有、关注全球宏观等且交易不频繁的机构，通常仅需要OMS即可；长期投资，特别是多数养老基金、共同基金等，偏好OMS；对冲基金，特别是使用高级交易算法和策略的对冲基金，则多倾向于EMS。
五、交易执行策略
1、交易执行简介
在证券投资活动中，交易执行是最基本的行为。不论组合交易还是复杂的套利策略，最终均会以基本的买入或卖出实现。随着资产管理规模的不断增加，机构投资者的交易行为对市场的影响越来越大。如何在不惊动市场的前提下买进或卖出大额证券从而承担较低的交易成本并避免市场的异常波动，已经成为机构投资者和证券监管当局最为关注的问题之一。
算法交易（Algorithmic Trading）提供了一种解决思路。算法交易技术将交易执行的目标以金融数学的方式转化为特定的策略模型，并基于计算机技术和信息技术将证券订单指令流予以计算机化（程序化、算法化）且以恰当的模式进行交易执行，以期获得较高执行质量。
在成熟市场，算法交易的用户包括经纪商、对冲基金、养老基金、共同基金以及公司中有自己算法交易系统的自营交易部门。
2、交易成本
证券投资活动中的交易成本可分为外生成本和内生成本两部分。外生成本包括佣金、印花税等，由交易所和监管部门制定收费比率，一般在股票实际交易前就可以确定大小；内生成本是指股票成交过程中受到市场条件、执行情况等因素影响而产生的成本，也称为交易执行成本，包括机会成本和冲击成本两部分。冲击成本指订单交易行为对市场价格的影响程度。当订单规模等于或者小于最优报价档位（即最优卖档或最优买档）的市场深度时，订单能够在最优买价或卖价上执行；当订单规模超过最优报价档位（即最优卖档或最优买档）的市场深度时，订单的交易会使市场价格向不利于交易者的方向变化。因此，订单的交易数量越大冲击成本也越大。机会成本指从投资者下达订单开始到订单执行完毕（或者最终没有执行而撤单）时间内的价格风险。由于新信息的进入、投资者情绪、临时流动性缺失等因素的影响，证券价格波动会导致订单执行价格相对订单下达时存在一定差别，即为订单的机会成本。
外生成本的收取大多实施固定手续费制度，投资者每笔交易所需外生成本是非常明确的；而市场条件的不确定及执行情况的内生性引发的交易不确定性使交易执行成本具有隐含性，往往导致许多投资者在观念上及实际操作过程中将外生成本视为交易总成本而忽视了交易执行成本的存在。
根据ITG公布的以交易执行损失（IS）方法衡量的主要证券市场交易执行成本情况，在2012年第二季度，世界主要市场的内生成本占交易总成本的84%，而外生成本仅占16%，表明在海外成熟证券市场交易过程中由机会成本和冲击成本构成的交易执行成本在总成本中的重要性。
3、交易执行策略基本框架
投资者的需要权衡选择即时交易还是延期交易，确保选择恰当的执行策略使交易成本最低。对大额交易需求，需要在制定执行策略时深入讨论需要在多久的时间内执行完毕，每次执行多大的头寸。
投资者可以通过一次性交易或拆分订单的方式完成大额交易。在选择前者时，大额交易很可能对市场产生较大冲击，导致实际成交价格向不利的方向变动，机构投资者需要承担较高的市场冲击成本；在选择后者时，虽然可以有效降低对市场的冲击，但大额交易全部完成的交易时间往往较长，机构投资者必须承担较大的价格波动风险，即承担较高的机会成本。为此，机构投资者必须在不同执行策略引起的市场冲击成本和机会成本中做出权衡，选择符合自己风险偏好、效用最大的执行策略，即采取何种交易策略以及如何确定分割订单的规模。

假定某个机构投资者考虑在时间（0，T）之间买入或卖出头寸大小为X的股票（买卖均可，以卖出为例）。机构投资者在初始时刻的头寸大小为X，T时刻剩余头寸为0。设每个时刻点的交易头寸为xi，序列表征了一种交易执行策略。在实际交易过程中，存在无数种不同的交易执行策略，以横坐标为时间，纵坐标为持有的头寸大小的坐标体系来表征整个执行过程。假定在卖出过程中不能买入，那么每个执行过程可以表征为一条连接（0,X）点与（T,0）点的下降轨迹曲线。

投资者在不同的执行策略下面临着不同的风险与收益选择，不同风险偏好的投资者会选择不同的执行策略。对于风险中性投资者而言，只关心交易过程中执行成本的大小，而不管执行过程面临的风险，交易时可能更倾向于将交易时间拉长，拆分订单更细，以避免对市场的价格冲击，其可能会选择匀速平均的执行策略C；极度厌恶风险的投资者不愿承担哪怕极小的价格风险，其会选择执行策略A，交易一开始就全部卖出，将不确定性削减到最小；对于极度偏好风险的投资者，将会选择执行策略E。而对于其他风险厌恶的投资者而言，投资者会根据自身的风险偏好，选择适合自己的恰当的执行策略。
4、交易执行策略的方法
恰当地选择执行策略是投资者在交易时能否顺利进行的核心和关键。在电子化交易中，执行策略的选择更多地体现为算法交易策略的选择和使用 。具体表现为，投资者利用计算机算法决定交易下单的时机、价格乃至最终下单的数量与笔数等，通过将大额的交易分解为若干笔小额的交易，以便更好地管理市场冲击成本、机会成本和风险。随着交易技术的发展及执行策略理论研究的深入，交易执行的算法交易也在不断发展：
A． 第一代算法交易策略
最初的算法交易要解决的问题是计算机能替代人工下单，以实现每隔一段时间就按照某种模式下达交易指令的目的，主要实现订单提交的功能。如在国际市场上使用最多的成交量加权平均价格（VWAP）、时间加权平均价格（TWAP）。
B． 第二代算法交易策略
第二代关于交易执行的算法交易策略始于投资者对最优执行策略认识质的变化。第二代算法交易策略已经开始关注如下问题：在确定的交易执行期，如何分配各时点的执行头寸才能使交易成本最低？若按照类似VWAP或者平均策略那样的每个时刻均参与交易，如何决定交易的执行期，是一天，还是一个周，在执行快慢中如何选择权衡？ 总的来看，此类算法不会根据市场的状况主动选择交易的时机与数量，而是按照一个既定的目的进行交易，因而也被称为被动型算法交易，或者结构型算法交易。如在国际市场上使用较多的到达价格（Arrive Price）策略、执行损失（Implementation Shortfall）算法。
C． 第三代算法交易策略
第二代算法交易策略认为市场是平稳及可预测的，一旦根据模型和数据获得执行策略，不管流动性及其它的市场条件的变化，交易一般不会偏离预定轨迹。但在实际情况下，基于历史数据的模型无法对一些极端市场情况加以考虑，这使得投资者期望在市场条件发生变化时，交易执行策略能够进行自适应调整。因此，在行业实践中出现了很多随着价格运动而改变执行迫切度的主动性策略。除了考虑第二代算法交易策略关注的如何降低执行成本和价格风险外，这类自适应交易算法把关注的重点转向了价格趋势预测。例如，投资者如判断市场价格在向有利于方向运动时就推迟交易的进行，反之则加快交易的速度；当市场价格存在较强的均值回归现象时，投资者能够抓住有利的偏移。
目前，最常见的算法交易策略包括VWAP、TWAP、Target Volume、Arrive Price，在大多数经纪商的系统中均提供。此外，还有一些机构为客户量身定制的策略。例如，隐身( Stealth )、游击队、狙击手(Sniper)、嗅探器(Sniffer)等。现有海外机构投资者的算法交易系统而言，一部分机构投资者的算法交易系统需要提供自定义参数。例如，需要交易者自定义执行的数量、执行的方式、选择的算法交易策略、交易起止时间、参与的交易量比例等，这些参数的设定决定了交易系统对该笔交易的执行情况，比如Instinet的Execution Experts对VWAP策略的设定（见图3）。同样，有部分机构投资者能够完全将自身研发的最优交易执行策略完全内嵌到交易系统中，例如海外著名交易执行服务提供经纪商ITG公司ACE系统的最优执行策略等。
随着执行策略的研究深入和完善，算法交易策略已被对冲基金、养老基金、共同基金以及其它机构交易者广泛使用，各大经纪商或第三方交易服务商纷纷开发出嵌入算法交易的管理系统，并在美国绝大多数的经纪商或第三方交易执行服务商中均得到了应用，如美银的Electronic Algorithmic Strategy Execution (EASE)，巴克莱资本的LME系统, 摩根斯坦利的Benchmark Execution Strategies (BXS)等。根据服务提供商对使用这些系统的客户的分类统计，在证券交易经纪商（Broker/Dealers）、对冲基金（Hedge Funds）、共同基金（Mutual Funds）、自营交易部门（Proprietary trading desks）四类客户中，比例最高的多数为对冲基金及共同基金，在绝大多数的服务提供商中超过一半多的客户来自于这两类。随着算法交易服务商队伍的扩张规模较大的投资银行、经纪商每年都会投入不菲的研究经费，用于开发更为迅速满足客户个性化需求的算法，以拉开与同业竞争对手的差距。而那些小机构则很难承担巨额的研发费用，不得不向大机构购买算法。
5、A股证券市场交易执行策略实践
交易执行在A股证券市场还处于起步阶段，在实践操作中，交易执行的应用较少，程序相对简单，风险基本可控。A股证券市场的交易执行特点如下：
（1）以人工下单模式为主，交易执行下单为辅，但交易执行下单占比呈递增趋势。
自2009年以来，交易执行逐步引入国内证券市场，得到了市场参与者的重视。
在基金方面，截至2012年底，国内基金公司共73家，绝大部分的柜台系统为恒生03系统。目前，该系统已经嵌入瑞银证券和国信证券的算法交易模块，包括华夏、嘉实、易方达、博时、南方等20家基金公司购买了交易执行技术系统，并在实际交易中利用交易执行进行交易。一些管理规模较大、交易量较多的基金公司采用交易执行进行交易的比重不断提升。例如，华夏、嘉实、工银瑞信等公司的股票交易量中约有15%至25%由交易执行完成。从我们之前对基金交易执行成本的分析结论就进一步表明交易执行占比在逐步增加。
在券商方面，国信证券、海通证券、中信证券、广发证券等纷纷开始开发交易执行策略。在2009年7月，瑞银证券利用交易执行在QFII业务方面开展机构客户经纪业务，交易执行在瑞银证券正式启用，目前瑞银证券的交易执行的交易量已占交易总量的80%。国信证券的交易执行服务在2010年在彭博系统正式上线，成为本土券商中第一家在彭博系统中推出针对A股市场算法交易服务的证券公司，全球机构投资者可以通过遍布各大金融机构的彭博终端选择使用国信证券算法交易服务参与中国证券市场的投资与交易。中信证券在2012年选择Progress软件公司Apama算法交易平台，为机构投资客户提供包括交易执行在内的低延迟高频算法交易策略。广发证券在2012年则选择美国StreamBase和Thomson Reuters合作提供的一个算法平台来开发交易执行策略。
（2）交易执行技术程序简便，应用对象有限
以基金行业为例，基金公司目前采用海外市场较为成熟并且相对简单的交易执行模型，如交易量加权平均价格（VWAP）、时间加权平均价格（TWVP）等，对于其他一些诸如执行差额（IS）等改进算法的应用较少。在应用对象方面，目前交易执行主要应用于流通市值较大、流动性较好以及波动性较小的股票。由于交易执行技术在国内应用时间不长，具体效果有待检验，对于波动性较大的中小盘股，基金还是以人工下单为主。
（3）交易执行优势出现，但尚未完全显现
尽管国内交易执行优势已经出现，但尚未完全显现。原因在于，我国部分交易制度的缺失限制了交易执行的发展，这进一步阻碍了交易执行优势的完全显现。具体而言，交易执行在我国面临的限制包括：
A. T+1交易制度。我国股票市场目前采用T+1的交易制度，而算法交易一般需要进行大量的日内交易。T+1交易机制无疑会带给以高频交易为主的算法交易者带来极大的阻碍。
B. 交易费用较高。我国股票市场的交易费用较其他国家或地区更高，特别是股票交易存在单边成交金额0.1%的印花税，对算法交易来说影响更大。
C. 数据存在高延迟问题。我国股票市场中存在数据延迟问题，这会制约算法交易的顺利进行。目前，在股指期货市场中的行情信息为实时揭示，而我国股票市场中一般的行情揭示为5秒/次，Level2的行情揭示速度也仅为3秒/次。因此，目前股票市场数据存在高延迟情况，这不利于专业型投资者进行算法交易。
若上述问题解决后，随着交易技术的复杂化和交易频率的增加，交易执行的优势将进一步显现，机构投资者将更为重视交易执行，并投入更多的精力将此技术付诸实施
六、交易执行过程
1、交易执行过程简介
交易系统网络仅仅是投资者具备交易执行的硬件保障，投资者对于交易执行过程的应用手段及策略选择等软件保障同样重要。在欧美成熟证券市场，投资者的交易执行过程通常分为交易前计划(Pre-Trade Strategy Plan)、交易执行过程监控、交易后分析。
2、交易前计划
在决定交易的具体任务后，投资者需要对交易执行进行以下分析：
（1）交易执行标的分析（Identifying Potential Outliers）
投资者首先对组合的交易执行标的进行分析，充分获得执行标的历史执行特点，以识别出潜在的需要特别考虑的标的。例如，需要识别出那些流动性很差、很难交易的证券、具有较大的执行成本或者占较大比例的日均交易量的交易等。
（2）流动性来源及交易方式的选择
在识别交易标的执行概况后，投资者需要对标的证券的流动性来源进行分析，以选择恰当的执行系统等。以ITG为例，对高流动性的股票，可以使用ITG以交易量为基础的策略Horizon smart server；对流动性不好的股票或者相对日均交易量而言头寸比例过大的交易，可以人工去寻找流动性池（Liquidity Pools）或者通过大宗交易的配对系统（Block-Matching System），即ITG的POSIT等。
（3）执行策略的选择
执行策略在行业实践中表现为各种算法交易策略，即按照设定的形式执行将大额的交易分解为若干笔小额的交易，以便更好地管理市场冲击成本、机会成本和风险。市场上不同机构开发了大量不同形式的算法交易，各种算法交易都有各自的特点，算法交易的选择重点是投资者的需求，并不存在一种任何情况下最优算法交易策略。
不同的投资者有不同的交易风格和风险偏好，投资者的特点均会影响执行策略的选择。有些投资者可能交易非常迫切，在交易中将大部分执行在上午便完成，而其他投资者可能就非常有耐心，选择在较长的时间内慢慢执行；不同的投资者还有各自不同的交易成本标杆，例如指数基金可能希望购买的价格尽量接近收盘价。此外，在交易的过程中，如果股票的价格或者成交量发生了变化，投资者的投资意愿也可能会随之改变，这些都是影响算法交易选择的因素。因此，选择恰当的策略来执行各种不同的交易，需要从股票特点、市场的条件、投资者的风险偏好等出发，基于历史参数对各种策略进行绩效评估比较，以选择最匹配的策略来执行。
3、交易执行过程监控
在交易开始后，可能会有不可预料的事件或信息发生，从而改变执行交易的设定，影响交易执行的表现。如果构成策略执行的各种影响因素发生了变化，投资者需要改变执行策略来应对突发变化。例如，基于交易量分布的策略对影响交易量分布的信息或事件非常敏感，在交易执行过程中市场公布了可能导致交易量大幅变化的信息时，如果投资者不及时改变执行策略，可能会使交易策略面临灾难性的结果。
因此，投资者需要监控系统来评估突发事件发生的可能性及事件发生后对执行策略的影响程度。简单的交易量信号和实时的最优买卖价差等指标均能帮助投资者较好地应对执行策略过程中的信息事件。
4、交易后分析
交易执行完毕后，投资者需要对交易执行质量进行评估，即通过对预定目标的估算执行成本与实际执行成本的差价进行识别分析。对差价的分析可以让投资者明白执行成本出现变化的原因——是市场条件的剧烈变化，还是执行策略选择上的不恰当。例如，若使用VWAP策略来交易低流动性的股票，可能产生大的差价，因为低流动性的股票的交易量模式很难去准确预测，会影响VWAP策略的执行质量，而交易后的分析通常会识别出不合理的差价。交易后的分析对交易执行的反馈非常重要，从其中得到的分析结论会影响未来交易执行的选择。


交易系统开发（二）——行情数据

一、行情数据简介
1、行情数据简介
行情数据是交易过程中最基本、最重要的部分。一次完整的交易通常分为三个步骤：接收行情、分析行情（策略部分）、发出买卖指令并成交（算法交易部分）。对于高频交易和低延迟交易者，行情数据的精度和细度尤其重要。精度是指数据的准确性和能在多大程度上反映市场的真实情况，细度是指行情的推送频率。
行情数据分为两部分：交易行情和订单委托行情。交易行情就是交易数据，包括最新成交价、成交量、成交额、最高价、最低价等字段信息；订单委托行情就是买卖报价和委托量，根据委托价格的不同，可以分为一档、五档、十档等行情；通常把交易行情和订单委托行情结合在一起，形成TAQ（Trades and Quotes）行情。
行情数据通常使用UDP组播进行转发，实时数据还要分A/B channel做冗余备份，再加一个Snapshot channel做备份。
2、tick行情与快照行情
tick行情也称逐笔行情，是完整记录了市场所有信息的数据，即会记录市场每一个event，如发生一次交易或者增加一个新订单，是最精细和最完整的行情数据。
快照（snapshot）行情是对tick行情数据在时间维度上进行一定频率切片后的统计数据，是一个时间截面上的统计数据。tick数据更为精确，快照行情根据时间频率的不同精确度也不同。
3、行情数据提供商
（1）Wind
官网：http://www.wind.com.cn/
老牌数据供应商，内容涵盖股票、债券、基金、衍生品、指数、宏观行业，价格较贵，是机构的首选。
（2）微盛数海
官网：http://www.wsbigdata.com/
提供股票、外汇、黄金、股指、国债期货等多个品种的API接口，与多家知名品牌有合作，是仅次于万得的供应商。
（3）立得行情数据
官网：http://ldhqsj.com/
提供股票、国内外期货、期权、指数、基金、债券、外汇汇率等行情，API接口模式。功能较全面，例如K线数据可选2种复权方式、9种时间周期，几十种指标。还提供其它网站所没有的沪深、港股实时五档分笔tick数据。
（4）大富翁数据中心
官网：http://www.licai668.cn
品种多样，涵盖沪深、港股、国内期权、国内外期货、贵金属。需安装专用的客户端才能使用，客户端可接收全推行情。
（5）金数源数据服务
官网：http://www.jinshuyuan.net/
有沪深股市和国内期货数据，以盘后下载csv文件为主。高频数据是它的强项，有A股分笔、level2逐笔数据(盘后下载)和国内期货tick数据(API接口)。另外它还提供免费的A股日K线数据(未复权)。
（6）财富通数据中心
官网：http://www.caifushuju.cn/
以盘后数据为主，包含股票、期货、贵金属、ETF期权、外汇。
二、行情数据需求
1、行情数据需求简介
2019年，上交所、深交所、中金所分别推出了沪深300ETF期权、沪深300指数期货期权，加上股指期货逐步松绑，投资机构在风险管理时有了更多、更好的对冲工具，可以构建更多的策略组合。尤其是金融市场剧烈波动时，沪深300股指期权和中证500股指期货的交易量猛增。根据期货业协会的数据，2020年2月份中金所月成交额同比增长169.76%，股指期货和期权已成为量化、程序化客户重要的对冲工具。
三大交易所金融衍生品的扩容，不仅有助于提升投资者风险防控能力，维护市场健康发展，也对金融IT系统发展起到积极的推动作用。
要开展新业务，第一步做的就是搭建满足业务需求的IT系统。
IT行情系统业务需求如下：
（1）面向大型机构客户，交易资金量大、换仓频繁，要提升交易系统性能，以满足其快速交易的需求；
（2）面向量化客户，为了量化T0、期现套利、ETF溢价对冲等策略的执行，需要同时收听上交所、深交所和中金所的实时行情。
2、行情服务用户需求分析
行情服务用户需求分析如下：
（1）快，第一时间收到行情；
（2）多交易所行情服务；
（3）能够在同一托管机房收听；
（4）用户个性化需求。
3、跨交易所行情服务
期权在风险管理和交易上的应用是多样化的，有单纯的方向性交易，也有复杂一些的组合应用，如保险、增强收益、套利交易等。
（1）保险
保险功能是期权市场最重要的功能之一，能够帮助投资者规避未来市场出现不利变化时可能带来的损失。
案例：持有现货的情况下，买入认沽期权，可以在一定程度上规避因股价下跌而带来的损失。
（2）增强收益
在市场波动小、趋势不明显的行情下，投资者可以通过卖出期权获得权利金收入，从而增厚收益。
案例：备兑开仓策略，持有沪深300ETF或相关资产，同时卖出沪深300ETF认购期权或沪深300指数认购期权，通过期权费收入可以增强资产组合收益。
（3）套利
目前不同交易所上市的3种股指期权标的，可套利标的数量、可能出现的套利机会、标的间的可组合数量都会大大增加。期权组合之间，期权组合和期货之间都可以套利。
案例：
跨品种套利：上证50指数的所有成分股都在沪深300指数中，上证50指数与沪深300指数的相关性也非常高。因为二者极高的相关性，使得两个指数相关产品之间的跨品种套利成为了可能，当两者走势各异时就会有套利机会出现，可以通过买入相对便宜的品种，卖出相对贵的品种并期待价差收敛从而获利。
价差套利：看涨和看跌期权可以模拟出期货价格，如果期权模拟出的期货价格与沪深300ETF产生价差，可以一边做多沪深300ETF，一边做空期权组合来实现收益。
（4）方向性交易
主要为投资者基于对市场的涨跌方向判断，进行期权投资，并在单边行情基础上获得收益。
案例：投资者判断未来一个月上证50能够上涨，因此买入50ETF 看涨期权，若后续市场上行，则可以选择行权获得收益。
据《2019年上海证券交易所股票期权市场发展报告》披露，保险、增强收益、套利和方向性交易四类交易行为占比分别为12.87%、43.77%、19.97%、23.39%。
从投资者类别看，机构投资者主要以增强收益和套利交易为主，个人投资者则主要以增强收益和方向性交易为主。
因此，专业投资者在进行风险管理时，需要在同一机房、同时收听关联市场的行情走势。
4、高效行情服务
基于行情的性能、合规、数据内容等角度考虑，申请Level-2非展示行情授权是获得跨市场极速行情的最佳途径。
（1）行情源更合规
交易所行情源直达指定的托管机房，速度优势远大于其它渠道转发的二、三手行情。
（2）接收速度快
Level-2行情采用FAST协议，行情快照速度从6s提高到3s，终端行情刷新速度提高了5到10秒。
三、Level 1行情数据
Level-1行情是交易所根据交易规则发布的即时行情信息；数据格式包括基于FIX/FAST协议的接口和TXT文件；行情通过交易所信息技术公司的高速地面网和宽带广播卫星系统发布或上证所信息网络有限公司的互联网和专线传输。
证券交易所的Level-1行情主要提供股票、债券、基金和指数等业务品种的行情信息。集合竞价期间提供证券代码、证券简称、前收盘价格、虚拟开盘价、虚拟匹配量、虚拟未匹配量和虚拟未匹配量的剩余方向；连续竞价期间提供证券代码、证券简称、前收盘价格、最新成交价格、当日最高成交价格、当日最低成交价格、当日累计成交量、当日累计成交金额、实时最高五个买入申报价格和数量、实时最低五个卖出申报价格和数量。
上交所和深交所的Level 1和Level 2 TAQ行情数据都是3秒频率的快照数据。
股票市场Level 2行情数据的逐笔交易数据确实是记录了每笔交易的，是真正的tick数据，在时间精度上，也精确到了10ms，但是其实时推送频率也是3秒一次的，因此数据本身的时间精度和推送精度并一定是一致的。
首先是股票市场，对于上交所和深交所，level 1行情数据有3秒一个快照的TAQ数据和分时数据，其中TAQ中的订单委托数据为五档行情数据；对于level 2数据，上交所和深交所有所不同，上交所的level 2依然是3秒一个快照的TAQ数据、3秒一个快照的50档订单队列和逐笔交易数据，深交所则是实时推送，并且还有tick级别的订单委托数据，其中level 2的TAQ中的订单委托数据为10档行情，比level 1多了5档；订单委托队列数据就是按照成交优先级顺序排列的一档价位的逐个委托的订单数据，共呈现了50个委托队列。
期货市场的level 1和level 2数据实际上就是TAQ快照数据，和股票市场的level 1数据比较像，但是相比对股票市场，期货市场的快照频率为500ms一个推送，相比于股票市场的3秒一个推送，其频率高了很多。期货市场中的level 1中的订单委托行情只有一档，而level 2则是五档，所以level 2相比于level 1提供了更深的订单委托行情数据。目前，期货市场的level 1行情是500ms一个推送，level 2行情数据中，中金所和上期所依然是500ms一次，其它交易所都是250ms推送一次，但是上期所也即将上线250ms频率的行情。
上交所的level 2行情提供了交易的tick数据，3秒一次推送；深交所level 2行情提供了交易和订单委托的tick数据，实时推送。
在期货市场上，实际上只有快照数据，一般说的一秒钟里面有几个tick，实际上指的就是一秒里面有几个快照而已，并非严格意义上的tick数据。
四、Level 2行情数据
1、Level 2行情
Level-2行情为上证所信息网络有限公司推出的上海证券交易所新一代行情，是在基础行情上增加了增值信息，以更好地满足机构投资者和专业投资者对行情信息的差异化需求。数据采用基于FIX/FAST协议的接口，行情通过上证所信息网络有限公司的专网传输。
2、Level 2行情的特点
作为增值行情，Level-2行情特点如下：
（1）更丰富的信息
更多的盘口订单数据、逐笔成交数据、成交与订单关联数据及增值数据，揭示交易细节，全方位反映市场状态
（2）更丰富的委托盘口
提供买卖方10个价位的价格、股数和委托笔数信息，同时提供第一档位的前50笔订单的委托量，揭示买卖双方行为细节
（3）更低时延
采用国际一流的FAST协议，毫秒级时延的技术系统让数据更迅速直达用户
（4）更多增值服务
数据经专业的信息服务商加工，可以衍生出更多的技术分析指标，如资金流向和大单分析等
（5）更高的服务质量保障
提供重发机制，确保数据可靠、准确，不丢失任何一笔数据
3、Level 2行情的优点
Level-行情比Level-1行情增加的主要内容：
（1）增加委托信息
汇总的委托笔数、委托数量及加权平均价格；
前10档的价格、委托数量及委托笔数；
前1档价位前50笔订单的委托数量；
总的价位深度数量；
（2）增加成交数据
逐笔成交明细数据；
买／卖方订单成交的最长等待时间；
（3）增加增值数据
买／卖方的累计撤单笔数、数量和金额；
ETF申购；
五、Datafeed非展示行情
1、Datafeed行情简介
算法交易、风险控制、数据分析研究和开发策略等高端应用如果需要听取实时市场报价，需要接入Datafeed非展示行情才能接收并使用行情。
Datafeed非展示行情是股票或期货Level2深度行情的一种使用模式，通过特定的API接口来接收交易所发出的行情数据。
Datafeed和Level-2数据来源一样，但Datafeed侧重于用（比如交易、分析研究），Level-2侧重于展示。
Level-2行情以图形化的形式直观地展现当前的市场波动，但行情数据不允许落地及接口获取，只能用于PC或者手机终端进行展示之用。
2、行情数据接入
交易所对实时行情数据的接入和转发是有明确限制的，任何未经授权的单位和个人不得擅自转发或传播交易所交易行情信息。
各大证券、期货交易所下属的技术公司或信息公司负责实时、历史行情对外的授权管理，用户可直接通过技术、信息公司提供的API接口，利用机房托管的方式接收交易所的深度行情，可以避免通过信息商获取数据的延迟问题。
Datafeed行情数据的接入申请包括资质、技术等各个方面的审核，
以及授权单位必须严格按交易所书面认可的用途（自用or转发）使用非展示数据。
（1）深交所
行情内容：在基本即时行情的基础上，实时买卖盘由五档扩展到十档，并增加最佳价位的前50个分档明细、逐笔委托、逐笔成交等信息；
发布频率：3秒/次；
传输形式：TCP；
（2）上交所
行情内容：在Level-1基础上增加委托信息（如委托笔数、委托数量及加权平均价格；前10档的价格、委托数量及委托笔数；前1档价位前50笔订单的委托数量；总的价位深度数量）、成交信息（逐笔成交明细数据买／卖方订单成交的最长等待时间）、增值数据（买／卖方的累计撤单笔数、数量和金额 ETF申购）
发布频率：3秒/次；
传输形式：TCP；
（3）大商所
行情内容：5级深度委托行情、最佳买卖价位上前10笔分笔委托量、加权平均委买价格、实时结算价、分价位成交量统计等8种数据；
发布频率：0.25秒/次；
传输形式：TCP、UDP点播及组播；
（4）郑商所
行情内容：合约编码、前收盘、前结算、昨持仓量、开盘价、收盘价、最高价、最低价、最新价、申买价、申卖价、申买量、申卖量、结算价、均价、涨停板、跌停板、成交量、持仓量、5级深度委托行情、委买总量、委卖总量；
发布频率：0.25秒/次；
传输形式：TCP或UDP组播；
（5）上期所/能源中心：
主要内容：合约编码、最新价、合约数量、成交金额、持仓量、最高价、最低价、今开盘、今收盘等；
发布频率：0.5秒/次；
传输形式：TCP或UDP组播；
（6）中金所
行情内容：合约名称、交割月份、最新价、涨跌、成交量、持仓量、申买价（最优五笔）、申卖价（最优五笔）、申买量（最优五笔）、申卖量（最优五笔）、结算价、开盘价、收盘价、最高价、最低价、前结算价、成交额等；
发布频率：0.5秒/次；
传输形式：TCP或UDP组播；
3、行情转发系统
符合合规要求和市场需求的行情转发系统需要具备功能如下：
（1）满足用户需求
在上海接收深交所行情，行情网关部署在哪里可降低时延；
不同交易所行情格式不同，如何处理便于用户快速接入；
是否可以对数据进行计算拼装，通过技术服务来满足用户个性化的需求；
（2）符合交易所合规要求
如何按照交易所的要求，进行行情转发的边界控制；
对所有的接入用户的权限进行统计和控制，建立数据库可供交易所查询；
（3）便于日常运维
能够实时监控系统的状态；
定位故障问题；
快速修复；
4、非展示行情申请
非展示行情申请授权，获得行情网关，必须满足交易所合规要求。
非展示行情的使用授权需要向交易所信息公司或技术公司进行申请，交易所会对企业资质、技术方案等各个方面进行审核。
授权单位必须严格按交易所书面认可的用途（自用or转发）使用非展示数据。
上交所行情授权联系上证信息，深交所联系深证信息，中金所联系中金技术。上交所、深交所、中金所非展示行情申请授权流程如下：

通过行情授权申请后，交易所信息公司会下发行情网关，券商和期货公司需要通过行情网关来获得行情数据。
上交所行情网关是VDE，即Vendor Data Engine，和交易所上游行情源服务器通过TCP协议连接，和下游行情转发系统通过TCP连接；深交所行情网关是MDGW，即Market Data Gateway，和交易所上游行情源服通过UDP连接，和下游行情转发系统通过TCP连接；中金所没有行情网关概念，通过前置机进行连接。
5、技术方案书和现场检查
向交易所申请授权，重点有技术方案书和现场检查两个环节。
根据交易所要求，在申请时需要提供技术方案书，需要说明行情转发系统技术方案、灾备方案，以及如何保障数据合规使用。
技术方案书，主要包含四大主要模块的说明：
（1）技术体系结构描述；
（2）操作终端管理描述；
（3）数据信息安全措施描述；
（4）系统测试情况；
方案书得到交易所批准后，即可开始准备现场检查。
现场检查重点关注四个方面：
（1）系统技术架构、灾备结构、网络部署等情况；
（2）是否存在非法转发、用户转发数漏报的情况；
（3）用户管理系统检查，用户数据不得删除且至少保留五年；
（4）机房情况是否达标。
现场检查通过后交易所会下发网关程序，拿到网关程序后即可切换生产环境进行自用与转发。
6、行情服务运维
行情收发不可避免地会出现一些问题，比如行情断线、丢包。原因如网络异常、进程异常、流量过大导致网关断连和buffer超载。
因此，运维时为确保行情系统稳定运行无故障可以监控如下指标：
（1）各节点网络状态；
（2）进程状态；
（3）行情落地时间管理；
（4）日志监控；
六、交易所行情对接
1、交易所行情对接
LDDS: 低延时行情发布系统（Low–Latency Data Distribution System）。
VDE: Vendor Data Engine前置机，深圳证券交易所新行情系统提供给信息商系统的接入点服务器。
DDS: IDC中的数据发布服务器。
DRS: IDC中的数据重建服务器。
VSS: Vendor Supplied System信息商服务器，经过许可接入深圳证券交易所新行情系统的信息商服务器。
上海证券交易所提供的LDDS-VDE是一个纯Java服务，启动后，VDE会和DDS服务器建立TCP连接，并且按需短连接DRS服务器。用户可以从VDE获取到上海证券交易所和深圳证券交易所的行情数据。
LDDS-VDE默认配置com.sseinfo.lddsidc.thread.vss.RealTimeClientThread 会将行情快照约每隔3秒更新到文件中 mktdt00.txt，用户可以通过读取文件或者直接连接VDE的9129端口获取到上交所的行情。
LDDS-VDE会对深交所的行情数据进行转发，虽然在9129也可以读取到深交所的数据，但建议连接VDE的 6666 端口通过Binary协议获取深交所的行情数据。
建立TCP连接后，VSS需要向VDE发送Login请求，如果登录没有问题，VDE会回复Login请求，随后开始推送行情数据。
定时发送Heartbeat消息以供检查连接有没有断掉，Heartbeat间隔是Login请求中设置的HeartBtInt 。
2、交易所行情转发
从2018年末开始，中金所对股指期货交易的限制逐步松绑，不少期货公司开始增加对股指期货交易的关注和技术投入，时刻准备着为专业机构用户提供差异化、优质的服务支持。
量化机构用户随着股指期货的解冻，入市热情逐渐升温，沪深两市的Level 2深度行情是量化机构用户交易股指期货的必备行情数据需求，也是期货公司提高专业服务水平，满足机构用户个性化需求的必备服务工具。
根据上证所信息网络有限公司Level-2非展示数据的许可单位公示名单，南华期货、兴证期货、中信期货、海通期货、中辉期货和五矿经易期货六家期货公司率先获得了上海证券交易所Level-2深度行情的技术方案验收认可和数据使用授权，并已在中金所托管机房接通行情专线，可供授权用户使用。
行情授权许可是使用Level-2非展示数据的第一步，还需通过技术解决方案实现行情接入、解码、转发等功能。
3、行情转发系统
上证所和深交所的Level-2行情数据通过Level-2行情生成引擎生成后，经行情发布中心发送到信息接收组件，通过UDP组播行情分发系统直接转发给客户。
UDP组播行情分发系统的特点：
（1）接收行情后直接分发，不经过程序的中转清洗处理，效率更高。
（2）将行情通过UDP组播而非TCP分发，支持更多并发客户，高效公平，可扩展性强。
（3）允许投资者按需订阅行情信息，有针对性地对指定股票行情解码，避免了对整个市场行情解码造成的性能损耗，提升了带宽的使用效率。
（4）支持将需要的行情分类发布到指定的组播地址以满足投资者的需求。
（5）具备完善的合规控制，所有行情仅在授权机房内广播。
（6）支持实时查询用户列表、MAC地址、IP地址等信息，并提供详细日志报表。
（7）沿用传统行情商的格式发布数据，以确保用户可以在做出尽量少的代码改动的情况下接入智喆系统。
（8）在配置不同组件时，也可同时支持期货交易所行情的接收与转发。
4、行情接口
对于任何程序化交易策略而言，行情接口和交易接口都是不可或缺的组成部分，行情是所有交易策略最基础的信号源，而各种交易信号的发送和接收则是交易策略的最终实现形式。
中国证券、期货市场采用会员制管理，只有交易所会员单位即证券公司、期货公司才有资格向交易所购买交易席位。程序化交易团队可以联系证券、期货公司提供交易接口的通道服务。
国内各大交易所对外提供行情接口服务的信息技术子公司如下：
上交所下属子公司——上交所技术有限公司
深交所下属子公司——深圳证券通信有限公司
郑商所下属子公司——郑州易盛信息技术有限公司
大商所下属子公司——大连飞创信息技术有限公司
上期所下属子公司——上海期货信息技术有限公司
中金所下属子公司——上海金融期货信息技术有限公司
七、行情数据加速
FPGA（Field Programmable Gate Array，现场可编程门阵列）是一种半定制电路，可以被重新编程（硬件编程）。
FPGA工程师不必依赖厂家的标准化芯片，而根据实际需要，通过改变电路逻辑连接关系，实现各种运算功能。
FPGA的优势在于运行效率高、速度快，但开发周期长、调试纠错较困难、逻辑实现的灵活度较弱、更新换代成本高。
随着金融科技发展，金融交易追求更低交易延迟的竞赛不断升级，传统的软件技术或以软件为核心的加速技术难以满足微秒级的实时处理和实时响应的要求。业内均在寻求搭建低时延交易系统的解决方案,基于GPU、FPGA硬件并行加速的技术逐渐进入证券交易领域，成为金融科技领域顶尖的科技趋势。
降低交易延迟本质是如何实现金融数据加速。FPGA具有硬件可编程、低功耗、低时延的特性。基于RTL(Register Transfer Level :寄存器传输级)级的逻辑编程，可定制化各类通讯协议(如TCP/IP协议栈卸载)、各种消息编解码(如上交所的FAST协议解码)及系统各种颗粒度的操作，实现数据的并行和流水的并行，达到极低的系统时延和极高的系统容量。





交易系统开发（三）——风控系统

一、风控系统简介
1、风控简介
对于程序化交易用户而言，无论是证券还是期货市场，每一个交易指令都需要进行充分的业务检查，通过后才能进入交易所的订单队列进行匹配成交。
在程序化交易中，除了验资、验持仓等基础的风控检查外，符合交易所异常交易管理办法规定的监管标准，杜绝和防范异常交易行为也是程序化交易风控的重中之重，比如是否存在自成交、日内过度交易、频繁报撤单、大额报撤单、报单流速控制等情况。
如果交易指令没有进行严格的业务检查就发送至交易所，可能会造成严重交易事故，如光大证券乌龙指事件。
各交易所对程序化交易指令的买卖价格和数量、委托次数、撤单次数等交易行为有明确的管理办法，并且会定期公示查处情况。如果违规，就会收到来自交易所的警告和处罚。如果异常交易指令能在交易执行前就被风控系统发现和拦截，可大幅降低交易行为的违规率。
2、风控类型
风控类型一般分为事前、事中、事后三种。
事前风控是指在交易指令发送到交易所前，对交易指令进行风险检测，通过检测的交易指令则提交到交易模块进行报单，未通过检测的交易指令将直接予以拒绝。对于追求低延时的交易策略，事前风控需要在极短的时间内完成。
事中风控主要是指在交易过程中，交易团队对策略的信号生成、执行情况进行监控以及盘中对策略的风险度进行实时监控。
事后风控是对交易数据在盘后进行分析，比如策略算法是否存在错误、策略的回撤是否可控、是否有计划外的持仓出现等，从而制定更严谨的业务风控预案和优化代码算法调整策略表现。
二、事前风控
1、程序化交易风控
对于交易团队而言，最好的风控效果就是防患于未然。因此，程序化交易更多采用的是事前风控，在程序错误、操作失误出现前就将其扼杀在摇篮中，确保交易策略满足业务风控要求和交易所的合规要求。
2、事前风控的特点
（1）与交易系统耦合极高
交易系统（订单执行系统、订单管理系统）会对所有交易指令进行筛选，通过风控检查的交易指令才会触发交易执行函数进行报单，风控检查不通过的进行拒单。
（2）低延时、高可靠性
事前风控是对所有交易指令进行过滤，因此对可靠性有严格的要求，如果出现判断错误，很有可能导致交易事故。
在保证风控准确性的同时，还需考虑处理耗时，以避免对交易产生影响，错失交易机会。
3、事前风控指标
通常量化交易系统的风控模块需要进行两个类别的风控检查：
（1）交易所硬性指标，避免违反交易所监管要求。指标如：自成交风控、撤单数风控、单笔委托最大手数、各产品的最大撤单次数、
每秒最大报单笔数等。
（2）保障策略运行符合预期的风控指标，避免因程序的错误而造成巨额亏损。指标如：最大可用资金、最大持仓、最大报单数、最大报单频率、最大可亏损资金、单边最大持仓量、单边最大敞口量等。
4、事前风控实现
事前风控可以在客户的交易策略程序内设置参数实现，也可以通过交易柜台的风控模块实现。
不同的交易柜台，风控的处理耗时不同。对追求低延迟高频次的交易策略，无论是接收行情、风控判断、发送订单、或是接收成交回报都可以归结为信号。信号的价值随着时间的流逝而降低，所以信号出现后必须尽快地进行处理。信号的快速识别与处理对策略的成交率、收益率会产生很大的影响。
如果选择通过高性能的极速交易柜台来实现风控检查，事前风控并不会显著增加交易延时，即可以保障交易速度，也可以得到全方位的风控保护，并且可以对单个策略、单个合约进行差异化的风控设置，帮助客户对每个策略、每个合约进行更精确的风险控制。
对于柜台自带的风控指标，如不需要，也可在柜台端选择关闭。如果需在盘中修改风控参数，实时即可生效。
5、事前风控处理流程
柜台接收委托订单后，风控会根据预先设定的风控指标进行运算和判断，符合风控规则的订单才会进入交易模块，不符合则拒单，并且日志系统会留痕所有风控、委托、成交信息，便于事后风控分析。借用闪策柜台事前风控流程如下：

三、穿透式监管
2018年9月7日，中国证监会发布《关于进一步加强期货经营机构客户交易终端信息采集有关事项的公告》。
2019年11月20日，上海期货交易所发布关于落实穿透式监管相关要求的通知，要求各期货公司严格落实相关要求，并按照中国期货市场监控中心发布的《期货公司客户交易终端信息采集及接入认证技术规范》有关规定，做好中继代理软件管理和认证工作，对于符合监管规定的中继代理软件，开通准入权限。
穿透式监管是指监管部门可以看穿投资者的证券账户，清楚掌握每一个账户的情况。穿透式监管对于绝大部分投资者的正常交易影响很小，对于程序化、高频交易影响较大，看穿式重点监管频繁报撤、多账户和对敲等违反交易规则，扰乱市场的交易行为。
穿透式监管要求期货公司对投资者使用的交易终端软件进行认证管理，确保软件具备真实、准确、完整地采集和报送投资者交易终端信息的功能。可以实现由交易柜台加密采集终端信息，经由加密渠道报送至期货市场监控中心，监控中心基于收集到的大数据信息，建立信息分析和交易行为分析系统。




交易系统开发（四）——交易柜台系统

一、交易柜台简介
依据国内监管要求，客户无法直连交易所系统，中间必须经过经纪公司的柜台系统，由经纪公司柜台系统调用交易所API下单。
交易柜台是连接交易所的下单系统。通过经纪公司交易柜台把交易指令发送到交易所，然后经纪公司交易柜台再将交易所委托回报和成交回报反馈给投资者。
二、券商柜台
1、券商柜台简介
依据国内监管要求，客户无法直连交易所系统，中间必须经过证券公司（Broker）的系统，即柜台系统。证券公司会有多套柜台系统，在功能上分为集中交易柜台和快速交易柜台。
国内券商交易柜台厂商主要有恒生、金证、华锐、顶点、根网、金仕达、宽睿等公司，柜台系统功能模块根据付费多少而不同，也可以根据证券公司需求做开发，提供给投资者使用。普通交易柜台即集中交易柜台，主要是提供给一般投资者使用；针对机构客户等程序化交易客户，经纪公司同时提供了快速交易柜台。
主流券商系统（金证、恒生、金仕达）大致分为报盘系统、接口数据库、柜台系统三部分，程序化交易的接口通常是柜台系统提供的券商私有接口API和券商接口API两种。
券商私有接口API是提供给第三方金融软件公司的，第三方软件公司可以通过券商私有接口API开发出行情软件或交易软件，供给个人投资者使用，比如通达信，同花顺等。
券商接口API是指券商把其接口进行封装后，直接供给个人程序化投资者使用。
报盘接口API，一般是不可能供给个人用户使用的，只可能由券商系统提供商和其第三方合作伙伴共同开发。
2、集中交易柜台
集中交易柜台是券商的核心系统，用于对接上交所、深交所的股票交易，属于场内市场。
普通交易从进行委托开始，委托会先从投资者所在地到券商总部，再从券商总部到集中交易柜台，然后从集中交易柜台到交易所检查是否合规，如果判断合规，则从交易所传递信息返回集中交易柜台—券商总部，然后再下单，假设投资者在深圳，抛开审核时间，还要经历从深圳到券商总部，再到交易所的物理时间。
集中交易柜台是按照满足券商经纪业务来设计的，主要业务功能如下：
（1）账户业务。为客户进行账户开户、销户、管理业务权限、处理与交易相关的适当性管理、合规报送等。
（2）资金业务。支持客户保证金三方存管制度。
（3）证券交易业务。处理投资者提交的各类交易指令，按照交易规则进行资金和证券的处理，并实现与交易所的委托和成交指令的对接。
（4）信用交易业务。2010年证监会推出融资融券业务试点，投资者可以通过向证券公司融资买入股票，也可以融券卖出股票，实现了杠杆交易。系统需要按照信用交易的业务规则处理各类交易指令。
（5）基金代销业务。投资者可以通过证券账户购买开放式基金产品，系统处理投资者的产品申购赎回指令，并实现与相应基金公司的指令交互和资金、份额结算。
（6）清算业务。负责与交易所、登记结算公司进行数据交互和业务核对，完成客户在交易所内产品的资金、股份清算和结算。
（7）查询业务。满足客户需要的各种交易流水、对账单、交割单等业务数据。
（8）理财产品销售。券商为扩大客户投资品种范围，自行提供的各类理财产品的销售。
（9）现金余额理财业务。可将客户投资账户上的现金余额自动申购为货币基金，提高客户的资金收益。
（10）其他管理职能。系统参数设置、客户账号安全、外围系统接入、异常交易监控等。
3、快速交易柜台
快速交易柜台主要是为程序化交易客户提供的快速交易通道，通常只提供基本的交易功能，力图实现低低延迟极速性能，因此主流快速交易柜台的股票现货交易和信用交易是分开的，因此需要分别进行接口开发。不同券商的快速交易柜台支持的交易功能有所不同，但委托申报、委托回执、交易回执、撤单申报是基本功能，同时上海主板、上海科创板、深圳主板、深圳中小板、深圳创业板、可转债、逆回购时需要支持的基本业务品种。
快速交易柜台在接到客户委托申报时会进行风控合规检查，只要过了风控就可以直接通过一条连接交易所的专线传递信息，无论是审核时间还是传输时间都得到了极大的缩短。
国内主要快速交易柜台系统包括华锐ATP快速交易柜台、恒生UFT快速交易柜台、恒生UST快速交易柜台、顶点HTS快速交易柜台、金证FGS快速交易柜台、宽睿OES快速交易柜台，华宝证券自研LTS交易柜台，中泰证券自研XTP交易柜台。
4、OTC柜台
OTC柜台交易用于发行场外产品，开展个性化业务，属于场外市场。
柜台交易市场又叫OTC（Over-The-Counter）市场、场外交易市场或店头市场，是和交易所市场相对的一个概念。柜台交易市场主要采取一对一协商交易或报价、做市的交易方式，可交易多样化、个性化的产品。
OTC柜台交易系统是一种基于权威第三方行情作为报价依据，为交易商及投资者提供高效、安全、稳定系统服务，完善的后台管理功能模块，多级专业防护，确保系统安全，确保价格机制的稳定性与准确性，完善智能风控系统，保证交易安全。
柜台交易业务指证券公司与特定交易对手方在集中交易场所之外进行的交易或为投资者在集中交易场所之外进行交易提供服务的行为。
证券公司柜台交易市场明确定位于私募市场，是证券公司发行、转让、交易私募产品的平台。柜台交易市场建设初期配合资产管理业务创新，以销售和转让证券公司理财产品、代销金融产品为主。
柜台交易客户以机构客户为主，各证券公司制定了相应的柜台交易适当性管理制度，根据不同产品制定了不同的投资者准入标准，并通过建立客户分类和产品风险评级制度，实现不同风险偏好的客户和不同风险级别的产品之间的匹配。
5、智能路由
智能路由（Smart Routers）是一种利用复杂的算法将大订单拆分成小订单发给不同交易所的技术。
下单时，智能订单路由（SOR）技术能够通过交易算法将大量订单拆分后，先指向暗池（Dark Pool）再指向交易所，为交易者提供最佳的订单执行机会。
由于不同经纪商的智能路由策略的存在，机构投资者的大单通常要发给多个交易所。但发往各个交易所的所需时间不同，轻微的延迟就给了具备技术手段的HFT探测其他市场参与者交易意图的机会。
三、期货柜台
1、期货柜台简介
依据国内监管要求，客户无法直连交易所系统，中间必须经过期货公司（Broker）的系统，即柜台系统。期货公司会有多套柜台系统，在功能上分为主席和次席系统。
2、主席柜台
主席柜台功能全面，支持出入金、盘后结算等，要求高吞吐量与高可靠性，一般客户都是在主席系统上交易。
CTP (Comprehensive Transaction Platform，综合交易平台)是上期所子公司上期技术开发的一套主席系统。
3、次席柜台
次席系统一般只用于下单及撤单，重点是低延迟穿透时间，一般面向对时延要求较高的程序化交易客户。次席柜台的资金划拨、结算等功能则交由主席柜台实现。
期货公司的极速交易系统是次席交易柜台，柜台内部穿透耗时峰值在百纳秒级，尤其适用于对延时要求严苛的交易团队。
4、API
在中国，任何柜台系统都必须调用交易所API才能下单。
期货柜台系统一般都会提供API给程序化客户接入柜台使用，同时柜台系统需要调用交易所的API将用户的交易订单传输给交易所。
股指期货实现程序化交易最简便的是CTP。CTP提供了全开放的API接口，所以不论是个人还是第三方软件公司，都可以基于其API接口进行程序化交易系统的开发，但交易席位仍然要通过期货经纪公司。只要投资者选择一家以CTP为主交易系统的期货公司，利用CTP全开放的API接口，就可以开发自己的程序化交易系统。如果投资者的交易思想属于高频交易，对速度要求很高，就要选择CTP交易系统运维优良的，最好提供服务器托管服务的期货经纪公司。
5、交易所前置机
期货交易柜台需要通过交易所前置系统与交易所主机连接，前置系统是柜台与交易所撮合系统之间的通讯中继。
交易所前置服务器不仅仅起到中间桥梁的作用，还要以通讯IP地址控制连入的终端，减少交易主机的网络负担的作用，以及对交易指令进行一部分的正确性检测处理。同时，还可以起到防火墙的功能，防止交易主机受到外界的攻击，确保交易主机的安全运行。
为缓解交易系统压力，提高期货公司交易速度，交易所会设置多个交易前置机均衡前置机的系统负载，期货公司可按照交易所发布的前置机IP优选配置规则进行配置。
6、极速交易柜台
在中国期货市场，任何交易系统都必须调用交易所API（应用程序编程接口）才能下单。而国内交易所只提供软件版本API，而软件API只能通过CPU调用。

极速交易柜台拥有独立服务器的客户交易系统，使用独立的交易通道，优点在于委托速度快、申报指令推送快、成交回报快。
集中交易系统中，客户下单后通过网上客户端软件，先集中到网上交易服务器，再由网上服务器转向券商交易系统服务器，然后再接到交易所接口，最后再到交易所；极速交易通道，下单后转到快速交易通道与交易所系统对接。
四、顶点HTS柜台
1、HTS简介
HTS（Hyper Trading System，超级速交易系统）是顶点公司在交易功能进行专项突破和全面升级，基于自主知识产权的新一代内存数据库HyperDB、采用全新的架构、通讯服务和业务流程的新一代快速交易柜台系统。

HTS快速交易柜台系统性能能满足未来3至5年的发展需求，其中纯委托单笔处理耗时速度提升近5倍；委托时延压缩90%+， 全流程用时压缩3/4 ；极速下单，触发式回转，整体流程的提速对程序化、量化、算法、高频交易及跨市场套利体验提升明显。
相比QTS快速交易柜台系统有了数量级的提升，基于普通x86刀片服务器全链路，处理时间达到微秒级，做到了全业务、实战快、易运维！
2、HTS架构
HTS快速交易系统由配置数据库、配置管理及目录服务、交易节点三个模块组成，在系统设计上，交易节点允许分布式独立部署，每个交易节点均可自由指定服务的客户范围，逻辑结构如下图：

配置数据库是快速交易系统保存系统运行基础参数、运维平台用户及权限管理、客户交易节点等基本参数管理的管理、查询等服务。
配置管理服务，主要提供快速交易系统配置参数管理、维护、查询等功能服务。
3、交易节点架构
交易节点具体逻辑结构如下图

交易节点主要由内存数据库、快速交易应用服务和交易节点申报回报服务组成，为固定的客户群体提供证券交易服务。
4、特点
快速交易柜台系统采用面向服务的体系架构（SOA），特点如下：
（1）采用模块化堆叠的技术，采用独立部署模式，与原有业务系统实现"松耦合"；
（2）实现清晰的层次划分和明确的接口定义； 
（3）具备良好的稳定性、高可靠性、兼容性、可扩展性和先进性。
 在安全设计上，快速交易系统涉及到核心的机密数据，系统的保密性和抗攻击性是系统性能重要指标之一。
在容灾设计上，快速交易的内存数据库日志主从备份模式，是通过在快速交易主系统中部署内存数据库数据备份服务进程来监控内存数据库日志生成及存盘动作，并将内存数据库日志通过TCP实时同步至备份服务器上来实现内存数据库日志的实时备份。
5、功能
快速交易系统的核心逻辑是快速交易系统启动后倒入相应的客户数据，包括客户的账户信息、资金可用余额信息；然后从集中交易系统中冻结客户的可用资金，并反向在快速交易系统中解冻；最后进行日间的交易处理，其核心的功能包括：
A、客户实时资金查询、实时股份查询；
B、委托订单受理；
C、委托申报；
D、委托申报确认；
E、委托实时成交处理；
F、盘中客户资金存取管理；
G、盘中客户股份调账管理。
6、招商证券HTS快速交易柜台
招商证券在开展对冲基金服务过程中，通过利用快速交易平台满足程序化交易、算法交易等高端客户的需求。顶点公司成为招商证券快速交易系统供应商，HTS成为招商证券承建含个股期权、股票交易、基金交易、债券交易等全品种的快速交易系统。
个股期权快速交易节点由配置数据库、配置管理及目录服务、交易节点三个模块组成，在系统设计上，交易节点允许分布式独立部署，每个交易节点均可自由指定服务的客户范围。





交易系统开发（五）——华锐柜台简介

一、华锐平台简介
1、华锐平台简介
当前机构业务崛起、券商财富管理转型如火如荼，华锐金融技术提供了集成统一接入网关、机构交易系统、实时风控平台、高速行情、交易总线、开发测试云服务等功能，从规划到落地，从设计到实施，从软件到服务，从硬件到链路的机构交易风控整体交付解决方案。
华锐机构交易风控整体解决方案如下：

2、低延迟
竞价交易的本质是价格优先、时间优先的竞争性交易。交易员的委托申报能否顺利达成，除了委托价格外，报盘时延是最大的影响因素，也是从投资者角度评判券商交易系统能力的第一要素。
投资者可感知的交易时延，由券商交易系统处理时延和交易所处理时延两部分组成，交易所时延对全市场投资者是一样的，券商端时延就起了决定作用。券商端时延分为上行时延和下行时延，上行时延指委托从进入券商交易系统起，到离开报盘服务报送给交易所网关的时延，上行时延是决定委托能否尽快送达交易所的关键。
ATP极速部署方案的上行时延可低至30微秒以内，是名副其实的超低时延极速交易系统，并且时延稳定可预期，不会因为委托压力变化而剧烈波动。

3、高并发
机构投资者自动化交易程度高，瞬时并发委托量高，每日总委托量巨大，对交易系统的吞吐能力和委托容量都有极高的要求。
券商交易系统吞吐能力通常用委托TPS来表达，即每秒处理的委托数。时延指标必须与TPS指标结合才有意义，即谈时延时一定要明确在什么委托压力下保证，而谈委托TPS时也一定要明确是在什么时延水平下达成。由于交易并发的必然存在，只申报一笔委托录得的时延现实意义不大，应当在不同的并发压力下评测其时延指标。而由于交易的竞争本质，不能保证时延水平的吞吐量也毫无意义，仅能表示系统没有宕机，但服务质量已经不合格。
华锐ATP极速版单交易节点实测数据：
3000笔/秒的委托压力，平均上行时延<45微秒，回路时延<70微秒。
8000笔/秒的委托压力，平均上行时延<100微秒，回路时延<200微秒。

  
4、水平扩展
作为分布式交易系统，ATP具备容量水平扩展的能力，8000笔/秒只是一个交易节点的最佳性价比容量，并不是华锐ATP容量的极限。
 需要更大的容量时，每1台PC服务器即可增加1个交易节点，获得相应的容量增加，且性能水平不下降。通过扩容，整个系统可以在超低时延水平上支持超过10万笔/秒的委托请求，并且完全不需要修改应用软件，仅通过运维配置即可实现。

5、部署灵活
地理距离远近对投资者交易速度有非常重大影响，甚至动辄引入额外几十毫秒的时延，对于第三方接入场景下影响尤为严重。
ATP支持灵活的双节点双就近的高可用部署，可在上海和深圳分别部署一个高可用交易节点。同一投资者下的两个证券账户，可两地就近报盘，满足上海深圳都追求报盘极致速度的场景。
ATP虽然支持多个交易节点部署，但隶属于同一套交易系统，可以统一监控、统一管理、统一运维。

6、交易通道管理
交易通道是重要的资源，ATP具备多交易节点多通道模式，支持对交易通道资源精打细算、灵活配置的管理需求。
通道独享模式，可给各交易引擎配置独占的交易通道，独享资源，各交易通道之间互不影响。

由于交易所报盘网关对流速的限制，单独的交易通道也不一定能满足并发委托的要求，ATP也支持同一交易引擎连接多交易通道的能力，轻松实现通道扩容。

通过这些灵活配置的模式，券商可以自主选择为投资者提供哪种服务模式，既可以多个投资者共用一条交易通道，也可以单个投资者独占一条通道，可以多个投资者共用多个交易通道，也可以单个投资者使用多个交易通道，非常的灵活便利。
7、实时风控ARC
 机构业务对风控高度重视，ARC（ArchForce Risk Control，华锐实时风控平台）是为机构交易业务量身打造的实时风控产品，尤其适合用于为三方接入等业务场景构建实时风控和全局风控能力，可以帮助证券公司快速建立符合三方接入风控要求的全方位、全流程的实时风控能力，全面满足证券公司对机构交易的合规监控和风险管理要求。

ARC基于分布式平台构建，采用并行计算技术，配备微秒级实时风控引擎，满足交易速度要求，适配机构交易实时风控实时海量计算需要，日计算量可达百亿次，确保在风险发生的第一时间点时识别和发现。
ARC紧跟监管要求设计智能监控模型，从监管规则、处罚案例、监管函件出发，基于大量交易行为数据进行分析、重演、计算、建模，力求规则模型精准有效。ARC能够为券商提供一体化闭环式机构交易风险管理，通过完备的流程设计、功能设计，为系统用户提供一站式服务，用户无需多个系统不断切换。

8、统一接入网关
为了满足第三方交易信息系统统一接入、统一风控的要求，华锐基于ATH（ArchForce Trading Highway ，华锐高速交易总线）推出统一接入网关，实现数据通信、协议适配、接入控制和成交推送等功能。
华锐统一接入网关秉承开放兼容理念，既提供标准API接入，又兼容现有FIX、KCXP/KCBP、AR/AS/T2等常用协议，支持券商PB系统、量化交易系统等各种系统直接接入，支持讯投、通达信等主流交易客户端，可快速便捷的满足第三方系统的接入，最大程度保护投资者和券商的现有投资。
华锐统一接入网关还提供了多种身份认证、流量控制的安全手段，支持对每个用户的单个连接或者总连接进行流量控制，支持针对用户委托、撤单、查询等操作分别进行流量控制，完全满足《暂行规定》中对客户、系统的验证要求。
统一接入网关设计为多活模式，接口协议及API提供回报数据的断点对齐机制，支持故障切换及自动重连功能。同时统一接入网关可以实现按照资金账号分组，从而实现系统容量的水平扩展。
9、高速行情
行情服务是券商为机构客户提供的重要服务内容。作为交易信号触发者，行情速度决定了交易速度，行情数据服务质量是机构业务服务质量的重要衡量标准。
AMD是华锐新一代企业级行情服务平台，聚焦于实时行情分发及行情数据加工，为金融机构提供微秒级的行情分发和增强行情服务。可用于数据中心内分发、跨数据中心分发、远程终端用户等各种场景。

AMD具备级联分发、优先转发、实时监控等多项功能特性，能够同时提供流式行情、文件行情等不同市场、不同类型行情数据的分发服务，而且可以根据使用环境为用户提供时延优先或带宽优先的不同分发策略，从而为用户不同级别的数据中心、IDC机房以及各级营业部提供快速、稳定的原始行情分发服务。
AMD提供丰富的数据接口，既可以提供各个交易所原始格式的行情数据，也可以多种API形式推送行情数据。除了提供原始行情数据，AMD具备极好的可扩展性，按需模块化地扩展行情深加工的组件，提供历史行情数据的查询和重放服务，生成K线行情、分时行情、分笔行情等更丰富的数据形式。通过对逐笔委托和逐笔成交行情的推演，AMD可以模拟重建交易所的委托簿状态，为机构投资者提供更多的参考信息。
AMD凭借极强的灵活性、极低的切换成本、充分的可扩展性可以满足不同市场参与者对行情数据的需求。
10、ATH交易总线
为了更好的服务机构客户，交易数据应当能够被实时采集和共享，以便于开发更多机构服务能力。
ATH聚焦证券公司的交易数据传输，实现不同终端系统的统一接入，支持后台与交易数据相关的服务集成。
ATH可对接多种数据源采集数据，支持多维度的数据订阅，为终端系统提供高效、快速的交易数据分发和推送服务。凭借优异的性能和水平扩展能力，减少数据源访问压力，保障核心系统安全稳定运行。
ATH基于AMI及框架结构，支持灵活的业务扩展，提升证券公司自主开发能力，用户可根据自身业务需要进行定制开发。

11、开发测试云环境
《证券公司交易信息系统外部接入管理暂行规定》第十三条要求“证券公司向投资者提供交易信息系统外部接入服务前，应当建立与生产环境一致的仿真测试环境”。第三方交易信息系统接入正式上线前，证券公司需要对接入系统进行验证，确保其能够稳定运行，验证程序化交易、算法交易符合预期，并对异常情况进行模拟测试，严控业务和操作风险。但按照要求建立与生产系统一致的仿真环境本身就是一件非常复杂的工作，用户管理、应用部署、测试验证、交易仿真等工作量巨大，硬件投资也是一笔不小的开支。
华锐联合行业云机构，为券商和投资者提供了开发测试云资源申请、部署升级、运行管理、技术支持、测试管理的一站式服务，为第三方接入提供完备的云测试环境，并且对接了交易所等仿真测试环境，配备测试行情、模拟撮合、自动化测试等工具链，大大减轻了券商的负担，是一个专业、完备的全业务模拟测试平台。
二、华锐ATP柜台
1、ATP简介
ATP（ArchForce Trading Platform，华锐核心交易平台）聚焦交易所场内标准业务，连接订单管理系统和交易所交易系统，业务范围覆盖所有场内交易品种，提供交易订单生成、前端风控检查、报盘等功能，及交易管理、运营和清算功能。
ATP产品遵循分层、抽象、解耦、隔离的业务设计理念，实现了公共技术服务框架和可配置的交易业务框架，业务特性封装为独立的业务包，实现了“可组装”式的业务配置，有效隔离业务间相互影响，可根据需要自选组装和分批上线，业务调整时影响范围可有效控制。
ATP产品具有可伸缩弹性架构，可按照场景灵活应用于构建普通投资者使用的大型集中交易系统、面向专业投资者使用的机构交易系统和面向追求极致性能场景的极速交易系统。

2、特点
高可用：所有组件高可用，全系统无单点故障风险；多活集群，发生故障时秒级自动切换，无须人工干预；支持异地容灾，可实现分钟级切换；消息和业务数据全部实现持久化。
高性能：在50万笔/秒超高吞吐下，核心交易处理时延低至3微秒；
支持多交易节点部署，实现各交易所就近报盘。
水平扩展：通过增加服务器实现线性扩容，可容纳超过1亿证券账户；
扩容对应用透明，操作无风险；业务包按需组装，分批上线，业务变更风险小。

三、华锐AMD行情
1、AMD简介
程序化交易中，行情速度决定交易速度。
AMD（ArchForce Market Data，华锐高速行情平台）是企业级行情服务平台，基于新一代分布式架构技术，为金融机构提供微秒级的行情分发服务，聚焦于实时行情分发及行情数据加工。既支持同数据中心内的极速转码、极速原始分发，也支持跨数据中心部署，适应金融机构多场景应用。

2、AMD产品优势
稳定可靠：双活双源，双路合并，确保行情不中断；实时热备，全程无单点故障风险，故障自动切换；L2+L1行情降级备份，L2行情源异常时切换到L1行情。
低延迟：微秒级分发时延；双路合并选取最快行情。
无限拓展：行情总线可接入无限数量的行情用户节点；采用可靠组播技术，节省带宽，一点发出，多点同时送达；水平扩展+垂直级联。
3、AMD产品特点

多维度行情订阅：市场+数据类型（如快照、逐笔、公告等）、
证券集（预定义）、证券（动态定义）
增强行情服务：精确重演任一天历史行情；高速、准确、保序；提供委托簿重构等行情加工服务。
数据补全机制：自动补全模式；用户补全模式；混合补全模式。
开放接口：提供简洁易用的标准API接口
集中运维管理：集中监控；可视化运维；一键升级回退





交易系统开发（六）——HFT高频交易

一、高频交易简介
1、高频交易简介
高频交易（High Frequency Trading）是指从极为短暂的市场变化（市场的微观特性）中寻求获利的程序化交易，如某种证券买入价和卖出价差价的微小变化，或者某只股票在不同交易所之间的微小价差。
2、高频交易的特点
美国证券交易委员会SEC给出的高频交易的特点：
（1）使用超高速的复杂计算机系统下单。
（2）使用co-location和直连交易所的数据通道。
（3）平均每次持仓时间极短。
（4）大量发送和取消委托订单。
（5）收盘时基本保持平仓（不持仓过夜）。
HFT的速度优势是指当交易所完成一笔交易，在通知所有交易者的时候，HFT因为在通信线路的上游，所以会比别人先看到交易确认信息，可以根据自己对交易确认信息的理解以及业务需求，增加或者撤掉自己的委托订单，但都是完全正常的交易操作，不存在任何恶意，并且由于交易确认信息是发送给所有人的，任何人都会对交易确认做出解读和反应，但只有在同一个时间粒度上工作的交易者之间才可能存在竞争。
3、高频交易的发展历史
1602年，阿姆斯特丹证券交易所成为世界上首个证券交易所。
17世纪，罗斯柴尔德家族使用信鸽传递消息，成功跨越国界在同一类证券价格上进行套利。
1983年，彭博（Bloomberg）获得美林证券公司（Merrill Lynch）3000万美元投资，建立了首个计算机系统，以向华尔街金融公司提供实时市场数据、金融运算和分析。
1998年，美国证券交易委员会（SEC）给予电子交易所授权，为执行速度是人工速度1000倍以上的高频交易（HFT）服务铺平了道路。
2000年，HFT交易执行已经达到数秒执行时间。
2000年，HFT在美国股票交易订单中所占比例不到10%。
2005年，HFT在美国股票交易中占35%的比例。
2010年，HFT交易执行速度已经下降到毫秒和微妙级别。
2010年，HFT在美国股票交易中占56%的比例。
2010年3月6日，价值41亿美元的电子交易引发了金融市场的闪电崩盘，道琼斯指数在单个交易日内狂跌1,000点，市值蒸发近1万亿美元。在市场走上恢复道路前，市场依然能出现5分钟暴跌600点的情况。SEC和美国商品期货交易委员会（CFTC）认为HFT公司应负主要责任。
2011年，纳米交易技术推出：一家名为Fixnetix的公司研发出微芯片，使得交易执行速度达到纳秒。
2012年，HFT交易速度达到纳秒级别。
2012年9月，初创公司Dataminr获得3000万美元投资后推出了全新服务，将社交媒体流量转变为可操作的交易信号，其所报道的商业新闻比传统新闻报道平均提前54分钟。
2012年，HFT在美国股票交易中达到约70%的比例。
2012年，很多IT公司开始在HFT技术上投资数百万美元。一个特别为HFT开发的电脑芯片使执行速度提高到74纳秒；而一个价值3亿美元、横跨大西洋的电缆线项目正在建设中，目的仅是为了将纽约和伦敦之间的交易时间减少6毫秒。
2012年8月1日，美国最大的HFT公司骑士资本（Knight Capital）因程序错误疯狂买入4亿股股票，导致巨亏4.6亿美元，次年被SEC罚款1200万美元。
2012年11月，美国联邦调查局（FBI）宣布开始将社交媒体作为证券诈骗的形式之一进行调查。
2013年4月2日，SEC和CFTC公布对上市公司通过社交媒体发布公告的限制。
2013年4月4日，彭博终端将实时Tweets整合进其经济数据服务。彭博社交速度（Social Velocit）开始追踪社交媒体上有关特定公司话题的异常情况。
2013年4月23日，美联社（Associate Press）的Twitter账号被黑后，于下午1:05发布了一条美国总统奥巴马在白宫炸弹袭击中受伤的假消息，瞬间引起华尔街的剧烈恐慌，道琼斯指数在3分钟内跳水143点。
2013年，一个坐落在纽约的服务器中心可以通过超快速微波传输服务，将数据光速传递到新泽西纳斯达克交易所。
2013年9月18日，美联储下午2时宣布暂时不会缩减对经济的支撑水平，消息震惊了金融市场。在芝加哥的部分交易者获得消息前的数毫秒内，已经约有6亿美元资产进行了转手交易。
2013年9月，意大利成为首个向HFT征税的国家，对维持时间少于0.5秒的股票交易征收0.02%的税。
2014年1月，美国高频交易公司Virtu Financial提交IPO申请，其在招股书中表示，2009年至2013年的1238各交易日，公司只有一天出现亏损，通过从每笔交易获取的微薄利润，公司每天可以获得130万到150万美元的净利润。
2014年2月，巴菲特为消除近来媒体报道旗下商业资讯供应商Bussiness Wire向高频交易公司提供收费服务可能引起的误解等负面影响，决定不允许高频交易公司获取Bussiness Wire提供的特许直接投送服务。
2014年4月，SEC、CFTC、FBI对高频交易展开调查，FBI审查交易者是否涉嫌利用未公开信息抢在机构投资者前交易。
2014年4月15日，欧洲议会通过包含一系列限制高频交易措施的《金融工具市场指令Ⅱ》，内容包括限制报价货币单位过小、强制对交易算法进行测试、要求做市商每个交易日每小时上报交易额，以及当价格波动超过一定限制时的熔断机制。
2016年6月，SEC批准IEX成为全国性股票交易所。IEX是美国首家对股票交易订单施加350微秒延迟的交易所。
2017年4月20日，高频交易公司Virtu宣布14亿美元收购骑士资本。
2018年5月，瑞士证券交易所SIX宣布将联合微波解决方案供应商12H将在欧洲推出微波交易网络。12H负责提供支持微波集哦呵波交易的技术，SIX负责管理接入微波交易网络的所有客户。SIX是世界上第一家经营和拥有欧洲欧洲微波交易网络的交易所，交易所的系统将连接苏黎世、伦敦、法兰克福、米兰。
2018年9月20日，美国商品期货交易委员会（CFTC）宣布对Geneva Trading公司（位于芝加哥的自营交易公司）处罚150万美元罚款，因公司员工进行幌骗（Spoof）交易。
2018年11月，莫斯科证券交易所宣布将向基金、算法、高频交易者提供更多分析工具。
2018年11月，澳大利亚证券投资委员会宣布，高频交易占澳大利亚股票市场交易的四分之一。
2019年3月，高频交易商Virtu宣布10亿美元收购ITG（Investment Technology Group）。
2019年11月7日，美国司法部和商品期货交易委员会（CFTC）宣布高频交易公司Tower Research Capital同意支付6749万美元了结关于其三名前交易员从事挂单欺诈的指控，罚款包括3259万美元赔偿金，1050万美元非法所得以及2440万美元民事罚款。挂单欺诈即国内频繁报撤单，在国际上称为幌骗（spoofing）的交易行为。在实际交易操作中，投机者可能利用高频交易进行频繁报单、撤单，制造幽灵流动性以吸引其它投资者上钩。
二、高频交易监管
1、高频交易监管
1998年，美国证券交易委员会（SEC）给予电子交易所授权，为执行速度是人工速度1000倍以上的高频交易（HFT）服务铺平了道路。
2010年7月，美国总统奥巴马签署多德-弗兰克（Dodd Frank）金融改革法案，正式把虚假盘列为违规的操控市场行为。
2012年10月，美国证券交易委员会(SEC)提出了一系列针对高频交易的监管方法。
2012年11月，美国联邦调查局（FBI）宣布开始将社交媒体作为证券诈骗的形式之一进行调查。
2013年5月，德国高频交易法案开始实施，是全球首部针对高频交易（含算法交易）的法案。
2014年4月，美国证监会（SEC）、美国商品期货交易委员会（CFTC）、美国联邦调查局（FBI）对高频交易展开调查，FBI审查交易者是否涉嫌利用未公开信息抢在机构投资者前交易。
2014年4月15日，欧洲议会通过包含一系列限制高频交易措施的《金融工具市场指令Ⅱ》，内容包括限制报价货币单位过小、强制对交易算法进行测试、要求做市商每个交易日每小时上报交易额，以及当价格波动超过一定限制时的熔断机制。
2015年11月，美国商品期货交易委员会推出新规，加强对高频交易员的监管力度。
2016年6月，美国证监会（SEC）批准IEX成为全国性股票交易所。IEX是美国首家对股票交易订单施加350微秒延迟的交易所。
2、高频交易监管处罚
2013年10月，美国证监会宣布，高频交易公司骑士资本因没有准备足够的安全措施以避免大量错误订单出现而违反市场准入规则（market access rule），被处以罚款1200万美元。骑士资本（Knight Capital）于2012年8月1日因程序错误疯狂买入4亿股股票，导致巨亏4.6亿美元。
2014年10月，美国证监会宣布认定Athena存在操纵市场行为，并处罚款100万美元。
2014年11月，美国商品期货交易委员会（CFTC）发布公告称，芝加哥投资公司3 Red Trading LLC及其交易员伊格尔·奥斯塔赫，涉嫌利用幌骗手段及欺诈性设备操纵市场，CFTC决定对其提起诉讼。
2015年4月，美国司法部指控英国高频交易员萨劳涉嫌以幌骗交易进行获利，造成美股2010年5月6日发生闪电崩盘。
2015年10月，中国公安部宣布对伊世顿国际贸易有限公司涉嫌操纵中国期货市场进行立案侦查，中国监管部门认为高频交易是导致2015年中国股票及期货市场坍塌的原因。
2015年11月，美国联邦法院裁定Panther Energy Trading公司的负责人米歇尔·科斯夏（Michael Coscia）的商品交易欺诈以及幌骗(spoofing)罪名成立。
2016年8月，中国证监会宣布对荷兰高频交易公司IMC的期货交易行为的审查。
2018年9月20日，美国商品期货交易委员会（CFTC）宣布对Geneva Trading公司（位于芝加哥的自营交易公司）处罚150万美元罚款，因公司员工进行幌骗（Spoof）交易。
2019年11月，美国司法部和商品期货交易委员会（CFTC）宣布高频交易公司Tower Research Capital同意支付6749万美元了结关于其三名前交易员从事挂单欺诈的指控，罚款包括3259万美元赔偿金，1050万美元非法所得以及2440万美元民事罚款。挂单欺诈即国内频繁报撤单，在国际上称为幌骗（spoofing）的交易行为。在实际交易操作中，投机者可能利用高频交易进行频繁报单、撤单，制造幽灵流动性以吸引其它投资者上钩。
三、高频交易策略
1、高频交易策略简介
西蒙斯的大奖章基金是华尔街对冲基金的一个神话，连续20年，平均每年盈利35%，如果考虑基金5%的管理费和40%的提成，其每年的收益率超过60%。收益率远远超过巴菲特和索罗斯。
西蒙斯的策略主要是利用强大的数学模型和计算机软件，在全球市场的不同产品中，进行高频交易，赚取微小的波动差，从而获取一个稳健持续的收益，属于市场中性策略，不太受牛市熊市的影响，只要有波动就能赚钱。西蒙斯的大奖章基金能在2008年金融危机全球市场暴跌的情况下获得80%的收益率。
高频交易策略主要有：流动性回扣交易（Liquidity Rebate Trading）、猎物算法交易（Predatory Algorithmic Trading）和自动做市商策略（Automated MarketMakers Trading）。
主流的高频交易策略对计算机和网络的性能要求极高，高频交易机构通常会将将自己的交易服务器安置到了离交易所计算机很近的地方，以缩短交易指令通过光缆以光速旅行的距离。
高频交易涉嫌市场公平问题，高频交易需要的设备和计算能力对中小投资者是一种不可逾越的门槛，利用高频交易获取收益的机构，可能造成市场的不公平。
在国内市场，股票市场是T+1，股指期货市场的持仓、交易频率都有很大的限制，商品期货市场可以做一些日内的短线交易，但离高频交易尚且有很大的距离。
2、做市策略
做市是指在市场上充当流动性提供者。做市商是所有人的对手盘，在任何人想买一个标的（比如股票，期货等），做市商要保证买方投资者能买到，在任何人想卖出一个标的，做市商要保证卖方投资者能卖出。
做市商策略本质上是均值回归，认为市场价格在短期内具有波动性，涨上去的价格会落下来，跌下去的价格回涨回来。做市商可以选择承担一定的风险，暂时从卖方投资者手里把股票买过来，过一段时间价格变得有利时再卖掉。由于不能保证价格一定会向着做市商有利的方向变化，因此做市商存在亏损的风险，时间跨度越大，风险也越大。做市商买过来的东西需要持有一定时间作为库存，来赚取因为波动性而产生的一点点价差。
noncontractual market maker（非合约做市商），是一种主动型做市商，通过投入大量资金聘请一流IT专家、金融专家，购买最先进的IT设备，开发高频交易算法和策略，打造极至性能的低延迟高频交易系统，但极少能赚钱。
contractual market maker（合约做市商），是一种被动型做市商，没把握一直赚钱，但交易所需要向市场提供流动性，避免在市场对价格趋势判断一致时缺乏流动性，因此，交易所会引入做市商。合约做市商会和交易所签订一个合同，承诺提供多少流动性，交易所相应会给一些报酬和福利。因此，合约做市商即使赔点钱，但算上交易所的报酬，还是能盈利。合约做市商不是很需要预测市场走势的能力，只要能做到不赔钱就可以赚交易所的酬劳。要做到不赔钱，一是做好对冲，二是发现形势不利时要能及时撤单，因此对低延迟要求较高，速度慢就会发生来不及撤单而遭受损失的情况。
做市是比较主流的HFT业务，做市商是所有交易者的对手盘，使得大部分交易都是通过做市商的参与来完成的。
市价单（market order）是不保证成交价的，指令发给交易所，交易所根据当时的情况，算出是什么价就给什么价。如果想要确保价格，请使用限价单（limit order），保证成交价格，但不保证时间。
3、套利策略
套利是指找到两种强相关性的证券，如ETF和组成ETF的股票。可以根据股票的价格使用ETF计算方式计算一个ETF的期望价格。如果计算得到的ETF期望价格和市场上ETF价格不一样，显然是市场发生了一些混乱，ETF的市场价格会回归到ETF预期价格附近。此时，投资者可以买入（卖出）ETF，卖出（买入）股票，坐等价格回归，可以稳赚不赔。
套利策略竞争非常激烈，任何人都可以参与，参与人多了市场就会少犯错误，同时套利者的利润空间也会变小。当套利赚取的净利润不足以支撑HFT的研发维护成本的时候，HFT公司就会关门。
为了减小对市场价格的冲击影响，投资者的算法交易系统一般对大额买单进行两阶段处理：首先将其分解为几十个甚至几百个小买单（一个小买单通常在100～500股之间），然后将小买单按某种设定的顺序投放到市场。
4、流动性回扣交易
为了争取更多的交易订单，美国所有的证券交易所都会为创造流动性的券商提供一定的交易费用回扣，通常为0.25美分/股。不论买单还是卖单，只要交易成功，交易所即向该流动性的原始提供券商支付回扣，同时向利用流动性进行交易的券商征收更高的费用。随着交易回扣激励机制的日益普及，诞生了越来越多的以专门获取交易回扣为赢利目的的交易策略。
假设机构投资者的心理成交价格在30～30.05 美元之间。如果交易系统中的第一个买单（如100 股）配对成功，以30美元价格成交。交易系统中第二个买单（如500 股）便跳显出来。再假设该买单也配对成功，以30美元价格成交。根据上述交易信息，专门从事流动性回扣策略的高频交易者的计算机系统即可能察觉到机构投资者其它后续30美元买单的存在，于是，回扣交易商计算机采取行动，报出价格为30.01美元的买单100股。此时，曾以30美元出售股票的券商更愿意以30.01美元的价格出售给回扣交易商。
在交易成功之后，回扣交易商立刻调整交易方向，将刚刚以30.01 美元购得的100股股票以相同价格，即30.01美元挂单卖出。由于30美元股价已不复存在，故卖单很可能被机构投资者接受。尽管回扣交易商在整个交易过程中没有赢利，但由于第二个主动卖单给市场提供了流动性，从而获得了交易所提供的每股0.25美分的回扣佣金。回扣交易商所获得的每股0.25美分的盈利是以机构投资者多付出的1.0美分为代价的。
5、猎物算法交易
在美国，超过一半的机构投资者的算法报单遵循SEC国家最佳竞价原则（National Best Bid or Offer，NBBO）。所谓NBBO，即当客户买入证券时，券商必须保证给予市场现有的最佳卖价；同样当客户卖出证券时，券商必须保证给予市场现有的最佳买价。根据NBBO原则，当一个报单由于价格更为优先从而在排序上超过另一个报单时，为了能够成交第二个报单，常常调整股价并与前者保证一致。事实上，一只股票的算法报单价格常常以极快的速度相互攀比追逐，从而使股票价格呈现出由高到低、由低到高的阶段性变动趋势。在实际交易中经常看到数量有限的100股或500股小额交易常常将股价推高或拉低十美分至几十美分的原因。
猎物算法交易策略即在对上述股价变动历史规律进行研究基础上而设计的。一般而言，猎物算法策略通过制造人为的价格来诱使机构投资者提高买入价格或降低卖出价格，从而锁定交易利润。
假设机构投资者遵循NBBO并且心理成交价格在30～30.05美元之间。猎物算法交易商用程序和技术来寻找其他投资者潜在的连续算法订单。在计算机确认价格为30美元的算法报单的存在后，猎物算法交易程序即发起攻击：报出价格为30.01美元的买单，从而迫使机构投资者迅速将后续买单价格调高至30.01美元；然后猎物算法交易商进一步将价格推高至30.02美元，诱使机构投资者继续追逐。
以此类推，猎物算法交易商在瞬间将价格推至机构投资者所能接受的价格上限30.05美元，并在此价格将股票卖给机构投资者。猎物算法交易商知道30.05美元的人为价格一般难以维持，从而在价格降低时进行补仓赚取利润。
Pinging试单指的是以小额的(通常是一两百股)、不断提价的(例如每次增加一分钱)、不能立即成交便立即撤销的订单(Immediate-or-Cancel Order，简称IOC订单)的策略，以便窥探到暗池或交易所的大额隐藏订单。在HFT中，Pinging试单被用来寻找隐藏的猎物。
为了发现大订单的存在，高频交易公司对每只上市股票进行100股的出价和报价。
一旦高频交易者发现存在大单，就抢先交易，扫单后（即吃掉已有的流动性）再以稍差后的价格（更高或更低的价格）提供新的流动性，向机构投资者反向买卖，从中牟利。
6、自动做市商策略
做市商的主要功能是为交易所提供交易流动性。自动做市商高频交易者通过向市场提供买卖订单来提高流动性，通常与投资者进行反向操作。自动做市商高频交易者的高频交易系统具有通过发出超级快速订单来发现其它投资者投资意向的能力，如以极快速度发出一个买单或卖单后，如果没有被迅速成交，将订单马上取消；然而如果成交，系统即捕捉到大量潜在、隐藏订单存在的信息。
假设机构投资者向其算法交易系统发出价格在30.01～30.03美元之间的系列买单。为了发现潜在订单的存在，自动做市商高频交易者的高速计算机系统开始以30.05美元的价格发出一个100股的卖单。由于价格高于投资者价格上限，因此没能引起任何反应，于是该卖单被迅速撤销。计算机又以30.04美元的价格再次探试，结果还是没能引起任何反应，于是卖单也被迅速撤销。计算机再以30.03美元的价格继续探试，结果交易成功。因此，计算机系统立即意识到一定数量价格上限为30.03美元的隐藏买单的存在。于是，运算功能强大的计算机系统随即发出30.01美元的买单，并利用其技术优势赶在机构投资者前进行成交，然后再以30.03美元的价格反卖给机构投资者。
四、高频交易基础设施
1、高频交易基础设施简介
高频交易系统端到端时延主要由网络设备转发时延、网络连线的传输时延、网卡数据收发时延、操作系统处理时延、中间件处理时延及业务处理时延等构成。为了追求极致的低延迟，需要在各个环节降低时延损耗。
2、金融专网
（1）光纤通信
光纤通信中光信号在光纤线缆中并不是直线前进而是不断折角反射前进，并且受限于光缆内部的玻璃介质，光信号实际传输度大约只有20万千米/秒；光纤铺设受限于山川河流海洋等地形的限制，使得光纤传输距离大于两地实际距离。但光纤网络的带宽比较大，仍然是长距离高速网络连接的首选。
高频交易公司通常会选择暗光纤（已经铺设但是没有投入使用的光缆），对于优质的暗光纤服务（无需与其他客户共享的连接），全球最流行的芝加哥——纽约路线在传输容量充足的情况下，标准的往返延迟是16毫秒。
2010年，美国高速网络供应商Spread Networks曾经耗资3亿美元修建了一条纽约和芝加哥两地间最直的一条光缆，为了让光缆不用绕道，挖通了横穿阿巴拉契亚山脉的光缆隧道，网络连接往返速度只需13.33毫秒比其它网络少了3毫秒。
2013年，北极海底光缆开始利用破冰队伍和特制极地冰山电缆铺设船进行铺设，耗资15亿美元。北极海底光缆共三条，其中两条名为Artic Fibre和Arctic Link的光缆将跨过加拿大北极群岛的西北通道；第三条俄罗斯跨北极海底光缆（ROTACS）将会围绕北欧北部的纳维亚半岛和俄罗斯进行铺设。通过北极海底光缆，全球两大金融交易中心英国伦敦和日本东京将几乎得以直连，距离节省近8000公里，两地间的数据传输时间也从大约0.23秒减少至0.17秒。
2018年12月7日，中国联通宣布中国联通(欧洲)运营有限公司法国分公司在法国巴黎正式开业。法国公司是中国联通在境外设立的第32个分支机构。中国联通针对法国及欧洲金融客户推出了升级版的终端安全防护方案和低时延金融专网解决方案，将中国联通骨干网络巴黎到香港的信息传送时延缩短到近160毫秒。
（2）微波通信
微波通信的传输速度约为30万千米/秒，通过建微波信号塔、用中继的方式（通常建在山顶或者高建筑物的顶端），将传输距离尽可能缩短。微波通信比光纤的延迟要低一个数量级，低延迟敏感的应用一定要选择微波线路；但微波通信的传输速度易受糟糕天气影响，刮风下雨都会导致通信受损，甚至会直接故障，因此需要有备用光纤线路；微波通信的带宽较小，如果是跨交易所的业务，不可能通过微波通信转移市场数据，只能用来收发下单指令，因此网络服务商有一定空间做一点数据压缩和抽样，可以在微波线路上提供一个微缩版的市场数据。
光纤、海底光缆通信方式适合承载大量数据的交易，比如上市公司发布数兆大小的财报文件。
2014年，高频交易公司Jump Trading在全球最大期货交易所芝加哥商品交易所（CME）数据中心对面，买了一块12万平方米的空地架设微波通信基站，用于第一时间把交易请求传到CME。
2018年5月，瑞士证券交易所SIX宣布将联合微波解决方案供应商12H将在欧洲推出微波交易网络。12H负责提供支持微波集哦呵波交易的技术，SIX负责管理接入微波交易网络的所有客户。SIX是世界上第一家经营和拥有欧洲欧洲微波交易网络的交易所，交易所的系统将连接苏黎世、伦敦、法兰克福、米兰。
（3）激光通信
激光通信兼顾光纤通信和微波通信的优点，激光通信的传输速度约为30万千米/秒，能够提供2Gbps 带宽，是微波通信网络的数百倍并且红外激光基本不受天气影响，在雨天和大雾中能正常传输数据。但激光通信中激光只能够直线传输，容易发生传输偏差，因此需要将激光发射器装在高楼楼顶才能增加传输距离，但高层建筑会在风的影响下小幅度来回摆动，难度在于如何在信号传输过程中让激光射入锅盖大小的接收板，并且在整个传输过程中保持如此。
Anova公司在位于纽约曼哈顿（纽交所）和新泽西Carteret（纳斯达克交易所）之间的楼宇顶上安装有激光通信网络的基站，能将发丝粗细的红外激光射到10千米以外的地方，由于两大交易所数据中心之间的直线距离大约是55千米，Anova将在中途修建6 至7个激光基站，为交易数据建立一条最直接的通道，以取代光纤和微波无线网络。
3、交易所机房托管
为了追求更低延迟，高频交易公司通常会把服务器放到交易所撮合引擎服务器所在的数据中心里（co-location）。
交易所数据中心会确保使用Co-location的客户无论将机器托管在交易所内的任何位置，都是通过相同长度的电缆传输、相同的延迟时间。
国内交易所都有自己的服务器托管中心，如上交所外高桥上证通托管机房、深交所南方中心深圳通托管机房、上交所金桥托管机房。只有证券、期货公司可以向交易所租用托管机房机柜。证券、期货公司通过提供机柜、购买设备、购买或租用软件为其客户提供服务。高端程序化交易团队通常自购设备或指定硬件配置由证券、期货公司采购，经证券、期货公司同意，放到租用的机柜内进行交易。
HFT公司或自营交易团队可向证券公司或期货公司申请机柜和网络资源，将交易主机与交易所的交易主机在物理距离上尽可能近地放置在一起。
交易所提供的托管机房受制于场地及电力所限，一般资源容量有限，常常供不应求。
4、网络接入
交易所co-location服务一般提供的网络连接是1G、10G以太网和40G以太网连接。通常，更高的带宽对延迟会有直接的影响，特别是在交易环境中容易出现单个消息相对大、消息速率相对高、网络有拥塞和突发流量等情况下，高带宽能够保证系统的延迟低而且稳定。对于co-location用户，40G的网络连接相对于10G的网络连接，能使往返延迟（roundtrip latency）减少7微秒，对于高频交易是相当可观的。
高带宽不但能带来更低的延迟，而且还能保证延迟的稳定性。高带宽能够保证在有大量数据需要传输的时候，数据等待传输到网线的时间更短，因为单位时间能够被传输的比特数更多，保证了即使在网络有突发流量的情况下，也能获得尽量低的延迟。对于高频交易，数据最高的时候往往也是市场动荡最多的时候，也正是交易盈利机会最多的时候。
5、网络设备
网络设备的性能会对高频交易系统的整体延迟产生直接影响，网络设备主要包括路由器、交换机以及服务器上的I/O接口卡或网卡，而通常对高频交易系统延迟产生较直接影响的是交换机和网卡。
（1）交换机
目前比较常规的10G以太网交换机，比如Dell，Juniper， Cisco等公司的交换机产品，能提供的端口到端口延迟约为700纳秒；专注低延迟的交换机产品，如Arista 和Mellanox公司的交换机，可以提供低于500纳秒的延迟，其中Mellanox号称能提供250纳秒的延迟；对极端的应用场景，存在更低延迟的交换机产品，比如Zeptonics公司的交换机能支持到130纳秒的延迟性能，其一层交换机（Layer 1 switch）甚至做到5纳秒的延迟，但只能支持某些特定应用场景，如基于交易网络端口和端口之间的通讯不多。
高频交易系统不需要复杂的交换功能，主要以通过一个特定端口连到交易所的通讯为主，因此，支持低延迟交换机。
（2）网卡
服务器网卡对于系统的延迟性能也非常重要，目前一些比较高端的1G和10G以太网卡集成了TOE（TCP Offload Enigne）技术，由于在网络中的数据到达服务器后，服务器端的操作系统（OS）需要对数据进行TCP/IP协议解析，数据解析过程不仅耗时，而且会占用大量的主机CPU资源（处理1Gbps的TCP/IP协议数据需要占用大约1GHz的CPU），在网卡上支持协议解析后，一方面可以利用特定硬件的处理能力获得更低的延迟，另一方面可以节省CPU资源用于处理运行于主机上的高频交易程序。高端的网络接口卡通常能够支持RoCE，FCoE等技术，公司包括Solarflare, Mellanox, Chelsio等。
专用网卡除了自身硬件的设计外，需要切换掉系统自带的kernel space TCP/IP stack，避免昂贵的context switching。
FPGA（ield Programmable Gate Array，现场可编程门阵列）是一种硬件可重构的体系结构，FPGA同时拥有流水线并行和数据并行，具有比CPU和GPU更低的延迟和更高的吞吐量，因此可以使用FPGA做专用网络设备以及一些额外的逻辑处理，进一步解放CPU。
除了以太网，另外一种网络结构InfiniBand以其更高速，更低延迟的特性也在交易系统中越来越流行。更高速和更低延迟并不是绝对的，而是在某些特定的应用中才能体现出来，取决于InfiniBand架构本身，比如，InfiniBand的帧是基于16bit的本地地址，而以太网是用48bit的全球唯一的物理地址，InfiniBand本质是一个I/O技术，而不是网络技术。InfiniBand的另一个优势是在可扩展性上，对于某些需要多个节点之间频繁进行消息传递的应用，比如超级计算中经常用到的消息传递接口（MPI）技术，InfiniBand相对于以太网能够提高整体的吞吐量，减少延迟，并且保证随节点增加系统整体处理能力的有效扩展。但InfiniBan缺点在于价格相对昂贵，需要特殊的硬件，与以太网设备存在兼容性问题等，而且目前为止也少有交易所提供InfiniBand的连接，所以InfiniBand网卡通常用在高频交易公司的内部网络。
目前，以太网也在引入一些InfiniBand支持的功能，如RDMA（远程直接内存访问）技术能够使集群中的节点之间通过网络设备对对方机器的内存进行直接访问，既减少延迟，也节省了节点上的CPU资源，而RoCE（RDMA over Converged Ethernet）技术实现了基于以太网的RDMA（远程直接内存访问），将InfiniBand拥有的低延迟也赋予了以太网。
目前InfiniBand与以太网技术比，在延迟和吞吐量上，还是有优势的。由于兼容性和成本的原因，许多公司采取混合模式，把最需要速度的部分网络用40G的Infiniband 或以太网，而其它部分网络用一般的10G。
6、高频交易系统
高频交易系统的设计和开发是一个非常复杂的工程，而且对于准确性和稳定性要求极高，不够精密就上线后会出现各种问题，根本无法使用。
高频交易系统的精髓在于把单机的软硬件系统的性能发挥到极致，而不强调高负载和延展性。
高频交易系统的核心业务逻辑处理的核心是延时。在计算机内部分两个部分，一是core的使用率，比如irq balance，cpuisol，affinity等，主要是要尽可能的独占core；另一个是cache invalidation，从L1/L2/L3cache到TLB，内存布局都要仔细考虑。
交易策略程序作为操作系统的用户程序存在。行情数据主要通过UDP与TCP两种方式进行网络传输。行情数据到达网卡后，通过PCI Express 或HyperPort接口，再传到操作系统的内核（OS Kernel）进行TCP/IP 协议栈解析，再把解析后的数据内容通过socket 接口，推送到用户程序即策略中。然后用户程序再对数据按照规定的格式进行解析，然后应用在策略逻辑中，进行分析，下单等动作。
整个过程的处理时间数量级在两位数微秒左右。在整个行情数据内部传递与解析的过程中，能够优化的主要是TCP/IP协议栈的解析和业务数据的解析。由于策略逻辑的多样性，对策略逻辑的普遍加速的可能性不大。TCP/IP协议栈的解析（TOE，TCP/IP offload engine）和业务数据的解析主要由专用的网卡来做。目前有两种方法来实现，一种是在网卡附带的CPU上进行处理（IBM有一款网卡附带CELL芯片，功能很强大）；另一种是网卡+FPGA的形式，用FPGA（现场可编辑门阵列）来做TCP/IP的解析和业务数据的解析。FPGA因为全部是硬件，速度会更快些。通过硬件加速的方法，可以达到个位数微秒（us）的延迟，并且能够做到无论在数据多少都达到固定的性能。
五、主流高频交易系统
1、盛立系统
盛立极速柜台系统（REM）的交易和行情都使用FPGA硬件加速，EFH行情系统、多核硬件技术铸造的纳秒级行情转发服务设备，全面满足高频交易客户的tick-to-trade 0延迟的需要。REM柜台系统特点：
（1）订单管理和风险控制0延迟
（2）个位数微妙性能抖动。
（3）资金风控、流量控制并行处理。
（4）可视化实时风险监控。

2、艾克朗克
行情加速系统Xele-MD是业内领先的基于FPGA的亚微秒级行情加速系统。
独创的FPGA数据传输系统拥有纳秒级响应速度，可提供最快速最准确的资讯通道，是为投资证券、期货的高端人士以及基金类投资机构，产业巨头量身打造的高性能极速交易系统的重要环节。
Xele-Trade系统采用国际顶尖技术，基于高速可编程硬件设备，为证券、期货、期权、外汇提供软硬件加速。

3、CTPII mini
CTPII mini是上海期货交易所采用最新技术架构开发的系统，相较CTP mini系统得到了更大程度的精简，将所有核心部件合并为Tserver一个组件，取消不必要的API。保留了对应不同交易所的交易报盘和行情报盘，同时将郑商所和大商所的交易报盘和行情报盘更新为最新的Linux组件，大大提高交易效率。
4、飞马
飞马柜台系统由交易系统、行情系统和会员端组成，符合当前看穿式监管要求，支持国内四大期货交易所和能源中心的全部期货、期权业务，具有较低的系统时延、订单处理性能优越。
5、量投QDP
量投极速柜台交易系统（QDP）通过内核开发与硬件精准调优，实现微妙级别延迟的交易行情，国内四大期货交易所和能源中心的接入许可，内置逐笔合规检查和流控技术，统一的API接口。

6、易盛mini
易盛mini柜台是异构双核交易系统架构，普通版大容量内核保证系统的超大容量和超高稳定性，而极限版高速内核提供目前国内交易系统中最快的极限交易速度，超低的数据延迟，全面支持国内四家交易所和能源中心的期货期权业务。
tapextreme系统是基于易盛启明星系统的子系统，目的在于简化系统架构，优化处理逻辑，通过降低模块间通信延时而开发的一套子系统。基础数据来源于启明星系统导出的离线文件、交易所提供的查询接口。





交易系统开发（七）——交易延迟分析

一、交易延迟简介
1、交易延迟简介
交易延迟高最常用的指标是往返延时（Round Trip Time），即交易订单从客户策略服务器发至经纪公司交易柜台，交易柜台内部处理后发往交易所，交易所确认报单后发送回报给交易柜台，再从柜台发送至客户策略机的一来一回整体链路的耗时。

2、交易策略服务器至交易柜台延迟
客户策略服务器至经纪公司交易柜台的延时指订单从客户策略服务器网卡发出，至经纪公司柜台服务器网卡收到之间的延时。
本阶段延时主要耗时在硬件上，受服务器、网卡及交换机的性能优劣影响较大。
策略服务器一般由客户自行采购或由客户指定配置由券商采购，柜台服务器一般由经纪公司提供，高频交易服务器一般托管在机房，布线一般由经纪公司网络工程师完成，本段延迟主要由经纪公司和客户共同决定。
3、交易柜台内部延迟
交易柜台内部延迟指交易柜台网卡收到策略客户端发出的委托订单，经过前置、风控、订单、报盘等模块管理后，再调用交易所API从网卡发出所需要的耗时。
本段延时由经纪公司柜台系统，系统服务器、网卡及交易所API三部分决定。
第一部分即经纪公司柜台系统，高频交易柜台系统由专业柜台厂商提供。交易柜台系统一般有交易前置模块（提供监听及客户链接管理功能）、风控模块（对客户订单的风控管理）、订单管理模块（管理客户订单）、报盘模块（管理与交易所交易前置的链接）。
前置模块的连接处理速度，风控的逻辑计算速度，订单管理内存数据库的设计，报盘的订单快速报出，极其考验柜台厂商的技术水平。
极速交易柜台系统在考虑系统稳定性和吞吐量的同时，充分考虑了系统计算资源消耗及分配的问题，通过高时效性的计算函数，减少运行状态下的内存再分配，避免了计算资源抢占等一系列手段极大地减小了系统内部延迟。
从交易柜台服务器网卡收到策略服务器发出的订单至调用交易所API函数结束，耗时峰值已实现百纳秒级，中位数1~2微秒。 
第二部分即系统服务器、网卡的性能，主要由硬件决定，服务器的主频、内存、处理器，网卡的带宽、延时都有很大影响。
通过在服务器及网卡层面的系统进行调优，能最大程度地减小延时。
第三部分即交易所API，主要由交易所技术公司决定，按照中国金融市场的监管规定，各个柜台厂商都需要调用交易所API向交易所报单。
交易所API是由交易所技术公司封装好的发布产品，底层逻辑不可见，优化空间较小。
4、交易所端延迟
交易所端延迟指订单从柜台系统调用交易所API从网卡发出订单后，交易所返回委托或成交报文至柜台网卡的整体耗时。
本段延时主要由服务器所在的交易所托管机房优势、市场活跃度（活跃的合约或者抢手的价位报单量大、撮合时间长、排队时间长；非活跃合约或者类似于涨跌停板这样的价位订单，报单量小、撮合时间短、排队时间少）等决定；
交易所API至交易所网络一般由交易所技术公司提供，所以这段延时主要由交易所决定，对所有投资者来说这一段都比较公平，优化空间最小。
5、量化交易延迟
量化交易延迟的主要环节如下：
（1）行情和订单信息网络传送延迟
交易所的实时行情数据和订单信息需要通过网络通道连接到程序化量化交易的策略交易服务器上，行情数据转路经最少的时间、深度行情，交易通道采用专用、直连的交易通道进行交易。
行情和交易的延时都要求尽可能最低.，比如为了减少数据延迟，越来越多的经纪商和服务机构要求尽量缩短自己的服务器与证券交易所计算机系统的物理距离。
硬件设备延迟：网络连接方式、交换机、路由器、数据发送优化
（2）策略服务器数据接收、处理的延迟
策略服务器使用高速服务器执行策略的架构，采用服务器多核多进程、多线程方式进行自动化交易、程序化交易、算法交易，为了追求闪电交易，使用超低延迟硬件技术进行高频交易等量化交易方式.
硬件设备延迟：策略服务器硬件（CPU处理速度、网卡、硬盘、内存、存储等）
（3）算法交易策略的延迟
设计交易策略：算法交易的核心是对股票等证券的历史行情数据进行分析，结合交易思想，设计出交易策略。
实现交易策略：交易策略编写成计算机程序，并根据股票的品种等因素确定好交易参数，将交易策略整合到交易系统。
接入行情数据：将交易系统上接行情数据，下连下单接口以报单。实际交易时，让程序根据行情的变化自动选择股票的买卖点。
自动交易：程序根据产生的买卖点来对股票进行买卖操作。
涉及延迟：开发语言、算法策略、数据库。
目前机器学习、深度学习等AI技术已经被广泛用于量化策略中的因子挖掘。
（4）金融新闻信息实时获取延迟
金融市场的信息已被诸如路透、道琼斯、彭博、汤姆逊金融等公司格式化，通过算法的解读来形成交易。
二、操作系统延迟
1、粗粒度时钟
虽然理论上操作系统时钟最小可以与硬件中断处理的时间相等，但通用操作系统的时间管理一般采用粗粒度的周期性时钟中断。对操作系统而言，避免了频繁进行进程上下文切换，但也使调度的时钟延迟在最坏情况下可能等同于时钟的间隔，从而成为延迟产生的最大来源。例如，Linux缺省时钟间隔粒度为10毫秒，因此最坏情况下内核和用户空间应用程序需要使用一个时间间隔来进行调度。对于一个休眠的进程，即便唤醒条件已经触发，也许需要10毫秒的时间才能被调度执行，显然难以满足低延迟应用的要求。
2、非抢占式处理
通用操作系统中大量存在的非抢占式处理会对低延迟处理造成影响。即便操作系统已经使用了细粒度的时钟，而且硬件也及时地产生了一个时钟中断，但如果中断被屏蔽或者内核运行在非抢占式代码区，也会造成内核不能及时中断，应用程序依然得不到及时的调度执行，延迟可能会长达50-100毫秒。
3、线程调度策略
线程调度策略也可能造成较大的延迟。即使操作系统使用了细粒度的时钟，并且使用了抢占式方式可以及时中断，但如果优先权不够，仍然无法被立刻被调度执行。实时系统领域对线程调度策略问题进行了较多的研究，其中较好的一类办法是使用按比例的实时调度器，可以按照比例对不同类型的应用线程进行调度，但前提是所有线程都是抢占式的，而且使用粒度更细的时钟。
4、页面调度与交换
通用操作系统一般都使用虚拟内存，因此并发执行的程序可以在运行程序时，只将运行需要的部分载入内存，从而允许程序空间的总和可以远大于实际可用的物理内存。对于时分系统来说,虚拟内存不会产生问题。但对于实时系统，页面调度与交换会造成无法容忍的不确定性延迟。
为支持实时、低延迟的应用，一些实时操作系统利用MINIX无任何页面调度与交换的特点，使用基于优先权的调度器替换MINIX操作系统原本基于循环的调度器。适合对时间粒度的要求不太高的应用。
5、RTLinux
RTLinux系统通过在Linux内核和中断控制器硬件间加上一层轻量级的虚拟机层来虚拟中断控制器和时钟，使得可以将Linux按照抢占式的方式来运行。其中操作系统内核不能直接控制中断控制器，因为虚拟机层使用宏替换了所有开、关中断和中断返回指令，所有的硬件中断均被虚拟机层捕获，然后根据中断状态判断是否需要处理该中断。由于内核比实时应用的运行优先权低，就不会对不被虚拟机捕获的实时中断造成影响。
6、RedHat MRG
为支持实时和低延迟的应用，RedHat公司也于2007年底推出了面向实时和高性能消息交换的RedHat MRG。MRG采用了更细粒度时钟、以信号量代替锁、减少非抢占式操作的代码、用线程处理中断、读-拷贝修改等各种技术来支持低延迟处理。根据Redhat在2009年峰会上公布的数据，配置为24GB内存、2.93gxeon四核处理器、Infiniband 4XQDR接口的MRG单机上每秒消息通信量已突破百万级。
7、CPU绑定
在多核处理器成为主流后，利用多核系统并行运行多线程以最大化计算机的处理效率成为研究的热点。在并行系统中，线程被尽可能地分派到不同的核心上执行。对于不希望被其它线程打扰运行的线程，或一些访问特定资源(如内存、I/O)的线程以及一些对无需上锁的运行时资源进行管理的线程，可以利用操作系统线程关联的机制，将线程绑定到特定的处理器，加快程序的运行速度。
8、Kernel bypass
kernel bypass（绕过内核）是解决系统网络栈和存储栈性能瓶颈的一种方式，kernel bypass核心思想是内核只用来处理控制流，所有数据流相关操作都在用户态进行处理，从而规避内核的包拷贝、线程调度、系统调用、中断等性能瓶颈，并辅以各种性能调优手段（如：CPU pin、无锁队列），从而达到更高的性能。
DPDK（Data Plane Development Kit）是由Intel发起，主要基于Linux系统运行，用于快速数据包处理的函数库与驱动集合，可以极大提高数据处理性能和吞吐量，提高数据平面应用程序的工作效率。DPDK使用了轮询(polling)而不是中断来处理数据包。在收到数据包时，经DPDK重载的网卡驱动不会通过中断通知CPU，而是直接将数据包存入内存，交付应用层软件通过DPDK提供的接口来直接处理，节省了大量的CPU中断时间和内存拷贝时间。
SPDK（Storage Performance Development Kit）是由Intel发起，用于加速使用NVMe SSD作为后端存储的应用软件加速库，核心是用户态、异步、轮询方式的NVMe驱动。与内核态的NVMe驱动相比，可以大幅度降低延迟，同时提升单CPU核的IOPS。其架构如下：

RDMA（Remote Direct Memory Access）全称远程直接数据存取，是为了解决网络传输中服务器端数据处理的延迟而产生的。RDMA通过网络把资料直接传入计算机的存储区，将数据从一个系统快速移动到远程系统存储器中，而不对操作系统造成任何影响，不需要用到多少计算机的处理功能。RDMA消除了外部存储器复制和上下文切换的开销，因而能解放内存带宽和CPU周期用于改进应用系统性能。

三、高频交易系统性能优化
1、延时定义
交易系统中的延时是指在一定的背景压力情况下，从接入网关发出指令，后台处理，然后在接入网关收到应答的延时。
延时是一个有实际意义的值，假设一定的背景压力，考虑的是延时的发生实在实际的生产环境中发生的，同时具体到背景压力，可能还会包含实际的业务行为分布，例如订单输入、订单删除、订单修改、订单查询等等。这些业务行为的分布，需要考虑实际生产环境中发生的比例，只有这样整个延时的测试才会比较真实和合理。
延时测试的基点是接入网关，目的是排除广域网物理链路对延时的影响，也是目前国际上发布延时的基准。
低延时意味着交易系统能够在更短的时间上响应客户的请求，那么在交易的关键路径上，必须要能够足够快的传输数据，同时关键路径上的模块必须要能够足够快的处理数据。
2、延迟测量
要控制和降低延迟，首先要能准确测量延迟，因此需要比较精确的时钟，每个机房需要配几台带GPS或原子钟的NTP服务器。即便使用NTP，同一机房两台机器的时间也会有毫秒级的差异，计算延迟的时候，两台机器的时间戳不能直接相减，因为不在同一时钟域，解决办法是设法补偿时差。另外，不仅要测量平均延迟，更重要的是要测量并控制长尾延迟，即99百分位数或99.9百分位数的延迟。
3、内部延迟
普通C++服务程序，内部延迟(从进程收到消息到进程发出消息)做到亚毫秒级并不需要特殊的优化。如果瓶颈在CPU，最有效的优化方式是强度消减，即不在于怎么做得快，而在于怎么做得少。
4、网络延迟
网络延迟分传输延迟和惯性延迟，通常局域网内以惯性延迟为主，广域网以传输延迟为主。传输延迟是传送1字节消息的基本延迟，大致跟距离成正比。传输延迟受物理定律限制，优化办法是买更好的网络设备和租更短的线路。惯性延迟跟消息大小成正比，跟网络带宽成反比，千兆网TCP有效带宽按115MB/s估算，那么发送1150字节的消息从第1个字节离开本机网卡到第1150个字节离开本机网卡至少需要10us，是无法降低的，因此可以减小消息长度。
5、吞吐量
延迟和吞吐量是矛盾的，延迟跟吞吐量的关系通常是个U型曲线，吞吐量接近0的时候延迟反而比较高，因为系统比较冷；吞吐量增加一些，平均延迟会降到正常水平；吞吐量再增大，延迟缓慢上升；吞吐量过了某个临界点，延迟开始飙升。因此需要把吞吐量控制在合理范围，保证延迟处于正常值。
6、资源使用率
延迟和资源使用率是矛盾的，做高吞吐的服务程序，恨不得把CPU和IO都跑满，资源都用完。而低延迟的服务程序的资源占用率通常低得可怜，实际上平时资源使用率低是为了准备应付突发请求，请求或消息一来就可以立刻得到处理，尽量少排队，排队意味着等待，等待意味着长延迟。消除等待是最直接有效的降低延迟的办法，依赖的是系统的冗余。
7、可靠传输
延迟和可靠传输也是矛盾的，TCP做到可靠传输的办法是超时重传，一旦发生重传，会增加几百毫秒的延迟，因此保持网络随时畅通，避免拥塞也是控制延迟的必要手段。
因此，必须避免交易时段在服务器上拷贝日志文件等操作，或是部署两张网卡，一张网卡专门用于交易，一张用于运维操作。
另一个办法是写个慢速拷贝程序，故意降低拷贝速度，每50毫秒拷贝50kB，用时间换带宽。
另外，可以编写慢速压缩程序，每100毫秒压缩100kB，花一分半钟压缩完100MB数据，分散CPU资源使用，减少对延迟的影响。




交易系统开发（八）——低延迟网络构建

一、低延迟交易
1、低延迟交易简介
低延迟交易是算法交易的一个分支，资本市场机构对市场事件进行更快速的反应，利用极其细微的反应时差，来获得更强的交易获利能力。
2、交易延迟分类
延迟是计算机系统接收到一个事件刺激，到产生响应之间的时间间隔。对于券商而言，事件刺激可以是客户端输入订单，可以接收到市场行情数据发布，可以是接收到订单确认返回。低延迟交易要求整个交易链条上的所有环节，都尽量缩短时间间隔。从交易系统层面看，交易延迟主要包括网络延迟、协议延迟、操作系统延迟、应用延迟等。 
3、网络延迟
交易系统的下单通过网络经券商柜台到达交易所交易撮合主机，中间会经过多个网络设备，包括交换机、路由器和防火墙等，因此网络会存在延迟。
网络中存在三种类型的延迟：数据序列化延迟、传输延时、排队延迟。
（1）数据序列化延迟
数据序列化延迟是网络设备将一定量的数据位（bit）输入物理介质（通常指光纤或者铜缆）所需要的时间。
（2）传输延迟
传输延时传输延时（propagation）是数据经过序列化处理进入传输介质后，在传输介质中传输所使用的时间。光在光纤中传输速度通常是在真空中传输速度的三分之二。
（3）排队延迟
当多个数据发送端通过同一条网络链路往一个接收端发送数据包时，数据包必须在连接发送端与接收端的交换设备上进行排队（queuing）。一个数据包排队延时的大小取决于两个因素，一个是排在前面的数据包数量，一个是数据接收链路的带宽速率。 
4、协议延迟
交易网络中存在多种网络传输协议，比如TCP、UDP、SPX等，由于不同协议设计的目标不同，因此其传输效率以及相应的延迟都有所区别。针对网络协议延迟，需要考虑以下特性：
（1）纳吉尔算法（Nagle Algorithm）
（2）数据窗口（Data Window）耗尽
（3）包丢失（Packet Loss）
（4）路由协议
（5）QOS与SPAN的使用
5、操作系统延迟
在计算机硬件与交易系统间，存在BIOS/FIRMWARE、操作系统内核、代码运行环境（包含在操作系统内），为交易系统提供各种功能函数调用，以实现代码与硬件之间的互动，操作系统内核及代码运行环境在调用过程中也存在一定的延迟。
设备制造厂商一般建议将BIOS和Firmware更新到最新版本并进行特别设置，并且提供关于低延时方面的解决方案或最佳实践，包括提供配置清单和脚本，用于检查各层次基础软件设置是否符合低延迟系统最佳实践等。
6、应用延迟
低延迟应用一般是交易机构自行控制的，根据一般交易应用的本质特征，应用延迟分为：
（1）磁盘访问
低延时应用采用内存数据库或者固态存储来降低IO延迟。
（2）进程间通讯
低延时应用采用RDMA等技术降低进程间通讯成本。
（3）数据计算
低延时应用采用FPGA、GPU等技术加速数据计算过程。
（4）数据锁等共享资源访问等待
可采用非阻塞式的数据管理系统，或者更小粒度的资源管理来降低访问等待。
7、延迟的度量
由于低延迟交易系统的延迟，在每一个环节都接近次微秒级，在度量时，不仅要作为一个整体来考虑平均延时、延时抖动以及吞吐量，而且要注意度量手段和工具本身的时间精度。
（1）平均延时
平均延迟是是消息通过从一个点到另一个点的平均时间,越低越好。
（2）延迟抖动
延迟抖动是衡量延迟可预测性的重要指标，其代表的是测量过程中，每次实际延迟与平均延迟之间的偏差程度。。
（3）吞吐量。
吞吐量可以定义为单位时间处理的数据量。一般低延迟系统要求在保持低延迟的前提下，追求尽量大的吞吐量。
（4）时间精度
大部分的计时系统依赖硅晶体振荡和主板中断等硬件基础，不同的操作系统平台采用的精度控制方法会有所差别。部分低延迟网卡和交换机可以提供高精度的时间戳供延迟度量使用。
二、低延迟网络简介
1、低延迟网络简介
近年来，金融和资本市场通过业务和技术双轮驱动持续高速发展，全球交易所趋向集中整合和互联互通，交易产品和业务多元化创新。信息技术创新日新月异，推动交易系统不断更新换代，交易系统由集中式转向分布式是国内证券行业交易技术发展的趋势。
证券交易系统的交易竞价原则是价格优先、时间优先，即同等价格下，先到先得。目前国内主流券商的集中交易系统委托上行时延从几十毫秒级到上百毫秒不等，面对日益激烈的竞争需求，新一代分布式架构的交易系统已经向百微秒级的时延迈进，时延大小是衡量交易系统性能最重要的指标。
全球交易所是以微秒级时延来进行度量和竞争的。为满足市场要求，采用先进的高性能网络设备和技术，构建高可靠、低时延、高吞吐网络的需求日益迫切。
每年6月和11月，Top500 Supercomputer网站公布超级计算机世界500强名单、性能指标、技术架构等，其中网络互联技术作为高性能网络技术的标杆。2018年11月，超级计算机前500强名单显示，最流行的互连技术是以太网（252个系统），然后是InfiniBand（135个系统），自定义互连（64个系统）和Intel Omni-Path（43个系统）

对2016年至2018年Top500超级计算机的网络互联技术变化趋势进行统计

高性能网络技术的应用和发展趋势：
（1）以太网和InfiniBand是两种主要的网络协议，万兆以太网是最广泛使用的系统互联技术；
（2）近两年来，随着融合以太网技术快速发展及以太网带宽大幅提升，以太网的份额逐渐扩大至51%，快接近InfiniBand份额的2倍；
（3）Intel主推Omni-Path高性能计算架构，提供交换机、管理软件、HFI卡、线缆等一体化解决方案。Omni-Path作为InfiniBand在超算高性能网络领域的主要挑战者，从2016年11月至今，采用Omni-Path的系统数量呈现平缓上升的趋势，目前总体占比为9%。
2、以太网
以太网在1970年代初期推出，以简单、易用、经济、易扩展等优势得到普遍应用。至今40多年的时间里，以太网技术和协议仍在持续演进发展，满足当今高性能网络融合创新的需求。近年来，为满足云计算、统一存储等多样业务，新型以太网通过DCB、VXLAN、FCoE等技术，丰富存储和虚拟化支持能力；通过RoCE、拥塞控制优化、流控管理优化等技术，大幅降低网络转发时延。以太网带宽从早期的10M速率提升到10G/25G/40G/50G/100G，近期以太网带宽进一步提升到400G，满足超大规模数据中心和云计算等带宽密集型需求。
高性能以太网络技术的快速发展，使得国内、外主要发达市场的交易所积极投入资源升级更新网络基础设施，如纽约证券交易所(NYSE)、纳斯达克证券交易所(NASDAQ)、伦敦证券交易所(LSE)、东京证券交易所(TSE)、香港证券交易所(HKEX)均采用万兆以太网，并提供万兆的托管机房接入。
3、InfiniBand
InfiniBand在1999年首次提出，是一个为大规模、低时延的高性能服务器集群而设计的网络技术，通过大带宽链路实现服务器、存储设备互联。其特点一是超大带宽的连接。带宽支持56Gb/s、100Gb/s及200Gb/s；二是极低的网络时延。InfiniBand在可比数据速率下具有比以太网更低的时延；三是可靠无损的网络。基于链路层的流控机制和先进的拥塞控制机制防止拥塞和丢包；四是完全的CPU卸载功能。基于硬件的传输协议实现高可靠、无丢包的网络数据传输。通过远程直接内存存取(RDMA)和内核旁路技术，可以直接对远程节点间预分配内存读和写，无需涉及操作系统内核、无需数据多次复制，大幅降低CPU工作负载和网络时延。五是卓越的可扩展性和灵活性。一个子网可以支持48,000个节点，一个网络即可支撑大规模服务器的部署。
一套完整的InfiniBand系统由服务器、交换机、子网管理器、主机通道适配器(HCA)组成。高性能服务器集群最广泛使用的网络架构为胖树（Fat-Tree），非阻塞网络下，该架构可以达到大规模服务器的最优性能。典型的胖树架构如下图示：

部分交易系统的内部通信为了达到最小的时延，核心网络采用InfiniBand，其它网络采用以太网，如德国证券交易所和新加坡交易所的交易系统内网采用InfiniBand，德国证券交易所的T7交易系统6.1版本委托回报回路时延少于52us，新加坡交易所的平均订单回报时延为90us。
三、低延迟网络构建
1、低延迟的因素
系统端到端时延主要由网络设备转发时延、网络连线的传输时延、网卡数据收发时延、操作系统处理时延、中间件处理时延及业务处理时延等构成。网络时延由网络设备转发时延、网络连线的传输时延和网卡数据收发时延组成，构建低时延网络，需要在各个环节降低时延损耗。
2、转发时延压缩
随着行业低时延、高性能交易场景及数据中心托管业务发展的需求，对网络设备的性能提出了更苛刻的要求。无论数据包大小和流量类型，所有网络端口之间应提供稳定的低时延传输，并保持足够低的时延抖动。2012年9月，思科公司发布了自研芯片和算法的Nexus3548交换机，正常路径转发时延为250纳秒，抖动在5纳秒左右。2013年，Metamako公司发布了超低时延的、可配置的一层交换机MetaConnect，时延仅为4纳秒，如此低的时延速度意味着使用者可以获得最大的竞争优势。2014年，Exablaze公司发布ExaLINK Fusion交换机，通过精简功能和协议并集成Xilinx Ultrascale FPGA，二层转发时延为110纳秒，一层交换时延为5纳秒。Arista、Juniper、华为等网络厂商大部分采用Broadcom、Intel的商用ASIC芯片解决方案，根据官网的数据，Arista 7150s-52的时延为380纳秒，Juniper的QFX 5110的时延为550纳秒。Mellanox采用自研的Spectrum芯片，以太网交换机SN2410的时延为300纳秒，InfiniBand SX6036 FDR(56Gb/s)交换机的时延为200纳秒，InfiniBand SB7800 EDR(100Gb/s)交换机的时延为90纳秒。
低时延网络设备的制胜高地竞争异常激烈，超低时延交换机的转发时延已经慢慢接近光传输速度的物理极限。实际上，业务处理时延和系统开销远大于网络设备时延，网络设备的转发时延、性能表现等指标可作为一个对比参考项。尤其是在核心交易系统，首先应该关注高可用网络架构以及网络在复杂故障场景下的表现，其次才是尽可能地降低时延。
3、网络架构
传统的大型数据中心的网络架构，通常分为核心层、汇聚层、接入层，随着云数据中心、分布式计算快速兴起，数据中心内的服务器交互流量激增，数据流向模型由南北向变成东西向。传统的网络架构是为了南北向流量设计，已不能满足高性能、低时延分布式系统部署的要求。目前，构建低时延网络架构的方法是尽量简化传统网络的层数，减少数据经过网络设备的次数，将传统集中交换、垂直的网络架构变为水平的、易扩展的分布式架构。
根据服务器的数量进行分类，交换机按48个接入端口计算，一个数据中心小于40台服务器的低时延网络架构通常只有一层（核心层），两台交换机互联既作为核心交换机，也作为接入交换机。交换机之间运行M-LAG或vPC或堆叠，确保不产生环路。同数据中心1跳网络可达，跨数据中心2跳网络可达，网络架构如下图示：

一个数据中心多于40台服务器的低时延网络架构通常有两层（核心层、接入层），两台交换机互联作为核心交换机，其余交换机作为接入交换机。核心交换机之间运行M-LAG或堆叠，确保不产生环路。同数据中心1跳网络可达，跨数据中心4跳网络可达，网络架构如下图示：

4、传输时延优化
网络传输时延是数据在网络链路传输时产生的延迟，网络传输时延与系统部署位置、长途线路的长度及传输介质密切相关，选择最短路径和最佳质量的链路，可确保最小化链路的网络传输时延。
为便于市场参与者能灵活、快速接入，交易所提供托管机房、数据专线甚至互联网等多种接入方式。技术基础设施和系统部署的位置就近接入交易所，在交易所托管机房部署系统可有效缩短网络接入时延，有利于构建点对点直连交易所的快速交易通道。为保证公平性，交易所在托管机房提供几乎完全等长的布线、及统一带宽的接入端口。市场参与者为获得最小的网络通讯时延，应建设低时延的局域网，同城跨数据中心的通讯尽量采用高速光纤链路进行通讯，通讯链路上尽可能少使用中继器、连接器、防火墙、路由器等设备。
5、低时延万兆网卡
低时延网络设备转发时延是百纳秒级的，在同一数据中心内部网络连线的传输时延也是百纳秒级的，相比之下，网卡数据收发时延则占据了主要的比重。下表是几个主流系列网卡的时延参考值：

即使是同为万兆网卡，不同系列网卡的性能差距甚远，低时延万兆的传输时延是普通万兆网卡的一半。网卡收发数据时延占如此高的比重，因此在构建低时延网络过程中，选择低时延万兆网卡非常有必要。
6、网络带宽提升
串行化时延是指一个数据帧或信元被一个接收者接收并开始处理的时间。串行时延与传输速率成反比，速率越高，接收数据帧的时间越短。提升网络接入带宽是减少串行时延的最有效办法，低时延网络建议最低的接入带宽为10G，推荐采用25G或更高的接入带宽。
现阶段,大多数数据中心基于10G以太网规划和建设。随着25G交换机和网卡的成本大幅降低，目前25G的总体拥有成本基本接近于10G，网络布线不需要变动便可直接升级演进到25G带宽。根据Dell'Oro Group预测：随着支持25G的网络交换机和网卡不断增加，更多的云用户或大型企业升级到25G。2019年至2020年，25 G将成为云和企业服务器的主流速度，25 G端口的出货量预计将在2021年达到峰值。
华锐分布式技术实验室联合上交所技术公司低时延技术实验室，使用Qperf对某主流品牌低时延万兆网卡在10G和25G模式进行TCP、UDP时延基准测试，分析对比结果显示：25G各种不同数据包长的TCP和UDP时延，均低于10G的时延。

即使网卡端口占用带宽远未达到10Gb/s的水平（如百兆b/s的流量带宽），以上测试结果仍然成立。为进一步分析带宽对应用系统的性能影响，实验室使用华锐的ATP交易系统在同一个测试环境，基于网卡的不同带宽模式进行测试，结果表明，系统时延降低超过20%的，应用的处理性能也得到了提升。
7、网卡加速
网卡作为服务器的一个重要部件，网卡的性能好坏会直接影响系统总体性能。通过网卡加速技术，可以大幅有效减少系统总体时延。近年来，以太网不断融合创新，发展推出RoCE协议。RoCE在数据链路层支持标准以太网协议，在网络层上支持IP协议；也无需改变数据中心的原有基础设施，节省大量成本；还使得大带宽以太网的性能快速向InfiniBand靠拢。
除了RoCE的网卡加速技术，行业比较常用的是加速技术，提供的高性能POSIX兼容网络堆栈，可显着减少网络时延、提高吞吐量和降低CPU利用率。提供标准的BSD应用程序编程接口支持以太网网络协议，最终用户不需要对应用程序进行修改。 技术通过内核旁路、减少数据复制次数等技术将传统的内核堆栈约7us的时延降低至不到2us。
8、无损网络
传统的以太网络采用的是尽力而为的转发模式，它对时延、丢包率等性能不提供任何保证。当网络中出现多台服务器同时与一台服务器通讯的时候，往往会造成网络数据的拥塞甚至丢包。网络拥塞丢包导致重传，增加网络时延，严重时会让业务性能也受到影响。减少或者避免网络拥塞和丢包现在通用的解决方案是：PFC(Priority-Based Flow Control )和ECN(Explicit Congestion Notification )的流控技术。PFC可以对链路上队列的流量进行控制，并在交换机入口出现拥塞时对上游设备流量进行反压。ECN技术可以实现端到端的拥塞控制，在交换机出口拥塞时，对数据包做ECN标记，并让流量发送端降低发送速率。通过在网络中组合部署PFC、ECN功能来实现无损传输保障，确保网络保持低时延运行。





交易系统开发（九）——Dark Pool技术

一、Dark Pool简介
1、Dark Pool简介
Dark Pool（黑池，暗池）是指不显示公开股票报价的电子交易场所。暗池交易最早出现在美国，兴起的主要原因与证券市场上兼并、收购日益频繁，大宗股权的转让需求蓬勃发展有密切关系。
通常，大宗交易可通过普通交易市场(直接、分拆申报、冰山/保留订单隐藏申报方式)或场外交易市场 (OTC) 进行交易，但存在效率低下，交易成本高，可能对市场造成影响等缺点。
随着投资者越来越害怕自己的订单给市场带来影响及不愿意暴露买卖信息，加上电子交易技术的发展，暗池交易应运而生。其中，最早出现、同时也是应用最广的形式当属配对撮合网。
在黑池交易中，买卖双方匿名配对进行大宗股票交易，主要由机构投资者参与买卖，运作并不透明，不会展示买卖盘价及报价人士的身份，也不会向公众披露已执行交易的详情，对机构投资者非常有利。
近年，黑池在欧美市场发展迅速，美国境内有几十家注册的暗池交易平台，在欧美证券市场中占据不忽视的市场份额。
目前，黑池内交易的证券种类以股票和债券为主，部分黑池也可交易外汇、交易型开放式指数基金（ETF）、衍生品等证券产品。
2、黑池交易的特点
黑池的特点如下：
（1）交易前信息保密
欧美监管机构都对黑池豁免交易前信息披露义务，其中美国在《另类交易系统指引》（Regulation ATS）中允许ATS中某只证券月均交易量在过去的6个月中4个月超过全国月均交易量5%时，才需公示其最优报价订单详情；欧盟在《金融工具市场法规》中对大宗交易和参考公开市场价格执行的交易豁免交易前信息披露义务。豁免交易前信息披露有利于保护大宗交易信息、减少市场价格冲击，但同时也使暗池流动性难以监测、成交时间和交易价格不确定性上升。
（2）交易价格多参考公开市场，黑池本身不参与定价。
欧美黑池大多直接以市场最优买卖价格（NBBO）中间价为成交价，可能为投资者提供优于市场的交易价格，但在市场波动较大时，投资者也可能因被动接受市场价格而蒙受意外损失。
（3）投资者有权选择交易对手。
黑池交易者可以选择向特定交易对手发送交易意向单（Indication of Interest，IOI），透露自己的交易标的和方向。根据不同交易对手的行为特点，投资者可以识别高频交易者等对己不利的交易对手，以避免可能损失。
3、黑池交易的优点
黑池交易平台对机构投资者的吸引力源于三个方面：
（1）价格优势
大多数黑池交易平台与NBBO中点价匹配，在交易所报价的最高出价和最低卖价的基础上得出。通过大额的高频交易，总数看来节省大量成本。
（2）成本更低
黑池交易直接绕过交易所达成双方交易，使得买卖双方不需要向交易所缴纳相关交易的手续费，和传统交易所订单方式的佣金相比，黑池交易的参与者认为黑池交易的佣金和交易费更低，从而节省成本。
黑池交易的匿名方式有利于买卖主力或基金大户隐藏身份，防止投资动向过早被外界察觉，以致交易成本增加或获利减少。故此，黑池交易比传统交易更能控制无形成本。
（3）流动性充足
黑池交易平台有能力避开市场流动性的波动，其独立性可以保障黑池交易平台可以获得流动性资源。交易所的交易数量和平均交易规模下降意味着交易所的流动性降低，此时投资者可以从黑池交易平台寻求部分流动性，特别是中小型股。
黑池交易将大额买卖迅速拆分为多项小额买卖，在私人交易平台进行配对，避免实时供求对大宗买卖产生影响，从而减少资产价格的波动。
4、黑池交易的缺点
黑池交易的缺点如下：
（1）黑池交易会影响市场稳定性
黑池交易是交易所外交易，在现有的技术和制度条件下，黑池交易规模无法准确统计，直接影响股票市场定价并对市场定价产生冲击，最终影响市场的稳定性，引发市场调控危机，对于现有的金融体制产生冲击。
（2）市场容易被机构控制
黑池交易的发展使得市场极有可能被大部分机构所控制。个人投资者极有可能要独自承担与机构作战的风险，会使得市场的个人投资者损失惨重。
（3）市场监管困难
当黑池交易的规模越来越大时，市场监控也就变得越加艰难，使得内幕交易的发生概率变高，市场很难再起到一个监控的作用，资本市场的涌动可能会在未来摧毁整个金融体系和个人投资者的投资信心。
5、Dark Pool交易的发展
暗池交易最早出现在美国，兴起的主要原因与证券市场上兼并、收购日益频繁，大宗股权的转让需求蓬勃发展有密切关系。
通常，大宗交易可通过普通交易市场(直接、分拆申报、冰山/保留订单隐藏申报方式)或场外交易市场 (OTC) 进行交易，但存在效率低下，交易成本高，可能对市场造成影响等缺点。
随着投资者越来越害怕自己的订单给市场带来影响及不愿意暴露买卖信息，加上电子交易技术的发展，黑池交易应运而生，其中最早出现、同时也是应用最广的是配对撮合网。
1986年，Instinet公司建立了第一个真正意义上的现代黑池：After Hours Cross配对撮合网。 
1987年，ITG公司（Investment Technology Group）成立，并与Barra公司联合发布POSIT（Portfolio System for Institutional Trading）配对撮合网。
2001年，塞斯·莫林（Seth Merrin）创立Liquidnet（利贯交易网）， 帮助大型资管机构建立一个匿名的交易平台。目前，利贯交易网已成为全球主要的独立黑池交易平台之一，如今已经涵盖全球46个市场，拥有约1000个机构客户，所管理的资产规模总计高达15万亿美元。
2005年，高盛在美国推出SIGMA X黑池平台。
2006年，日本野村证券以12亿美元从私募股权集团Silver Lake手中收购Instinet。
2006年，摩根士丹利推出黑池交易平台MS Pool。
2008年，英国伦敦金属交易所LME推出黑池交易平台Turquoise。
2009年，美国高盛在香港引入黑池交易平台SigmaX。
2009年2月，纽约证券交易所联合汇丰银行、摩根大通、法国巴黎银行推出暗赤交易平台SmartPool。
2009年12月，日本野村证券推出黑池交易平台NX。
2015年11月，富达国际投资（Fidelity Investment）等9家资产管理巨头正式推出黑池交易平台Luminex。Luminex由富达国际投资（Fidelity Investment）发起，参与组建的其他财团还包括贝莱德集团(BlackRock, Inc.)、资本集团（Capital Group Capital）、MFS投资管理公司（MFS Investment Management）、景顺集团(Invesco)、美国普信集团(T Rowe Price)、摩根富林明资产管理公司（JPMorgan Asset Management）、道富银行(State Street)和纽约梅隆银行（Bank of New York Mellon）形成。其中，富达国际投资约持有60%的股权，其它股东各占4.9％。
2017年5月，高盛推出新的黑池交易平台Sigma X-Squared并关闭Sigma X。
2019年7月，UBS在澳大利亚引入黑池交易平台PIN。
二、交易所反应
1、纽约证券交易所
纽约证券交易所采取正面反击态度面对黑池，2009年2月，纽交所联合汇丰银行、摩根大通、法国巴黎银行等投行推出了黑池交易平台SmartPool，直接对抗各黑池交易平台。
2、纳斯达克证券交易所
纳斯达克证券交易所对于黑池交易的不透明性进行严厉批评，但同时也在建立自己的黑池交易平台。2010 11月，美国 PSX 透过 NASDAQ OMX Nordic平台推出黑池交易服务。
3、伦敦证券交易所
伦敦证券交易所采取正面反击态度面对黑池，2009年12月，伦交所宣布将其下黑池交易平台Baikal与黑池交易平台Turquoise进行合并，新平台名称为Turquoise，伦敦证交所持股60%，Turquoise的初始投资者（数家投行）持有其余股份。
4、香港证券交易所
2015年5月16日香港证监会决定禁止散户参与黑池交易平台，新制度于2015年12月1日生效。
尽管黑池交易在日本和澳大利亚等其它亚洲市场有所成长，但由于香港证监会对黑池交易实施强监管的抑制政策，黑池交易在香港发展一直比较缓慢，其原因之一是高昂的交易手续费使得在香港证券交易所进行高频交易基本无钱可赚，黑池交易失去了重要卖点，即无法通过让价格保密来阻止自动化交易员掌握资讯优势。
三、Dark Pool交易监管
1、Dark Pool交易监管
1998年12月，美国证监会颁布《ATS条例》并宣布对ATS实施监管，ATS（另类交易系统）可以申报登记为交易所。黑池需要注册为另类交易系统，并受美国证监会监管。
2007年11月1日，欧盟《金融市场工具指令》(MiFID)生效，黑池需要注册为多边交易设施（MTF），受欧洲证券及市场管理局（ESMA）监管。
2011年8月，香港证监会禁止汇丰银行向散户投资者提供StockMax黑池交易服务，只能对专业投资者提供服务。
2012年10月，香港证券交易所要求所有黑池交易参与者向港交所强制申报所有在黑池进行的香港股票交易，并以另类交易平台(ALP)标示，包括交易金额的数据在执行后一分钟内，向港交所进行申报。港交所负责收集交易数据，然后向香港证监会汇报，数据不向外公布。
2013年1月，美国金融业监管局(Financial Industry Regulatory Authority)计划扩大对黑池交易平台的监管。
2015年11月，美国证券交易委员会（SEC）提出新规加强对黑池的监督。
2015年11月，欧洲央行宣布加强对黑池交易的监管力度。
2015年12月1日，香港证监会决定禁止经纪机构向个人投资者提供黑池交易，同时要求加大交易活动的透明度。
2018年1月，欧盟正式推出欧洲金融工具市场指令（Markets in Financial Instruments Directive II , MiFID II），并于2018年1月3日生效。
2、Dark Pool监管处罚
2014年6月，美国证监会宣布Liquidnet公司因违反其监管业务以及对公司另类交易系统用户的承诺，允许黑池业务外的部门获取其机密的交易数据被处以200万美元罚款。
2015年8月，香港证监会宣布法国巴黎银行旗下法巴证券因在黑池交易服务方面存在缺失和违规对其开1500万港元的罚款，致使法国巴黎银行11月6日关闭了香港的黑池股票交易平台。
2015年12，香港证监会宣布摩根大通旗下摩根大通经纪(香港)、摩根大通证券(亚太)和摩根大通证券(远东)三家子公司在做空交易、便利客户及自营交易业务和黑池交易服务方面存在多项违反规定以及存在内部监控缺失的行为，证监会作出谴责，并分别罚款1500万港元、1200万港元及300万港元。
2016年12月，美国监管部门宣布德意志银行（DB）将支付3700万美元了结美国政府对其如何将交易转到黑池私人交易渠道的调查。
2018年7月10日，香港证监会宣布花旗环球因其黑池交易平台Citi Match存在未对客户进行识别及未向用户提供平台指引两大职责缺失被谴责并处罚款400万元港元。




交易系统开发（十）——FIX协议

一、FIX协议简介
1、FIX协议简介
FIX（Financial Information eXchange Protocol，金融信息交换协议）是由国际FIX协会组织提供的一个开放式协议，目的是推动国际贸易电子化进程，在各类参与者之间，包括投资经理、经纪人、买方、卖方建立起实时的电子化通讯协议。
FIX协议的目标是把各类证券金融业务需求流程格式化，成为一个可用计算机语言描述的功能流程，并在每个业务功能接口上统一交换格式，方便各个功能模块的连接。
 2006年10月，FPL（FIX Protocol Ltd）发布了FIX5.0，FIX5.0引入TI（the transport independence ）传输无关框架。TI将FIX会话层从应用层协议中分离出来。在TI框架下，应用层协议消息可以通过任意合适的传输技术进行传送，FIX会话层协议是FIX应用层消息的可选传输传输协议之一。两个协议层的版本标注将会有所不同，FIX X.Y为FIX应用层协议版本，应用层协议定义金融活动相关的业务数据结构；FIXT X.Y 为FIX会话层协议版本编号，会话层协议定义数据通信相关的协议。
2、FAST协议
为了解决FIX协议传输市场数据存在的冗余度高，带宽需求大的问题，芝加哥商品交易所（CME）在2003年向FPL（FIX Protocol Ltd）提交了一个解决方案，FPL在2004年成立了市场数据优化工作组(MDOWG)，2005年MDOWG开始根据一些POC(Prove of Concept)的结果进行协议标准制定，并于2006年初完成了FAST(FIX Adapted for Streaming) V1.0，2006年12月完成了FAST V1.1。 
FAST协议核心是一个压缩算法，将按照FIX规范定义的数据经过压缩后，可以在很大程度上降低发送、接收双方的带宽。
FAST协议的优点是高压缩比，低资源消耗，算法简单高效，每秒百万级别的消息处理能力。
3、STEP协议
STEP（Securities trading exchange protocol，证券交易数据交换协议）是基于FIX4.4版本FIX协议制定出来的中国本地化FIX协议版本，是中国国家金融行业标准，已成为事实上的证券数据标准，其语法简单定义灵活易扩展，数据相对冗余。
4、Binary协议
Binary即二进制协议，定义了各种报文的字段、编解码规则等。在深交所的Binary协议中，所有的消息都有3部分组成：消息头，消息体和消息尾。消息头有8个字节，包括整数MsgType和整数BodyLen，MsgType表示消息的类型，BodyLen表示消息体的长度；消息体根据BodyLen大小进行读取；消息尾是4个字节的 checksum。
5、FIX协议的优缺点
FIX协议优点是使用key-value对，可以很方便地查看报文内容以及扩展新字段，国际通用，适应力强。
FIX协议缺点是速度慢。
二、FIX协议工作原理
1、FIX应用模式
FIX有Initiator和Acceptor两种应用类型，Initiator是通信发起者，通过发送初始Logon消息发起Session；Acceptor是FIX Session的接收方，负责执行第一层次认证和通过传输Logon消息响应确认正式连接请求被接受。
FIX协议规定Initiator是通信发起者，Acceptor为接受者。FIX标准应用模式以网关为Acceptor，客户端为Initiator。
2、FIX Connection
FIX Connection由3部分组成：logon登录，message exchange消息传输，logout注销。
3、Fix Session
FIX Session由一个或多个FIX Connection组成，一个FIX Session可以有多次登录。
一个FIX Session定义为一个在连接双方间的的带有连续序列号的有序消息双向传输流。单个FIX Session能够跨越多个连续（不是并行的）的物理连接。在一个FIX Session中，参与方能够多次连接和断开连接。连接的参与方必须根据单个系统及时间区域需求，公共协商Session的开始和结束。
建议一个新的FIX会话在每24小时期间建立一次，可以维持24小时的连接和通过设置在Logon消息中的ResetSeqNumFlag建立一套新的序列号。
每个FIX参与方必须为FIX Session维护两个序列号，一个是接收序列号，一个是发送序列号，两者都在建立FIX Session开始时初始化为1。每个消息被赋予一个唯一的序列号值，并在消息发送后递增。此外，每个收到的消息都有一个唯一的序列号，接收序列号计数器在收到每个消息后将会被递增。
当接收序列号与所希望得到的的正确序列号不必配时，必须采取纠错处理。
4、序列号
每条FIX消息都由一个唯一的序列号进行标识，序列号在每一个FIX Session开始时被初始化为1，并在整个Session期间递增。监控序列号可以使Session参与者识别和处理丢失的消息，当在一个FIX Session中重新连接时能够快速进行应用程序同步。
每个Session将建立一组互不依赖的接收和发送序列。Session参与者将维护一个赋予发送消息的序列和一个监控接收消息的消息块间隙序列号。
5、心跳
在消息交互期间，FIX应用程序将周期性产生Heartbeat心跳消息。心跳消息可以监控通信链路状态及识别接收序列号间隙。Heartbeat消息的周期间隔由Session发起者使用在Logon消息中HeartBtInt域进行定义。
Heartbeat心跳消息的时间间隔应当在每一个消息发送后复位，即发送一个消息后，在间隔给定的时间内无其它消息发送则发送一个Heartbeat心跳消息。HeartBtInt值应当被Session双方认同，由Session发起方定义并由Session接收者通过Logon消息进行确认。同一个HeartBtInt被Session双方——登录的发起者和登录的接受者共同使用。
6、数据完整校验
消息数据内容的完整性可以参用两种方式来验证：消息长度和校验码检查。
程序通过计算BodyLength域到CheckSum标记（“10=”）分界符的字符数，域BodyLength标识的消息长度进行比较来完成完整性效验。
ChekSum完整性检查，通过计算从域“8=” 中“8”开始，包括紧跟在CheckSum标记域的分界符每个字符的2进制和同CheckSum进行比较得到。
一个FIX消息校验和通过计算到ChechSum域（不包括）的消息的每个字节和得到。然后，校验和被转换为模256的数字用于传送和比较。校验和在所有加密操作后被计算。
FIX消息示例如下：
8=FIX.4.29=7335=A34=149=CLIENT52=20181119-10:42:48.76856=SERVER98=0108=30141=Y10=208
消息长度：9=73，标识的消息体如下：
35=A34=149=CLIENT52=20181119-10:42:48.76856=SERVER98=0108=30141=Y
7、消息确认
FIX协议不支持单个消息的确认，采用监控消息时隙的方法来进行消息恢复和验证。
普通的数据传送（无单个消息确认）通过消息序列间隙进行错误识别。每个消息由一个唯一的序列号进行标识。接收端应用程序负责监控接收消息序列号以识别消息间隙并产生重传请求。
8、加密
加密算法由连接双方共同协商。
一个消息的任何一个Field可以被加密并放在SecureData Field中。然而，一些显示的标志域必须采用明文进行传输。为确保完整性，明文域可以在SecureData域中重复。
当使用加密时，建议所有的消息体都进行加密。如果一个消息中的循环组数据中的部分数据要加密，循环组必须全部进行加密。
预先协商好的加密算法在Logon消息中进行声明。
9、自定义域
FIX协议为给用户提供最大的灵活性，其允许用户自定义域。自定义域在认同的参与者之间实现、应用，因此需要注意避免冲突。
FIX协议规定，Tag在5000 到9999保留用于用户自定义域，用于企业联盟的信息交换，可以通过FIX网站进行注册；Tag在10000以上保留用于单一企业内部使用，不用注册。
10、有序消息处理
FIX协议假设消息在所有参与者间完全按照顺序进行传输。协议的实现者在设计消息间隙填充处理时应当考虑顺序传输假设。有两种方式处理消息间隙。第一种是，要求接收的消息是最后一个接收消息的后续消息或在维护一个所有新消息有序序列时，请求特定丢失消息。比如：接收方丢失了5个消息块中的第二个，程序能忽略第3到第5个消息，产生一个对消息2到消息5的重传请求，或者从消息2到无穷大消息编号的重传请求。第二种方式是，暂时存储消息3到消息5，仅要求重传消息2。
11、重复消息
当一个FIX引擎对一个消息是否成功地被指定的目标接收或者当对一个重传请求进行响应时，将会产生一个可能的消息复制。复制消息将用同样的序列号进行重新传送，此时在头部的PossDupFlag域将会被设置为‘Y’。接收端程序负责处理重发消息，可以作为一个新消息进行处理，或者根据实际情况忽略该消息。
所有重传请求的响应消息都将包含其值为‘Y’的PossDupFlag域。没有PossDupFlag域或者PossDupFlag域为‘N’的消息应被当作初始传送消息。PossDupFlag值为‘Y’的重传消息需要重新计算其CheckSum值。复制消息中发生变化的域包括：CheckSum，OrigSendingTime，SendingTime，BodyLength和PossDupFlag，加密相关域（SecureDataLen和SecureData）也必须被重新构造。
12、消息重发
模糊的应用层消息可能随同PossResend标志被重传。当一个指令没有在规定时间长度内进行确认或者终端用户挂起该指令没有进行传送时这种方法非常有用。接收程序必须识别此标志，并质疑其内部域以确定该指令是否在之前已经被接收过。重传消息将包含与原始消息相同的数据体，但包含PossResend标志和一个新的序列号。此外，CheckSum和与加密相关的域值需要重构。
三、消息类型
1、管理消息
管理消息（Adminitrative Message）是为了信息交换过程更加顺畅一致而使用的控制，包括登录、心跳、检验请求、重新发送请求、拒绝(交换过程)顺序重设及注销等。
2、应用消息
应用消息（Application Messages）是交易的数据，包括如下数据：
公告：宣布已完成的交易信息。
重要提示：告知由经纪人买卖的证券是由私人股份有限公司所有，还是由代理持有，以及持有量。
消息：是经纪人和机构之间传送的一般自由格式信息，带有识别信息紧急性和商号主题词分类标志。
电子邮件：其格式和用途与消息信息相同，但更倾向于双方非公开的用途。
报价请求：有些市场要求经纪人在每次订单前提出报价。
报价与多宗报价：回应报价请求的信息并用于发表主动的报价。
请求对多宗报价的确认：使用报价回应水平标记，有选择地支持对报价的确认。
报价撤销：报价发起人用于撤销报价。
报价状况请求：机构用来生成执行报告。
报价确认：针对报价、多宗报价、报价撤销和报价请求，作出回应。
行情数据请求：通过此请求得到所指定的证券和外汇交易报价的行情数据。
行情数据—快照、完全刷新：用于发送双方的订单登记簿、报价清单、交易清单、指数值、开盘价、收盘价、成交单价、最高价、最低价和变动加权平均价等。
行情数据—添加刷新：用于添加刷新请求。
行情数据请求拒绝：用于经纪人因交易或技术上的原因不承兑行情数据请求的情况。
证券定义请求：用于某一指定证券与第二方交易。
证券定义：接受或拒绝证券定义信息中请求的证券，发回证券及类型清单。
证券状况请求：用于提出有关证券状况的请求。
证券状况：提供有关证券状况改变的报告。
交易盘状况请求：请求有关市面状况的信息。
交易盘状况：提供有关市场状况的信息。
新订单：机构向经纪人提供有关证券或外汇的订单。
执行报告：确认收到订单或订单改变信息，传递订单状况或订单成交信息，报告交易的费用。
未知交易：通知交易方，收到的订单已被执行。
订单撤销、替换请求：改变订单的参数。
订单撤销拒绝：经纪人在不能承兑所收到的撤销请求信息时发出的信息。
订单状况请求：机构要求经纪人生成并发挥有关订单状况的信息。
划拨：指定如何将一个订单或一组订单细分为一个或多个账户。
划拨确认：确认收到机构发送的划拨信息及状态。
结算指令：经纪人或机构交易结算的指令。
出价请求：在非公开市场与公开市场，因市场规则不同用法也不同。
出价回应：因两个市场规则不同，有不同的用法。
新订单—清单：因两种市场规则的不同而不同。
敲定价：交换本金交易的敲定价。
状况清单：卖方以主动方式发送回应状况清单请求信息。
清单执行：机构用于指示经纪人开始执行已被提交的证券订单信息。
清单撤销执请求：用于机构希望在执行交易盘之前或之中，撤销已被提交的证券订单消息。
状况清单请求：用于机构指示经纪人生成有关某一状况清单的信息。
清单订单信息的分解：使用与其它FIX信息相同的方法，支持程序交易中的信息分解。
交易信息拒绝：拒绝因遵循了交易盘规则而不能以其它方式进行拒绝的应用层面的信息。
四、FIX协议
1、数据类型
FIX协议的数据类型包括整数int，浮点数float，字符char，布尔Boolean，字符串String，数据data。
2、Field
Field由Tag、Value和Delimeter组成，Delimeter用于分隔不同Field，如8=FIX4.1SOH，tag为8，value为FIX4.1，Delimeter为SOH（0x01）。
常见Field如下：
Tag	FieldName	Description
8	BeginString	起始串，FIX协议版本
9	BodyLength	消息长度
35	MsgType	消息类型：例如F=Order Cancel Request，取消订单
11	ClOrdID	客户端订单ID
37	OrderID	服务端订单ID
41	OrigClOrdID	原始客户端订单ID
54	Side	买卖类型。例如：1 = Buy，2 = Sell
55	Symbol	股票代码。例如：YRD
10	CheckSum	校验码
3、消息
FIX消息由多个Field组成，包括消息头、消息体、消息尾三部分。
消息头的前3个Field的次序不能改变，起始串(Tag=8)、消息体长度(Tag=9)、消息类型(Tag=35)。
消息尾的最后一个Field必须是校验和Field(Tag=10)。
8=FIX.4.49=6335=034=115849=SAMPLESENDER52=20150201-00:22:34.99556=SAMPLETARGET10=114
循环组中，Field出现的顺序应遵循循环组在消息或组件中定义时的次序；在一条FIX消息中，除循环组Field外任何其它Field不能重复出现。
由于FIX消息有可能在公网或不安全的网络上传输交换，因此需要对相关的敏感数据加密处理，具体加密的方法由连接双方达成的协议而定。
FIX消息内除某些需要公开识别的Field以明文传输外，其它任何Field都可以加密放置密文数据域 (SecureData)内，被加密的Field也可以同时保留明文的表示方式。
当决定使用加密方案时，可以对FIX消息正文内所有的Field加密。如果消息的循环组内有部分需要加密的，那么要求对整个循环组加密。
FIX协议还提供的一些Field用以支持数字签名、密钥交换和正文加密等安全技术。
4、消息头
每一个会话或应用消息有一个消息头，消息头指明消息类型、消息体长度、发送目的地、消息序号、发送起始点和发送时间。
Tag	域名	必需	说明
8	BeginString	Y	起始串，取值:FIX.4.2(不可加密，消息的第一个域)
9	BodyLength	Y	消息体长度(不可加密，消息的第二个域)
35	MsgType	Y	消息类型(不可加密，消息的第三个域)
49	SenderCompID	Y	发送方代码(不可加密，发送方标识符)
59	TargetCompID	Y	接收方代码(不可加密，接收方标识符)
115	OnBehalfOfCompID	N	最初发送方标识符(可加密)，用于经第三方发送。
128	DeliverToCompID	N	最终接收方标识符(可加密)，用于经第三方发送。
90	SecureDataLen	N	密文数据长度
91	SecureData	N	密文数据(紧跟密文数据长度域)
34	MsgSeqNum	Y	消息序号(可加密)，如果交易双方不采用 FIX 会话 机制，可将该 tag 置为一个固定的值，例如 0。
50	SenderSubID	N	发送方子标识符(可加密)
142	SenderLocationID	N	发送方方位标识符(可加密)
57	TargetSubID	N	接收方子标识符(可加密)
143	TargetLocationID	N	接收方方位标识符(可加密)
116	OnBehalfOfSubID	N	最初发送方子标识符(可加密)
144	OnBehalfOfLocationID	N	最初发送方方位标识符(可加密)
129	DeliverToSubID	N	最终接收方子标识符(可加密)
145	DeliverToLocationID	N	最终接收方方位标识符(可加密)
43	PossDupFlag	N	可能重复标志，重复发送时，作此标记。(可加密)
97	PossResend	N	可能重发标志。(可加密)
52	SendingTime	Y	发送时间(可加密)
122	OrigSendingTime	N	原始发送时间(可加密)
347	MessageEncoding	N	消息中 Encoded 域的字符编码类型(非 ASCII 码)
369	LastMsgSeqNumProcesse d	N	最后处理消息序号(可加密)
370	OnBehalfOfSendingTime	N	最初发送时间(用 UTC 表示时间)
5、消息尾
每一个消息(会话或应用消息)有一个消息尾，并以此终止。消息尾可用于分隔多个消息，包含有3位数的校验和值。
Tag	域名	必需	说明
93	SignatureLength	N	数字签名长度(不可加密)
89	Signature	N	数字签名(不可加密)
10	CheckSum	Y	校验和，消息的最末域。(不可加密)
6、新订单消息
对于在消息头中设置了PossResend标志的订单消息，应当使用交易客户方订单编号(ClOrdID)核实是否已收到该订单，具体实现时还应检查订单参数(买卖方向、证券代码、数量等)进行核实。如果之前收到该订单，应以执行报告消息回应订单状态。如果之前未收到，则以执行报告消息回应订单确认。
7、执行报告消息
订单回执包括订单确认、订单状态变化确认(如撤单确认)、成交回报、
订单拒绝。
8、订单状态请求消息
订单状态请求用于向交易服务方请求某订单的状态，交易服务方通过执行报告消息返回订单状态。
9、撤单消息
撤单消息用以撤消订单的全部订单剩余数量。
撤单消息也被赋予一个ClOrdID，如果被拒绝，撤单拒绝消息的ClOrdID放置撤单消息的ClOrdID，而原始订单的ClOrdID则放入OrigClOrdID域。ClOrdID要保证唯一。
10、撤单拒绝消息
本消息用于撤单消息的拒绝。
交易服务方接收到撤单发现无法执行(已成交订单不可更改等)，将发送撤单拒绝。
拒绝撤单时，撤单拒绝消息应用 ClOrdID 指示撤单的 ClOrdID，用 OrigClOrdID 指示之前最后接受的订单(除非拒绝原因是“未知订单”)。
Tag	域名	必需	说明
	标准消息头	Y	MsgType=9
37	OrderID	Y	期货公司委托号，同个交易日必需保证唯一
11	ClOrdID	Y	交易客户方订单编号
41	OrigClOrdID	Y	原始交易客户方订单编号，指示被撤消订单的ClOrdID
39	OrdStatus	Y	订单状态
109	ClientID	Y	客户资金帐号
1	Account	Y	客户交易编码
60	TransactTime	N	订单发起时间
434	CxlRejResponseTo	N	撤单拒绝回应类型
102	CxlRejReason	N	撤单拒绝原因
58	Text	N	
10	标准消息尾	Y	
五、FIX Engine
（1）QuickFIX
QuickFIX是一款C++实现的开源FIX引擎，同时提供Python、Ruby语言实现。
（2）FIX 8
FIX8是一款C++实现的开源高性能FIX引擎。
https://www.fix8.org/
（3）OnixS FIX Engines
OnixS FIX Engines是OnixS公司的一款商业的FIX引擎，支持C#、C++、Python、Java。
（4）Chronicle FIX Engine
Chronicle FIX Engine是Chronicle公司的一款高性能的FIX引擎。





交易系统开发（十一）——QuickFIX简介
一、QuickFIX简介

1、QuickFIX简介
QuickFIX是一款C++实现的开源FIX引擎，同时提供Python、Ruby语言实现。
QuickFIX官网：
http://www.quickfixengine.org
Github地址：
https://github.com/quickfix/quickfix
2、QuickFIX编译
编译选项配置：
configure
编译：
make
检查：
make check
安装：
sudo make install
二、FIX应用模式
1、FIX应用模式简介
FIX应用有initiator和acceptor两种模式。
initiator是TCP连接的发起方，acceptor是TCP连接监听方。标准FIX应用(如CTS FIX网关）可以同时支持initiator和acceptor两种模式，既可以发起连接，也可以接受连接请求。
开发FIX应用时，需要先确定FIX应用模式，然后选择对应的QuickFIX类对象。
initiator模式的FIX应用可以使用SocketInitiator、SSLSocketInitiator、ThreadedSocketInitiator、ThreadedSSLSocketInitiator创建FIX Initiator应用。
acceptor模式的FIX应用可以使用SocketAcceptor、SSLSocketAcceptor、ThreadedSocketAcceptor、ThreadedSSLSocketAcceptor创建FIX Acceptor应用。
2、FIX通信
FIX应用业务是通过在initiator与acceptor间建立一个FIX Session并交换消息来进行的。FIX业务消息有一系列预定义类型与格式，目前标准的消息类型有5、60个，函盖了交易、行情、结算等投资管理的各个环节。FIX应用开发基本上是对FIX消息的编程。
Fix Session可以由一个或多个Fix连接组成，即Fix Session可以多次登陆。Fix Session通常使用几个重要标识区分，如Fix版本号字符串(如:FIX.4.2)，发送者ID，接收者ID，Fix Session每发送一条消息时，消息头的BeginString、SenderCompID、TargetCompID都会被赋值。当消息通过FIX连接到达对等方时，对等方可以根据消息头中的的标识找到本地端的Fix Session去处理消息。
FIX通信双方包括Initiator和Acceptor，会各自维护2个递增的序列号(发送消息序列号–每发送一个消息加1，接收消息序列号–每收到一个消息加1)。
（1）通信首先由Initiator开始发起TCP连接请求， Acceptor接收网络连接请求，建立TCP连接。
（2）Initiator发起登录消息请求。
（3）Acceptor收到登录请求后，经过一系列消息检查，合格后，返回登录确认。
（4）Initiator收到登录确认后，经过一系列消息检查，合格后，双方FIX Session连接成功。
（5）Initiator和Acceptor交换消息。
（6）Initiator和Acceptor任何一方发出退出消息。
3、FIX Session配置
QuickFix中initiator或acceptor会维护多个Fix Session。QuickFix中使用BeginString（Fix版本号）、SenderCompID、TargetCompID的组合标识一个Session，Session标识用于区分其它不同的Session。
Session配置文件包含[DEFAULT]和[SESSION]两种分节，[SESSION]分节表示QuickFix中定义一个Session，[DEFAULT]表示所有Session默认使用的配置项，如果不提供QuickFix所需的配置，QuickFix会抛出ConfigError异常，表示配置缺失或格式不正确。
如果[DEFAULT]和[SESSION]分区中都包含相同的配置项，则[SESSION]分区的配置项会覆盖[DEFAULT]分区相应的配置项。
QuickFix配置文件sessions.ini如下：
[DEFAULT]
ConnectionType=initiator
ReconnectInterval=60
FileLogPath=log
FileStorePath=store
StartTime=00:00:00
EndTime=23:59:59
HeartBtInt=30
ResetOnDisconnect=Y
ResetOnLogout=Y
ResetOnLogon=Y

[SESSION]
BeginString=FIX.4.2
SenderCompID=CLIENT
TargetCompID=SERVER
SocketConnectPort=6666
SocketConnectHost=127.0.0.1
DataDictionary=FIX42.xml
三、QuickFIX核心类
1、FIX::Application
FIX应用需要实现FIX::Application接口：
class Application
{
public:
  virtual ~Application() {};
  /// Notification of a session begin created
  virtual void onCreate( const SessionID& ) = 0;

  /// Notification of a session successfully logging on
  virtual void onLogon( const SessionID& ) = 0;

  /// Notification of a session logging off or disconnecting
  virtual void onLogout( const SessionID& ) = 0;

  /// Notification of admin message being sent to target
  virtual void toAdmin( Message&, const SessionID& ) = 0;

  /// Notification of app message being sent to target
  virtual void toApp( Message&, const SessionID& )
  EXCEPT ( DoNotSend ) = 0;

  /// Notification of admin message being received from target
  virtual void fromAdmin( const Message&, const SessionID& )
  EXCEPT ( FieldNotFound, IncorrectDataFormat, IncorrectTagValue, RejectLogon ) = 0;

  /// Notification of app message being received from target
  virtual void fromApp( const Message&, const SessionID& )
  EXCEPT ( FieldNotFound, IncorrectDataFormat, IncorrectTagValue, UnsupportedMessageType ) = 0;
};
onCreate：当一个Fix Session建立时调用。
onLogon：当一个Fix Session登录成功时调用。
onLogout：当一个Fix Session退出时调用。
fromAdmin：当收到一个消息，经过一系列检查，合格后，属于Admin类型时调用。
fromApp：当收到一个消息，经过一系列检查，合格后，不属于Admin 类型时候调用。
toAdmin：当发送一个admin类型消息调用。
toApp：当发送一个非admin(业务类型)消息调用。
如果需要使用QuickFIX开发FIX应用，则需要实现FIX::Application接口，并重载不同FIX协议版本的MessageCracker::OnMessage接口，如FIX42::MessageCracker。
FIX业务都是异步方式处理的，而业务处理的基本对象是消息。OnMessage是消息接收回调函数，有多个重载版本，开发者只需要使重载一个FIX版本即可。
对于支持交易业务的FIX Initiator应用，通常要重写4个基本消息，即OnMessage(NewOrderSingle）、OnMessage(CancelRequest)、 OnMessage(ExecutionReport)、 OnMessage(CancelReject)，分别用于做委托、撤单、执行回报（包括对委托的拒绝）和对撤单的拒绝等4项业务。
#include "quickfix/Application.h"
#include "quickfix/MessageCracker.h"

class FIXApplication: public FIX::Application, public FIX::MessageCracker
{
public:
    /**************************************************
     *  reimplementation from Application
     * ***********************************************/
    /// Notification of a session begin created
    virtual void onCreate( const SessionID& )
    {

    }

    /// Notification of a session successfully logging on
    virtual void onLogon( const SessionID& )
    {
    }

    /// Notification of a session logging off or disconnecting
    virtual void onLogout( const SessionID& )
    {

    }

    /// Notification of admin message being sent to target
    virtual void toAdmin( Message&, const SessionID& )
    {

    }

    /// Notification of app message being sent to target
    void fromApp( const FIX::Message& message, const FIX::SessionID& sessionID )
    throw( FIX::FieldNotFound&, FIX::IncorrectDataFormat&, FIX::IncorrectTagValue&,
           FIX::UnsupportedMessageType& )
    {
        crack(message, sessionID);
    }

    /// Notification of admin message being received from target
    virtual void fromAdmin( const Message&, const SessionID& )
    throw ( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue,
            FIX::RejectLogon )
    {

    }

    /// Notification of app message being received from target
    virtual void fromApp( const Message&, const SessionID& )
    throw ( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue,
            FIX::UnsupportedMessageType )
    {

    }

    /**************************************************
     *  reimplementation from FIX42::MessageCracker
     * ***********************************************/
    virtual void onMessage( const FIX42::NewOrderSingle& message, 
                const FIX::SessionID& )
    {

    }

    virtual void onMessage( const FIX42::OrderCancelRequest& message, 
                        const FIX::SessionID& )
    {

    }

    virtual void onMessage( ExecutionReport&, const FIX::SessionID& )
    {

    }

    virtual void onMessage( OrderCancelReject&, const FIX::SessionID& )
    {

    }
};
2、FIX::SessionSettings
FIX应用配置使用FIX::SessionSettings读取FIX Session配置文件并传递给QuickFIX框架。一个FIX应用可以管理多个FIX Session，每个Session可以采用相同的FIX协议版本，也可以采用不同的版本。即使采用的是相同的FIX协议版本，不同FIX Session间也可以有FIX协议细节的差异，通过绑定FIX Session与FIX协议字典的方式来实现，即在Session配置文件中[Session]配置项中使用DataDictionary选项指定相应FIX字典文件来实现。
FIX::SessionSettings settings("sessionConfig.ini");
3、FIX::FileStoreFactory
QuickFIX提供了存储消息到文件的类FIX::FileLogFactory。消息文件存储的路径在Session配置中指定。
FIX::FileStoreFactory storeFactory(settings);
4、FIX::MessageStoreFactory
QuickFIX提供了给Fix Session持久化类型(如文件存储、数据存储，存储内容包括状态、创建时间、消息及其自己维护的发送序列号和接收序列号等）。
如果开发者要自定义持久化方式，可以自己定义MessageStoreFactory实现，并且自定义一种MessageStore。
5、FIX::FileLogFactory
QuickFIX提供了存储所有日志事件到文件的类FIX::FileLogFactory。
6、FIX::ScreenLogFactory
QuickFIX中提供了显示所有消息事件到标准输出的类ScreenLogFactory。
FIX::ScreenLogFactory logFactory(settings);
7、FIX::Message
QuickFIX中定义了不同FIX协议版本消息的基类FIX::Message，用于定义FIX消息的通用结构，不同的FIX消息版本的消息定义在不同的FIX命名空间内定义，如FIX42::Message。FIX::MessageCracker则继承了所有不同FIX协议版本的MessageCracker类，接收消息后生成具体FIX协议Message对象实现对消息进行处理。
8、FIX::Session
无论是FIX Initiator应用还是FIX Acceptor应用，在Fix Session初始化时，即在FIX::SessionFactory创建Fix Session后都会检查Fix Session时间范围。如果Fix Session启动不是当天有效的Session，则会重置Fix Session的发送序列号和接收序列号。(FIX规定一个Fix Session一般不超过24小时）。
FIX::Session部分接口定义如下：
class Session
{
public:
  static bool sendToTarget( Message& message,
                            const std::string& qualifier = "" )
  EXCEPT ( SessionNotFound );

  static bool sendToTarget( Message& message,
                            const SessionID& sessionID )
  EXCEPT ( SessionNotFound );

  static bool sendToTarget( Message&,
                            const SenderCompID& senderCompID,
                            const TargetCompID& targetCompID,
                            const std::string& qualifier = "" )
  EXCEPT ( SessionNotFound );

  static bool sendToTarget( Message& message,
                            const std::string& senderCompID,
                            const std::string& targetCompID,
                            const std::string& qualifier = "" )
  EXCEPT ( SessionNotFound );

  bool send( Message& );
  void next();
  void next( const UtcTimeStamp& timeStamp );
  void next( const std::string&, const UtcTimeStamp& timeStamp, bool queued = false );
  void next( const Message&, const UtcTimeStamp& timeStamp, bool queued = false );
};
next()方法是定时运行的一个方法，主要用于检测是否需要发心跳消息，是否需要发TEST消息，是否需要断开连接，是否需要产生LOGON（Initiator）。
next( const Message&)方法用于处理Session收到的FIX消息。
9、FIX::Acceptor
FIX::Acceptor用于从Session配置文件读取信息创建和管理本Acceptor支持的FIX Session，具体FIX Session的TCP连接管理、数据读写由具体的SocketAcceptor、SSLSocketAcceptor、ThreadedSocketAcceptor、ThreadedSSLSocketAcceptor实现。
FIX::Acceptor* acceptor = new FIX::SocketAcceptor(application, storeFactory, 
                                                  settings, logFactory);
10、FIX::Initiator
FIX::Initiator用于从Session配置文件读取信息创建和管理本Initiator支持的FIX Session，具体FIX Session的TCP连接管理、数据读写由具体的SocketInitiator、SSLSocketInitiator、ThreadedSocketInitiator、ThreadedSSLSocketInitiator实现。
FIX::Initiator * initiator = new FIX::SocketInitiator(application, 
                                                      storeFactory, 
                                                      settings, logFactory);
四、FIX Acceptor应用开发
1、FIX Acceptor应用简介
FIX Acceptor应用通常用于FIX网关，部署在卖方侧。
2、FIX Acceptor应用创建
（1）创建FIX Session配置对象
FIX::SessionSettings settings(sessionFile);
（2）创建FIX应用：
Application application;
创建日志工厂：
LogFactory logFactory(settings);
创建消息存储文件工厂：
FIX::FileStoreFactory storeFactory(settings);
创建Acceptor服务端：
FIX::Acceptor* acceptor = new SocketAcceptor(application, storeFactory, 
                                             settings, logFactory);
启动SocketAcceptor：
acceptor->start();
3、FIX Acceptor应用示例
Executor示例演示了接收订单请求并返回成交回执的FIX Acceptor应用。
Application.h文件：
#ifndef EXECUTOR_APPLICATION_H
#define EXECUTOR_APPLICATION_H

#include "quickfix/Application.h"
#include "quickfix/MessageCracker.h"
#include "quickfix/Values.h"
#include "quickfix/Utility.h"
#include "quickfix/Mutex.h"

#include "quickfix/fix40/NewOrderSingle.h"
#include "quickfix/fix41/NewOrderSingle.h"
#include "quickfix/fix42/NewOrderSingle.h"
#include "quickfix/fix43/NewOrderSingle.h"
#include "quickfix/fix44/NewOrderSingle.h"
#include "quickfix/fix50/NewOrderSingle.h"

class Application
: public FIX::Application, public FIX::MessageCracker
{
public:
  Application() : m_orderID(0), m_execID(0) {}

  // Application overloads
  void onCreate( const FIX::SessionID& );
  void onLogon( const FIX::SessionID& sessionID );
  void onLogout( const FIX::SessionID& sessionID );
  void toAdmin( FIX::Message&, const FIX::SessionID& );
  void toApp( FIX::Message&, const FIX::SessionID& )
    EXCEPT( FIX::DoNotSend );

  void fromAdmin( const FIX::Message&, const FIX::SessionID& )
    EXCEPT( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, 
            FIX::RejectLogon );

  void fromApp( const FIX::Message& message, const FIX::SessionID& sessionID )
    EXCEPT( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, 
            FIX::UnsupportedMessageType );

  // MessageCracker overloads
  void onMessage( const FIX40::NewOrderSingle&, const FIX::SessionID& );
  void onMessage( const FIX41::NewOrderSingle&, const FIX::SessionID& );
  void onMessage( const FIX42::NewOrderSingle&, const FIX::SessionID& );
  void onMessage( const FIX43::NewOrderSingle&, const FIX::SessionID& );
  void onMessage( const FIX44::NewOrderSingle&, const FIX::SessionID& );
  void onMessage( const FIX50::NewOrderSingle&, const FIX::SessionID& );

  std::string genOrderID() {
    std::stringstream stream;
    stream << ++m_orderID;
    return stream.str();
  }

  std::string genExecID() {
    std::stringstream stream;
    stream << ++m_execID;
    return stream.str();
  }
private:
  int m_orderID, m_execID;
};

#endif
Application.cpp文件：
#include "config.h"
#include "Application.h"
#include "quickfix/Session.h"

#include "quickfix/fix40/ExecutionReport.h"
#include "quickfix/fix41/ExecutionReport.h"
#include "quickfix/fix42/ExecutionReport.h"
#include "quickfix/fix43/ExecutionReport.h"
#include "quickfix/fix44/ExecutionReport.h"
#include "quickfix/fix50/ExecutionReport.h"

void Application::onCreate( const FIX::SessionID& sessionID ) {}
void Application::onLogon( const FIX::SessionID& sessionID ) {}
void Application::onLogout( const FIX::SessionID& sessionID ) {}
void Application::toAdmin( FIX::Message& message,
                           const FIX::SessionID& sessionID ) {}
void Application::toApp( FIX::Message& message,
                         const FIX::SessionID& sessionID )
EXCEPT( FIX::DoNotSend ) {}


void Application::fromAdmin( const FIX::Message& message,
                             const FIX::SessionID& sessionID )
EXCEPT( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, FIX::RejectLogon ) {}


void Application::fromApp( const FIX::Message& message,
                           const FIX::SessionID& sessionID )
EXCEPT( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, FIX::UnsupportedMessageType )
{ crack( message, sessionID ); }



void Application::onMessage( const FIX40::NewOrderSingle& message,
                             const FIX::SessionID& sessionID )
{

  FIX::Symbol symbol;
  FIX::Side side;
  FIX::OrdType ordType;
  FIX::OrderQty orderQty;
  FIX::Price price;
  FIX::ClOrdID clOrdID;
  FIX::Account account;

  message.get( ordType );

  if ( ordType != FIX::OrdType_LIMIT )
    throw FIX::IncorrectTagValue( ordType.getField() );

  message.get( symbol );
  message.get( side );
  message.get( orderQty );
  message.get( price );
  message.get( clOrdID );

  FIX40::ExecutionReport executionReport = FIX40::ExecutionReport
      ( FIX::OrderID( genOrderID() ),
        FIX::ExecID( genExecID() ),
        FIX::ExecTransType( FIX::ExecTransType_NEW ),
        FIX::OrdStatus( FIX::OrdStatus_FILLED ),
        symbol,
        side,
        orderQty,
        FIX::LastShares( orderQty ),
        FIX::LastPx( price ),
        FIX::CumQty( orderQty ),
        FIX::AvgPx( price ) );

  executionReport.set( clOrdID );

  if( message.isSet(account) )
    executionReport.setField( message.get(account) );

  try
  {
    FIX::Session::sendToTarget( executionReport, sessionID );
  }
  catch ( FIX::SessionNotFound& ) {}
}

void Application::onMessage( const FIX41::NewOrderSingle& message,
                             const FIX::SessionID& sessionID )
{

  FIX::Symbol symbol;
  FIX::Side side;
  FIX::OrdType ordType;
  FIX::OrderQty orderQty;
  FIX::Price price;
  FIX::ClOrdID clOrdID;
  FIX::Account account;

  message.get( ordType );

  if ( ordType != FIX::OrdType_LIMIT )
    throw FIX::IncorrectTagValue( ordType.getField() );

  message.get( symbol );
  message.get( side );
  message.get( orderQty );
  message.get( price );
  message.get( clOrdID );

  FIX41::ExecutionReport executionReport = FIX41::ExecutionReport
      ( FIX::OrderID( genOrderID() ),
        FIX::ExecID( genExecID() ),
        FIX::ExecTransType( FIX::ExecTransType_NEW ),
        FIX::ExecType( FIX::ExecType_FILL ),
        FIX::OrdStatus( FIX::OrdStatus_FILLED ),
        symbol,
        side,
        orderQty,
        FIX::LastShares( orderQty ),
        FIX::LastPx( price ),
        FIX::LeavesQty( 0 ),
        FIX::CumQty( orderQty ),
        FIX::AvgPx( price ) );

  executionReport.set( clOrdID );

  if( message.isSet(account) )
    executionReport.setField( message.get(account) );

  try
  {
    FIX::Session::sendToTarget( executionReport, sessionID );
  }
  catch ( FIX::SessionNotFound& ) {}
}

void Application::onMessage( const FIX42::NewOrderSingle& message,
                             const FIX::SessionID& sessionID )
{
  FIX::Symbol symbol;
  FIX::Side side;
  FIX::OrdType ordType;
  FIX::OrderQty orderQty;
  FIX::Price price;
  FIX::ClOrdID clOrdID;
  FIX::Account account;

  message.get( ordType );

  if ( ordType != FIX::OrdType_LIMIT )
    throw FIX::IncorrectTagValue( ordType.getField() );

  message.get( symbol );
  message.get( side );
  message.get( orderQty );
  message.get( price );
  message.get( clOrdID );

  FIX42::ExecutionReport executionReport = FIX42::ExecutionReport
      ( FIX::OrderID( genOrderID() ),
        FIX::ExecID( genExecID() ),
        FIX::ExecTransType( FIX::ExecTransType_NEW ),
        FIX::ExecType( FIX::ExecType_FILL ),
        FIX::OrdStatus( FIX::OrdStatus_FILLED ),
        symbol,
        side,
        FIX::LeavesQty( 0 ),
        FIX::CumQty( orderQty ),
        FIX::AvgPx( price ) );

  executionReport.set( clOrdID );
  executionReport.set( orderQty );
  executionReport.set( FIX::LastShares( orderQty ) );
  executionReport.set( FIX::LastPx( price ) );

  if( message.isSet(account) )
    executionReport.setField( message.get(account) );

  try
  {
    FIX::Session::sendToTarget( executionReport, sessionID );
  }
  catch ( FIX::SessionNotFound& ) {}
}

void Application::onMessage( const FIX43::NewOrderSingle& message,
                             const FIX::SessionID& sessionID )
{
  FIX::Symbol symbol;
  FIX::Side side;
  FIX::OrdType ordType;
  FIX::OrderQty orderQty;
  FIX::Price price;
  FIX::ClOrdID clOrdID;
  FIX::Account account;

  message.get( ordType );

  if ( ordType != FIX::OrdType_LIMIT )
    throw FIX::IncorrectTagValue( ordType.getField() );

  message.get( symbol );
  message.get( side );
  message.get( orderQty );
  message.get( price );
  message.get( clOrdID );

  FIX43::ExecutionReport executionReport = FIX43::ExecutionReport
      ( FIX::OrderID( genOrderID() ),
        FIX::ExecID( genExecID() ),
        FIX::ExecType( FIX::ExecType_FILL ),
        FIX::OrdStatus( FIX::OrdStatus_FILLED ),
        side,
        FIX::LeavesQty( 0 ),
        FIX::CumQty( orderQty ),
        FIX::AvgPx( price ) );

  executionReport.set( clOrdID );
  executionReport.set( symbol );
  executionReport.set( orderQty );
  executionReport.set( FIX::LastQty( orderQty ) );
  executionReport.set( FIX::LastPx( price ) );

  if( message.isSet(account) )
    executionReport.setField( message.get(account) );

  try
  {
    FIX::Session::sendToTarget( executionReport, sessionID );
  }
  catch ( FIX::SessionNotFound& ) {}
}



void Application::onMessage( const FIX44::NewOrderSingle& message,
                             const FIX::SessionID& sessionID )
{
  FIX::Symbol symbol;
  FIX::Side side;
  FIX::OrdType ordType;
  FIX::OrderQty orderQty;
  FIX::Price price;
  FIX::ClOrdID clOrdID;
  FIX::Account account;

  message.get( ordType );

  if ( ordType != FIX::OrdType_LIMIT )
    throw FIX::IncorrectTagValue( ordType.getField() );

  message.get( symbol );
  message.get( side );
  message.get( orderQty );
  message.get( price );
  message.get( clOrdID );

  FIX44::ExecutionReport executionReport = FIX44::ExecutionReport
      ( FIX::OrderID( genOrderID() ),
        FIX::ExecID( genExecID() ),
        FIX::ExecType( FIX::ExecType_TRADE ),
        FIX::OrdStatus( FIX::OrdStatus_FILLED ),
        side,
        FIX::LeavesQty( 0 ),
        FIX::CumQty( orderQty ),
        FIX::AvgPx( price ) );

  executionReport.set( clOrdID );
  executionReport.set( symbol );
  executionReport.set( orderQty );
  executionReport.set( FIX::LastQty( orderQty ) );
  executionReport.set( FIX::LastPx( price ) );

  if( message.isSet(account) )
    executionReport.setField( message.get(account) );

  try
  {
    FIX::Session::sendToTarget( executionReport, sessionID );
  }
  catch ( FIX::SessionNotFound& ) {}
}



void Application::onMessage( const FIX50::NewOrderSingle& message,
                             const FIX::SessionID& sessionID )
{
  FIX::Symbol symbol;
  FIX::Side side;
  FIX::OrdType ordType;
  FIX::OrderQty orderQty;
  FIX::Price price;
  FIX::ClOrdID clOrdID;
  FIX::Account account;

  message.get( ordType );

  if ( ordType != FIX::OrdType_LIMIT )
    throw FIX::IncorrectTagValue( ordType.getField() );

  message.get( symbol );
  message.get( side );
  message.get( orderQty );
  message.get( price );
  message.get( clOrdID );

  FIX50::ExecutionReport executionReport = FIX50::ExecutionReport
      ( FIX::OrderID( genOrderID() ),
        FIX::ExecID( genExecID() ),
        FIX::ExecType( FIX::ExecType_TRADE ),
        FIX::OrdStatus( FIX::OrdStatus_FILLED ),
        side,
        FIX::LeavesQty( 0 ),
        FIX::CumQty( orderQty ) );

 
  executionReport.set( clOrdID );
  executionReport.set( symbol );
  executionReport.set( orderQty );
  executionReport.set( FIX::LastQty( orderQty ) );
  executionReport.set( FIX::LastPx( price ) );
  executionReport.set( FIX::AvgPx( price ) );

  if( message.isSet(account) )
    executionReport.setField( message.get(account) );

  try
  {
    FIX::Session::sendToTarget( executionReport, sessionID );
  }
  catch ( FIX::SessionNotFound& ) {}
}
main.cpp文件：
#include "config.h"
#include "quickfix/FileStore.h"
#include "quickfix/SocketAcceptor.h"
#include "quickfix/Log.h"
#include "quickfix/SessionSettings.h"
#include "Application.h"
#include <string>
#include <iostream>
#include <fstream>

void wait()
{
  std::cout << "Type Ctrl-C to quit" << std::endl;
  while(true)
  {
    FIX::process_sleep(1);
  }
}

int main( int argc, char** argv )
{
  if ( argc < 2 )
  {
    std::cout << "usage: " << argv[ 0 ]
    << " FILE." << std::endl;
    return 0;
  }

  std::string file = argv[ 1 ];
  FIX::Acceptor * acceptor = 0;
  try
  {
    FIX::SessionSettings settings( file );

    Application application;
    FIX::FileStoreFactory storeFactory( settings );
    FIX::ScreenLogFactory logFactory( settings );
    acceptor = new FIX::SocketAcceptor ( application, storeFactory, 
                                         settings, logFactory );
    acceptor->start();
    wait();
    acceptor->stop();
    delete acceptor;
    return 0;
  }
  catch ( std::exception & e )
  {
    std::cout << e.what() << std::endl;
    delete acceptor;
    return 1;
  }
}
五、FIX Initiator应用开发
1、FIX Initiator应用简介
FIX Initiator应用通常用于交易客户端，部署在买方侧。
2、FIX Initiator应用创建
（1）创建FIX Session配置对象
FIX::SessionSettings settings(sessionFile);
（2）创建FIX应用：
Application application;
创建日志工厂：
LogFactory logFactory(settings);
创建消息存储文件工厂：
FIX::FileStoreFactory storeFactory(settings);
创建Acceptor服务端：
FIX::Initiator* client= new SocketInitiator(application, storeFactory,
                                            settings, logFactory);
启动SocketInitiator：
client->start();
3、FIX Initiator应用示例
tradeclient交易客户端
Application.h文件：
#ifndef TRADECLIENT_APPLICATION_H
#define TRADECLIENT_APPLICATION_H

#include "quickfix/Application.h"
#include "quickfix/MessageCracker.h"
#include "quickfix/Values.h"
#include "quickfix/Mutex.h"

#include "quickfix/fix40/NewOrderSingle.h"
#include "quickfix/fix40/ExecutionReport.h"
#include "quickfix/fix40/OrderCancelRequest.h"
#include "quickfix/fix40/OrderCancelReject.h"
#include "quickfix/fix40/OrderCancelReplaceRequest.h"

#include "quickfix/fix41/NewOrderSingle.h"
#include "quickfix/fix41/ExecutionReport.h"
#include "quickfix/fix41/OrderCancelRequest.h"
#include "quickfix/fix41/OrderCancelReject.h"
#include "quickfix/fix41/OrderCancelReplaceRequest.h"

#include "quickfix/fix42/NewOrderSingle.h"
#include "quickfix/fix42/ExecutionReport.h"
#include "quickfix/fix42/OrderCancelRequest.h"
#include "quickfix/fix42/OrderCancelReject.h"
#include "quickfix/fix42/OrderCancelReplaceRequest.h"

#include "quickfix/fix43/NewOrderSingle.h"
#include "quickfix/fix43/ExecutionReport.h"
#include "quickfix/fix43/OrderCancelRequest.h"
#include "quickfix/fix43/OrderCancelReject.h"
#include "quickfix/fix43/OrderCancelReplaceRequest.h"
#include "quickfix/fix43/MarketDataRequest.h"

#include "quickfix/fix44/NewOrderSingle.h"
#include "quickfix/fix44/ExecutionReport.h"
#include "quickfix/fix44/OrderCancelRequest.h"
#include "quickfix/fix44/OrderCancelReject.h"
#include "quickfix/fix44/OrderCancelReplaceRequest.h"
#include "quickfix/fix44/MarketDataRequest.h"

#include "quickfix/fix50/NewOrderSingle.h"
#include "quickfix/fix50/ExecutionReport.h"
#include "quickfix/fix50/OrderCancelRequest.h"
#include "quickfix/fix50/OrderCancelReject.h"
#include "quickfix/fix50/OrderCancelReplaceRequest.h"
#include "quickfix/fix50/MarketDataRequest.h"

#include <queue>

class Application :
      public FIX::Application,
      public FIX::MessageCracker
{
public:
  void run();

private:
  void onCreate( const FIX::SessionID& ) {}
  void onLogon( const FIX::SessionID& sessionID );
  void onLogout( const FIX::SessionID& sessionID );
  void toAdmin( FIX::Message&, const FIX::SessionID& ) {}
  void toApp( FIX::Message&, const FIX::SessionID& )
  EXCEPT( FIX::DoNotSend );

  void fromAdmin( const FIX::Message&, const FIX::SessionID& )
  EXCEPT( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, 
          FIX::RejectLogon ) {}

  void fromApp( const FIX::Message& message, const FIX::SessionID& sessionID )
  EXCEPT( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, 
          FIX::UnsupportedMessageType );

  void onMessage( const FIX42::ExecutionReport&, const FIX::SessionID& );
  void onMessage( const FIX42::OrderCancelReject&, const FIX::SessionID& );

  void queryEnterOrder();
  void queryCancelOrder();
  void queryReplaceOrder();
  FIX42::NewOrderSingle queryNewOrderSingle42();
  FIX42::OrderCancelRequest queryOrderCancelRequest42();
  FIX42::OrderCancelReplaceRequest queryCancelReplaceRequest42();

  void queryHeader( FIX::Header& header );
  char queryAction();
  int queryVersion();
  bool queryConfirm( const std::string& query );

  FIX::SenderCompID querySenderCompID();
  FIX::TargetCompID queryTargetCompID();
  FIX::TargetSubID queryTargetSubID();
  FIX::ClOrdID queryClOrdID();
  FIX::OrigClOrdID queryOrigClOrdID();
  FIX::Symbol querySymbol();
  FIX::Side querySide();
  FIX::OrderQty queryOrderQty();
  FIX::OrdType queryOrdType();
  FIX::Price queryPrice();
  FIX::StopPx queryStopPx();
  FIX::TimeInForce queryTimeInForce();
};


#endif
Application.cpp文件：
#include "config.h"
#include "Application.h"
#include "quickfix/Session.h"
#include <iostream>

void Application::onLogon( const FIX::SessionID& sessionID )
{
  std::cout << std::endl << "Logon - " << sessionID << std::endl;
}

void Application::onLogout( const FIX::SessionID& sessionID )
{
  std::cout << std::endl << "Logout - " << sessionID << std::endl;
}

void Application::fromApp( const FIX::Message& message, 
                           const FIX::SessionID& sessionID )
EXCEPT( FIX::FieldNotFound, FIX::IncorrectDataFormat, 
        FIX::IncorrectTagValue, FIX::UnsupportedMessageType )
{
  crack( message, sessionID );
  std::cout << std::endl << "IN: " << message << std::endl;
}

void Application::toApp( FIX::Message& message, const FIX::SessionID& sessionID )
EXCEPT( FIX::DoNotSend )
{
  try
  {
    FIX::PossDupFlag possDupFlag;
    message.getHeader().getField( possDupFlag );
    if ( possDupFlag ) throw FIX::DoNotSend();
  }
  catch ( FIX::FieldNotFound& ) {}

  std::cout << std::endl
  << "OUT: " << message << std::endl;
}


void Application::onMessage
( const FIX42::ExecutionReport&, const FIX::SessionID& ) {}

void Application::onMessage
( const FIX42::OrderCancelReject&, const FIX::SessionID& ) {}

void Application::run()
{
  while ( true )
  {
    try
    {
      char action = queryAction();

      if ( action == '1' )
        queryEnterOrder();
      else if ( action == '2' )
        queryCancelOrder();
      else if ( action == '3' )
        queryReplaceOrder();
      else if ( action == '5' )
        break;
    }
    catch ( std::exception & e )
    {
      std::cout << "Message Not Sent: " << e.what();
    }
  }
}

void Application::queryEnterOrder()
{
  int version = queryVersion();
  std::cout << "\nNewOrderSingle\n";
  FIX::Message order;
  switch ( version ) {
  case 42:
    order = queryNewOrderSingle42();
    break;
  default:
    std::cerr << "No test for version " << version << std::endl;
    break;
  }

  if ( queryConfirm( "Send order" ) )
    FIX::Session::sendToTarget( order );
}



void Application::queryCancelOrder()
{
  int version = queryVersion();
  std::cout << "\nOrderCancelRequest\n";
  FIX::Message cancel;

  switch ( version ) {
  case 42:
    cancel = queryOrderCancelRequest42();
    break;
  default:
    std::cerr << "No test for version " << version << std::endl;
    break;
  }

  if ( queryConfirm( "Send cancel" ) )
    FIX::Session::sendToTarget( cancel );
}

void Application::queryReplaceOrder()
{
  int version = queryVersion();
  std::cout << "\nCancelReplaceRequest\n";
  FIX::Message replace;

  switch ( version ) {
  case 42:
    replace = queryCancelReplaceRequest42();
    break;
  default:
    std::cerr << "No test for version " << version << std::endl;
    break;
  }

  if ( queryConfirm( "Send replace" ) )
    FIX::Session::sendToTarget( replace );
}

FIX42::NewOrderSingle Application::queryNewOrderSingle42()
{
  FIX::OrdType ordType;

  FIX42::NewOrderSingle newOrderSingle(
    queryClOrdID(), FIX::HandlInst( '1' ), querySymbol(), querySide(),
    FIX::TransactTime(), ordType = queryOrdType() );

  newOrderSingle.set( queryOrderQty() );
  newOrderSingle.set( queryTimeInForce() );
  if ( ordType == FIX::OrdType_LIMIT || ordType == FIX::OrdType_STOP_LIMIT )
    newOrderSingle.set( queryPrice() );
  if ( ordType == FIX::OrdType_STOP || ordType == FIX::OrdType_STOP_LIMIT )
    newOrderSingle.set( queryStopPx() );

  queryHeader( newOrderSingle.getHeader() );
  return newOrderSingle;
}


FIX42::OrderCancelRequest Application::queryOrderCancelRequest42()
{
  FIX42::OrderCancelRequest orderCancelRequest( queryOrigClOrdID(),
      queryClOrdID(), querySymbol(), querySide(), FIX::TransactTime() );

  orderCancelRequest.set( queryOrderQty() );
  queryHeader( orderCancelRequest.getHeader() );
  return orderCancelRequest;
}

FIX42::OrderCancelReplaceRequest Application::queryCancelReplaceRequest42()
{
  FIX42::OrderCancelReplaceRequest cancelReplaceRequest(
    queryOrigClOrdID(), queryClOrdID(), FIX::HandlInst( '1' ),
    querySymbol(), querySide(), FIX::TransactTime(), queryOrdType() );

  if ( queryConfirm( "New price" ) )
    cancelReplaceRequest.set( queryPrice() );
  if ( queryConfirm( "New quantity" ) )
    cancelReplaceRequest.set( queryOrderQty() );

  queryHeader( cancelReplaceRequest.getHeader() );
  return cancelReplaceRequest;
}

void Application::queryHeader( FIX::Header& header )
{
  header.setField( querySenderCompID() );
  header.setField( queryTargetCompID() );

  if ( queryConfirm( "Use a TargetSubID" ) )
    header.setField( queryTargetSubID() );
}

char Application::queryAction()
{
  char value;
  std::cout << std::endl
  << "1) Enter Order" << std::endl
  << "2) Cancel Order" << std::endl
  << "3) Replace Order" << std::endl
  << "4) Market data test" << std::endl
  << "5) Quit" << std::endl
  << "Action: ";
  std::cin >> value;
  switch ( value )
  {
    case '1': case '2': case '3': case '4': case '5': break;
    default: throw std::exception();
  }
  return value;
}

int Application::queryVersion()
{
  char value;
  std::cout << std::endl
  << "1) FIX.4.0" << std::endl
  << "2) FIX.4.1" << std::endl
  << "3) FIX.4.2" << std::endl
  << "4) FIX.4.3" << std::endl
  << "5) FIX.4.4" << std::endl
  << "6) FIXT.1.1 (FIX.5.0)" << std::endl
  << "BeginString: ";
  std::cin >> value;
  switch ( value )
  {
    case '1': return 40;
    case '2': return 41;
    case '3': return 42;
    case '4': return 43;
    case '5': return 44;
    case '6': return 50;
    default: throw std::exception();
  }
}

bool Application::queryConfirm( const std::string& query )
{
  std::string value;
  std::cout << std::endl << query << "?: ";
  std::cin >> value;
  return toupper( *value.c_str() ) == 'Y';
}

FIX::SenderCompID Application::querySenderCompID()
{
  std::string value;
  std::cout << std::endl << "SenderCompID: ";
  std::cin >> value;
  return FIX::SenderCompID( value );
}

FIX::TargetCompID Application::queryTargetCompID()
{
  std::string value;
  std::cout << std::endl << "TargetCompID: ";
  std::cin >> value;
  return FIX::TargetCompID( value );
}

FIX::TargetSubID Application::queryTargetSubID()
{
  std::string value;
  std::cout << std::endl << "TargetSubID: ";
  std::cin >> value;
  return FIX::TargetSubID( value );
}

FIX::ClOrdID Application::queryClOrdID()
{
  std::string value;
  std::cout << std::endl << "ClOrdID: ";
  std::cin >> value;
  return FIX::ClOrdID( value );
}

FIX::OrigClOrdID Application::queryOrigClOrdID()
{
  std::string value;
  std::cout << std::endl << "OrigClOrdID: ";
  std::cin >> value;
  return FIX::OrigClOrdID( value );
}

FIX::Symbol Application::querySymbol()
{
  std::string value;
  std::cout << std::endl << "Symbol: ";
  std::cin >> value;
  return FIX::Symbol( value );
}

FIX::Side Application::querySide()
{
  char value;
  std::cout << std::endl
  << "1) Buy" << std::endl
  << "2) Sell" << std::endl
  << "3) Sell Short" << std::endl
  << "4) Sell Short Exempt" << std::endl
  << "5) Cross" << std::endl
  << "6) Cross Short" << std::endl
  << "7) Cross Short Exempt" << std::endl
  << "Side: ";

  std::cin >> value;
  switch ( value )
  {
    case '1': return FIX::Side( FIX::Side_BUY );
    case '2': return FIX::Side( FIX::Side_SELL );
    case '3': return FIX::Side( FIX::Side_SELL_SHORT );
    case '4': return FIX::Side( FIX::Side_SELL_SHORT_EXEMPT );
    case '5': return FIX::Side( FIX::Side_CROSS );
    case '6': return FIX::Side( FIX::Side_CROSS_SHORT );
    case '7': return FIX::Side( 'A' );
    default: throw std::exception();
  }
}

FIX::OrderQty Application::queryOrderQty()
{
  long value;
  std::cout << std::endl << "OrderQty: ";
  std::cin >> value;
  return FIX::OrderQty( value );
}

FIX::OrdType Application::queryOrdType()
{
  char value;
  std::cout << std::endl
  << "1) Market" << std::endl
  << "2) Limit" << std::endl
  << "3) Stop" << std::endl
  << "4) Stop Limit" << std::endl
  << "OrdType: ";

  std::cin >> value;
  switch ( value )
  {
    case '1': return FIX::OrdType( FIX::OrdType_MARKET );
    case '2': return FIX::OrdType( FIX::OrdType_LIMIT );
    case '3': return FIX::OrdType( FIX::OrdType_STOP );
    case '4': return FIX::OrdType( FIX::OrdType_STOP_LIMIT );
    default: throw std::exception();
  }
}

FIX::Price Application::queryPrice()
{
  double value;
  std::cout << std::endl << "Price: ";
  std::cin >> value;
  return FIX::Price( value );
}

FIX::StopPx Application::queryStopPx()
{
  double value;
  std::cout << std::endl << "StopPx: ";
  std::cin >> value;
  return FIX::StopPx( value );
}

FIX::TimeInForce Application::queryTimeInForce()
{
  char value;
  std::cout << std::endl
  << "1) Day" << std::endl
  << "2) IOC" << std::endl
  << "3) OPG" << std::endl
  << "4) GTC" << std::endl
  << "5) GTX" << std::endl
  << "TimeInForce: ";

  std::cin >> value;
  switch ( value )
  {
    case '1': return FIX::TimeInForce( FIX::TimeInForce_DAY );
    case '2': return FIX::TimeInForce( FIX::TimeInForce_IMMEDIATE_OR_CANCEL );
    case '3': return FIX::TimeInForce( FIX::TimeInForce_AT_THE_OPENING );
    case '4': return FIX::TimeInForce( FIX::TimeInForce_GOOD_TILL_CANCEL );
    case '5': return FIX::TimeInForce( FIX::TimeInForce_GOOD_TILL_CROSSING );
    default: throw std::exception();
  }
}
main.cpp文件：
#include "config.h"
#include "quickfix/FileStore.h"
#include "quickfix/SocketInitiator.h"
#include "quickfix/SessionSettings.h"
#include "quickfix/Log.h"
#include "Application.h"
#include <string>
#include <iostream>
#include <fstream>

int main( int argc, char** argv )
{
  if ( argc < 2 )
  {
    std::cout << "usage: " << argv[ 0 ]
    << " FILE." << std::endl;
    return 0;
  }

  std::string file = argv[ 1 ];

  FIX::Initiator * initiator = 0;
  try
  {
    FIX::SessionSettings settings( file );

    Application application;
    FIX::FileStoreFactory storeFactory( settings );
    FIX::ScreenLogFactory logFactory( settings );
    initiator = new FIX::SocketInitiator( application, storeFactory, 
                                          settings, logFactory );
    initiator->start();
    application.run();
    initiator->stop();
    delete initiator;

    return 0;

  }
  catch ( std::exception & e )
  {
    std::cout << e.what();
    delete initiator;
    return 1;
  }
}





交易系统开发（十二）——QuickFIX官方文档

一、QuickFIX编译构建
1、Windows
使用VS Studio打开quickfix_vs12.sln、quickfix_vs14.sln、quickfix_vs15.sln。
链接库：链接lib\quickfix.lib和lib\debug\quickfix.lib到应用。
头文件：拷贝头文件到include目录。
编译控制：src目录的config_windows.h文件用于控制编译时选项。
#define HAVE_STLPORT 1
使用stlport替换Visual C++ STL进行编译。
#define HAVE_ODBC 1
QuickFIX支持ODBC数据库。
#define HAVE_MYSQL 1
QuickFIX支持MySQL。如果开启，MySQL的include和lib目录必须在Visual Studio的搜索路径内。
#define HAVE_POSTGRESQL 1
QuickFIX支持PostgreSQL数据库，如果开启，则PostgreSQL的include和lib目录必须在Visual Studio的搜索路径内。
2、Linux
Linux、Solaris、FreeBSD、Mac OS X使用相同的编译构建流程。
编译配置：
configure
编译配置选项如下：
--prefix=directory：指定安装目录。
--with-python2：编译Python2 API
--with-python3：编译Python3 API
--with-ruby：编译Ruby API
--with-mysql：支持MySQL
--with-postgresql：支持PostgreSQL
--with-stlport=directory：使用stlport进行编译，替换标准的GCC STL实现。
编译：
make
安装：
make install
二、QuickFIX数据库支持
1、MySQL
运行src/sql/mysql目录中的创建脚本，需要传递创建数据库的授权用户，必须安装MySQL数据库。
create.sh mysql

create.bat mysql
2、MSSQL
必须安装MSSQL，运行src/sql/mssql目录的创建脚本，必须传递创建MSSQL数据库的用户。
create.bat sa
3、PostgreSQL
必须安装PostgreSQL，运行src/sql/postgresql脚本，必须传递创建PostgreSQL数据库的用户。
create.sh postgres

create.bat postgres
三、测试
1、测试
QuickFIX开发由功能测试和单元测试组件驱动。
2、Windows
（1）单元测试
test目录下执行：
runut release [port]
端口用于测试socket功能。
（2）验证测试
在test目录执行：
runat release [port]

runat_threaded release [port]
端口用于Socket Server监听连接。
3、Linux
Linux、Solaris、FreeBSD、Mac OS X中单元测试和功能测试相同。
（1）单元测试
test目录执行：
runut.sh [port]
端口用于测试Socket功能，如果QuickFIX要支持数据库，需要更新数据库设置cfg/ut.cfg。
（2）验证测试
在test目录执行：
runat.sh [port]

runat_threaded.sh [port]
端口用于监听Socket服务器的连接。
四、工程设置
1、Windows
在Microsoft Visual Studio打开project | properties。
（1）设置C/C++ | Code Generation | Enable C++ Exceptions为Yes。
（2）C/C++ | Code Generation | Runtime Library设置Multithreaded DLL或Debug Multithreaded DLL。
（3）C/C++ | General | Additional Include Directories增加quickfix根目录。
（4）Linker | Input | Additional Dependencies必须包含quickfix.lib和ws2_32.lib。
（5）Linker | General | Additional Library Directories增加quickfix/lib目录。
2、Linux
（1）使用-fexceptions选项开启异常。
（2）推荐使用-finline-functions选项优化。
（3）QuickFIX必须使用-lquickfix选项进行链接。如果QuickFIX使用pthreads、libxml，则使用-lpthread选项、-lxml2选项、-lz选项链接。
（4）Solaris系统必须使用-lnsl选项和-lsocket选项链接。
五、应用创建
1、Application接口
使用QuickFIX创建FIX应用只需要实现QuickFIX Application接口。QuickFIX Application接口如下：
namespace FIX
{
  class Application
  {
  public:
    virtual ~Application() {};
    virtual void onCreate( const SessionID& ) = 0;
    virtual void onLogon( const SessionID& ) = 0;
    virtual void onLogout( const SessionID& ) = 0;
    virtual void toAdmin( Message&, const SessionID& ) = 0;
    virtual void toApp( Message&, const SessionID& )
      throw( DoNotSend ) = 0;

    virtual void fromAdmin( const Message&, const SessionID& )
      throw( FieldNotFound, IncorrectDataFormat, IncorrectTagValue, RejectLogon ) = 0;

    virtual void fromApp( const Message&, const SessionID& )
      throw( FieldNotFound, IncorrectDataFormat, IncorrectTagValue, 
             UnsupportedMessageType ) = 0;
  };
}
onCreate：QuickFIX创建Session时调用。无论对等方是否连接，在应用程序生命周期内Session会一直存在。一旦Session建立，并可以向其发送消息。如果没有登录，消息会在对等方建立连接时发送。
onLogon：通知和对等方的有效登录连接已经建立。连接建立，FIX logon进程完成双方有效登录消息交换后调用。
onLogout：通知FIX Session不再在线。正常登出或网络连接中断时调用。
toAdmin：可以查看FIX引擎发送给对等方的管理类型消息，应用程序通常不使用，可以在管理类型消息发送前增加字段。
toApp：发送到对等方的应用类型消息的回调函数，如果函数内抛出DoNotSend异常，则应用程序不会发送消息。
fromAdmin：通知FIX Session，对等方已经发送一条管理类型消息到FIX引擎，用于进行验证密码等登录消息的其它验证操作。抛出RejectLogon异常将会断开与对等方连接。
fromApp：用于接收应用类型消息。如果应用程序是卖方OMS，本函数内可以获取新的订单请求；如果应用程序是买方应用，则在本函数内获取成交回报。如果抛出FieldNotFound异常，对等方会收到表明消息缺失必需字段拒绝通知。如果试图索引缺失字段，Message类会抛出异常，因此不需要显式抛出异常。可以抛出UnsupportedMessageType异常，但会导致对等方收到拒绝通知，通知对等方本地应用程序无法处理这些类型的消息。当字段包含不支持的值时会抛出IncorrectTagValue异常。
2、示例
FIX Acceptor示例代码如下：
#include "quickfix/FileStore.h"
#include "quickfix/FileLog.h"
#include "quickfix/SocketAcceptor.h"
#include "quickfix/Session.h"
#include "quickfix/SessionSettings.h"
#include "quickfix/Application.h"

int main( int argc, char** argv )
{
  try
  {
    if(argc < 2) return 1;
    std::string fileName = argv[1];

    FIX::SessionSettings settings(fileName);

    MyApplication application;
    FIX::FileStoreFactory storeFactory(settings);
    FIX::FileLogFactory logFactory(settings);
    FIX::SocketAcceptor acceptor
      (application, storeFactory, settings, logFactory /*optional*/);

    acceptor.start();
    // while( condition == true ) { do something; }
    acceptor.stop();
    return 0;
  }
  catch(FIX::ConfigError& e)
  {
    std::cout << e.what();
    return 1;
  }
}
如果需要使用FIX Initiator，则需要使用SocketInitiator。
六、QuickFix配置
1、QuickFix配置简介
QuickFix中initiator或acceptor会维护多个Fix Session。QuickFix中使用BeginString（Fix版本号）、SenderCompID、TargetCompID的组合标识一个Session，Session标识用于区分其它不同的Session。
Session配置文件包含[DEFAULT]和[SESSION]两种分节，[SESSION]分节表示QuickFix中定义一个Session，[DEFAULT]表示所有Session默认使用的配置项，如果不提供QuickFix所需的配置，QuickFix会抛出ConfigError异常，表示配置缺失或格式不正确。
如果[DEFAULT]和[SESSION]分区中都包含相同的配置项，则[SESSION]分区的配置项会覆盖[DEFAULT]分区相应的配置项。
QuickFix配置参见官网：
http://quickfixengine.org/quickfix/doc/html/configuration.html
2、QuickFix配置文件
QuickFix配置文件sessions.ini如下：
# default settings for all sessions
[DEFAULT]
ConnectionType=initiator
ReconnectInterval=60
SenderCompID=TW

# session definition
[SESSION]
# inherit ConnectionType, ReconnectInterval and SenderCompID from default
BeginString=FIX.4.1
TargetCompID=ARCA
StartTime=12:30:00
EndTime=23:30:00
HeartBtInt=20
SocketConnectPort=9823
SocketConnectHost=123.123.123.123
DataDictionary=somewhere/FIX41.xml

[SESSION]
BeginString=FIX.4.2
TargetCompID=INCA
StartTime=12:30:00
EndTime=21:30:00
# overide default setting for RecconnectInterval
ReconnectInterval=30
HeartBtInt=30
SocketConnectPort=6523
SocketConnectHost=3.3.3.3
# (optional) alternate connection ports and hosts to cycle through on failover
SocketConnectPort1=8392
SocketConnectHost1=8.8.8.8
SocketConnectPort2=2932
SocketConnectHost2=12.12.12.12
DataDictionary=somewhere/FIX42.xml
3、Session配置
BeginString：Session使用的Fix版本，可选值为FIXT.1.1、FIX.4.4、FIX.4.3、FIX.4.2、FIX.4.1、FIX.4.0。
SenderCompID：关联Fix Session的本地ID，包含字母和数字大小写敏感的字符串。
TargetCompID：Fix Session的对等方ID，包含字母和数字大小写敏感的字符串。
SessionQualifier：Session标识，用于区分其它Session，包含字母和数字大小写敏感的字符串。
DefaultApplVerID：只支持FIXT 1.1及后续版本，早期版本会忽略，用于指定Session的默认应用版本ID，可选值可以是ApplVerID枚举值或BeginString值，包括FIX.5.0SP2、FIX.5.0SP1、FIX.5.0、FIX.4.4、FIX.4.3、FIX.4.2、FIX.4.1、FIX.4.0、9、8、7、6、5、4、3、2。
ConnectionType：定义Session的角色，可选值为initiator、acceptor。
StartTime：Session每天开始工作的时间，时间为UTC时间，时间格式为HH:MM:SS。
EndTime：Session每天停止工作的时间，时间为UTC时间，时间格式为HH:MM:SS。
StartDay：对于周级别的长连接Session，指示Session在周中的开始工作日。
EndDay：对于周级别的长连接Session，指示Session在周中的结束工作日。
LogonTime：Session每天登录的时间，时间为UTC时间，时间格式为HH:MM:SS。
LogoutTime：Session每天登出的时间，时间为UTC时间，时间格式为HH:MM:SS。
LogonDay：对于周级别的长连接Session，指示Session在周中登录的工作日。
LogoutDay：对于周级别的长连接Session，指示Session在周中登出的工作日。
UseLocalTime：指示StartTime和EndTime使用本地时间，而不是UTC时间，FIX消息中的按照FIX协议要求仍然使用UTC时间，可选值为Y、N，默认值为N。
MillisecondsInTimeStamp：是否将毫秒增加到时间戳上，只对Fix 4.2及后续版本有效。
TimestampPrecision：指定时间戳的小数部分，可选值为0-9，如果设置，则会覆盖MillisecondsInTimeStamp。
SendRedundantResendRequests：可选值为Y、N，如果设置为Y，QuickFix会发送所有需要的重发请求，即使冗余。如果设置为N，QuickFix会试图最小化重发请求，通常用于高吞吐量的系统中。
ResetOnLogon：如果Session为Acceptors，当收到一个登录请求时确定是否要重置序列号，可选值为Y、N，默认值为N。
ResetOnLogout：当收到一个登出请求时确定是否要重置序列号为1，可选值为Y、N，默认值为N。
ResetOnDisconnect：当Session异常终止时确定是否要重置序列号为1，可选值为Y、N，默认值为N。
RefreshOnLogon：当登录时确定Session状态是否从持久层恢复，用于创建热切换的Session，可选值为Y、N，默认值为N。
4、认证配置
UseDataDictionary：Session是否使用数据字典，如果使用重复分组，应该使用数据字典。可选值为Y、N，默认值为Y。
DataDictionary：XML格式的数据字典文件，如果没有提供数据字典，只能提供基本FIX消息验证。对于FIXT.1.1以及后续版本，使用TransportDataDictionary和AppDataDictionary进行指定。
可选数据字典包括FIX44.xml、FIX43.xml、FIX42.xml、FIX41.xml、FIX40.xml。
TransportDataDictionary：XML格式定义的数据字典，只对FIXT.1.1以及后续版本有效，可选数据字典为FIXT1.1.xml。
AppDataDictionary：XML格式的验证应用消息的数据字典，只对FIXT.1.1以及后续版本有效，可选数据字典为FIX50SP2.xml、FIX50SP1.xml、FIX50.xml、FIX44.xml、FIX43.xml、FIX42.xml、FIX41.xml、FIX40.xml。可以使用前缀指定多个应用字典，如：
DefaultApplVerID=FIX.4.2
# For default application version ID
AppDataDictionary=FIX42.xml
# For nondefault application version ID
# Use BeginString suffix for app version
AppDataDictionary.FIX.4.4=FIX44.xml
ValidateLengthAndChecksum：可选值为Y、N，默认值为Y。如果设置为N，则消息的长度和校验和不正确将不会被拒绝。
ValidateFieldsOutOfOrder：可选值为Y、N，默认值为Y。如果设置为N，则订单外的字段（如body字段在header中，header字段在body中）将不会被拒绝。
ValidateFieldsHaveValues：可选值为Y、N，默认值为Y。如果设置为N，则没有值的字段将不会被拒绝。用于那些会不恰当发送控tag的系统。
ValidateUserDefinedFields：可选值为Y、N，默认值为Y。如果设置为N，则没有在数据字典中定义的用户自定义字段将不会被拒绝，或是显示在不属于的消息中。
PreserveMessageFieldsOrder：是否按照配置文件中定义的保留发送消息体中的字段顺序，可选值为Y、N，默认值为N。
CheckCompID：可选值为Y、N，默认值为Y。如果设置为N，则消息必须从包含正确的SenderCompID和TargetCompID的对等方中接收。
CheckLatency：可选值为Y、N，默认值为Y。如果设置为Y，消息必须在最大延迟内被接收。
MaxLatency：如果CheckLatency设置为Y，则表示消息可以延迟处理的时间，默认为120秒。
5、Initiator配置
ReconnectInterval：重连接时间间隔，只用于Initiator，正数，默认只为30。
HeartBtInt：心跳时间间隔，只用于Initiator，正数。
LogonTimeout：登录超时时间，正数，默认为10。
LogoutTimeout：登出超时时间，正数，默认为2。
SocketConnectPort：Session连接端口，只用于SocketInitiator。
SocketConnectHost：Session连接主机，只用于SocketInitiator，可以是IP地址或域名。
SocketConnectPort<n>：对于热切换Session的备份连接端口。
SocketConnectHost<n>：对于热切换Session的备份连接主机。
SocketNodelay：指定使用TCP_NODELAY创建Socket，目前只能定义在[DEFAULT]分区，可选值为Y、N，默认值为N。
SocketSendBufferSize：指定使用SO_SNDBUF创建Socket，目前只能定义在[DEFAULT]分区，正数，默认值为0。
SocketReceiveBufferSize：指定使用SO_RCVBUF创建Socket，目前只能定义在[DEFAULT]分区，正数，默认值为0。
6、Acceptor
SocketAcceptPort：监听端口，只用于SocketAcceptor，目前只能定义在[DEFAULT]分区。
SocketReuseAddress：指定SO_REUSADDR使用创建Socket，只用于SocketAcceptor，可选值为Y、N，默认值为Y。
SocketNodelay：指定使用TCP_NODELAY创建Socket，目前只能定义在[DEFAULT]分区，可选值为Y、N，默认值为N。
7、Storage
PersistMessages：可选值为Y、N，默认值为N。如果设置N，消息不会被持久化，QuickFix会使用填充空白消息取代正在重发的消息。
FileStorePath：存储序列号和消息的目录，必须有写权限。
MySQLStoreDatabase：存储消息和Session状态的MySQL数据库名称，默认为quickfix。
MySQLStoreUser：登录MySQL数据库的用户名，默认为root。
MySQLStorePassword：登录MySQL数据库的用户名的用户密码，默认为空。
MySQLStoreHost：MySQL数据库的地址，可以是IP或域名，默认值为localhost。
MySQLStorePort：MySQL数据库的端口，默认值为标准数据库端口3306。
MySQLStoreUseConnectionPool：是否使用数据库连接池，可选值为Y、N，默认值为N。
PostgreSQLStoreDatabase：存储消息和Session状态的PostgreSQL数据库名称，默认为quickfix。
PostgreSQLStoreUser：登录PostgreSQL数据库的用户名，默认为postgres。
PostgreSQLStorePassword：登录PostgreSQL数据库的用户名的用户密码，默认为空。
PostgreSQLStoreHost：PostgreSQL数据库的地址，可以是IP或域名，默认值为localhost。
PostgreSQLStorePort：PostgreSQL数据库的端口，默认值为标准数据库端口5432。
PostgreSQLStoreUseConnectionPool：是否使用数据库连接池，可选值为Y、N，默认值为N。
OdbcStoreUser：登录ODBC数据库的用户名
OdbcStorePassword：登录ODBC数据库的用户密码
OdbcStoreConnectionString：ODBC数据库连接字符串，默认值为DATABASE=quickfix;DRIVER={SQL Server};SERVER=(local);
8、日志配置
FileLogPath：日志存储路径，必须有写权限。
FileLogBackupPath：日志备份路径，必须有写权限。
ScreenLogShowIncoming：打印Incoming消息到标准输出，可选值为Y、N，默认值为Y。
ScreenLogShowOutgoing：打印Outgoing消息到标准输出，可选值为Y、N，默认值为Y。
ScreenLogShowEvents：打印Events消息到标准输出，可选值为Y、N，默认值为Y。
日志也可以存储到数据库中，支持MySQL、PostgreSQL、ODBC数据库。
9、SSL配置
SSLProtocol：用于控制应用程序在建立其环境时应使用的SSL协议，可选值为SSLv2、SSLv3、TLSv1、TLSv1_1、TLSv1_2、all，默认为all -SSLv2。
七、消息验证
QuickFIX会在消息到达应用程序前对其进行验证，拒绝任何格式错误的消息。XML文件定义会话支持的消息、字段和值。spec目录包含多个标准的FIX协议字典。FIX字典基本骨架如下：
<fix type="FIX" major="4" minor="1">
  <header>
    <field name="BeginString" required="Y"/>
    ...
  </header>

  <trailer>
    <field name="CheckSum" required="Y"/>
    ...
  </trailer>

  <messages>
    <message name="Heartbeat" msgtype="0" msgcat="admin">
      <field name="TestReqID" required="N"/>
    </message>
    ...
    <message name="NewOrderSingle" msgtype="D" msgcat="app">
      <field name="ClOrdID" required="Y"/>
      ...
    </message>
    ...
  </messages>
  <fields>
    <field number="1" name="Account" type="CHAR" />
    ...
    <field number="4" name="AdvSide" type="CHAR">
     <value enum="B" description="BUY" />
     <value enum="S" description="SELL" />
     <value enum="X" description="CROSS" />
     <value enum="T" description="TRADE" />
   </field>
   ...
  </fields>
</fix>
验证器不会有条件地拒绝必填字段，因为其规则没有明确定义。使用非预设的有条件必填字段将导致消息被拒绝。
八、接收消息
开发者感兴趣的大部分消息在应用程序重载的fromApp函数内收到，所有消息都有消息头和消息尾，消息头和消息尾分别使用 getHeader和getTrailer函数进行访问。
1、类型安全消息和字段
QuickFIX为不同FIX标准规范中定义的所有消息提供了一个类MessageCracker。
#include "quickfix/Application.h"
#include "quickfix/MessageCracker.h"

class FIXApplication: public FIX::Application, public FIX::MessageCracker
{
public:
    /**************************************************
     *  reimplementation from Application
     * ***********************************************/
    /// Notification of a session begin created
    virtual void onCreate( const SessionID& )
    {

    }

    /// Notification of a session successfully logging on
    virtual void onLogon( const SessionID& )
    {

    }

    /// Notification of a session logging off or disconnecting
    virtual void onLogout( const SessionID& )
    {

    }

    /// Notification of admin message being sent to target
    virtual void toAdmin( Message&, const SessionID& )
    {

    }

    /// Notification of app message being sent to target
    void fromApp( const FIX::Message& message, const FIX::SessionID& sessionID )
    throw( FIX::FieldNotFound&, FIX::IncorrectDataFormat&, FIX::IncorrectTagValue&, 
           FIX::UnsupportedMessageType& )
    {
        crack(message, sessionID);
    }

    /// Notification of admin message being received from target
    virtual void fromAdmin( const Message&, const SessionID& )
    throw ( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, 
            FIX::RejectLogon )
    {

    }

    /// Notification of app message being received from target
    virtual void fromApp( const Message&, const SessionID& )
    throw ( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, 
            FIX::UnsupportedMessageType )
    {

    }

    /**************************************************
     *  reimplementation from MessageCracker
     * ***********************************************/
    void onMessage( const FIX42::NewOrderSingle& message, const FIX::SessionID& )
    {
        FIX::ClOrdID clOrdID;
        message.get(clOrdID);

        FIX::ClearingAccount clearingAccount;
        message.get(clearingAccount);
    }

    void onMessage( const FIX42::OrderCancelRequest& message, const FIX::SessionID& )
    {
        FIX::ClOrdID clOrdID;
        message.get(clOrdID);

        // compile time error!! field not defined for OrderCancelRequest
        FIX::Price price;
        message.get(price);
    }
};
通过继承MessageCracker，可以使用crack函数并可以重载不同的FIX协议的消息函数，未重载的函数默认抛出UnsupportedMessageType异常。
2、类型安全字段
使用getField函数从消息中获取字段。
void fromApp( const FIX::Message& message, const FIX::SessionID& sessionID )
  throw( FIX::FieldNotFound&, FIX::IncorrectDataFormat&, 
         FIX::IncorrectTagValue&, FIX::UnsupportedMessageType& )
{
  // retrieve value into field class
  FIX::Price price;
  message.getField(price);

  // another field...
  FIX::ClOrdID clOrdID;
  message.getField(clOrdID);
}
3、非类型安全
使用tag数字创建自定义字段。
void fromApp( const FIX::Message& message, const FIX::SessionID& sessionID )
  throw( FIX::FieldNotFound&, FIX::IncorrectDataFormat&, 
         FIX::IncorrectTagValue&, FIX::UnsupportedMessageType& )
{
  // retreive value into string with integer field ID
  std::string value;
  value = message.getField(44);

  // retrieve value into a field base with integer field ID
  FIX::FieldBase field(44, "");
  message.getField(field);

  // retreive value with an enumeration, a little better
  message.getField(FIX::FIELD::Price);
}
九、发送消息
1、发送消息
使用静态函数方法Session::sendToTarget发送消息到对等方。
// send a message that already contains a BeginString, SenderCompID, and a TargetCompID
static bool sendToTarget( Message&, const std::string& qualifier = "" )
  throw(SessionNotFound&);

// send a message based on the sessionID, convenient for use
// in fromApp since it provides a session ID for incoming
// messages
static bool sendToTarget( Message&, const SessionID& )
  throw(SessionNotFound&);

// append a SenderCompID and TargetCompID before sending
static bool sendToTarget( Message&, const SenderCompID&, const TargetCompID&, 
                          const std::string& qualifier = "" )
  throw(SessionNotFound&);

// pass SenderCompID and TargetCompID in as strings
static bool sendToTarget( Message&, const std::string&, const std::string&, 
                          const std::string& qualifier = "" )
  throw(SessionNotFound&);
2、类型安全消息和字段
Message构造函数接收所有必需字段，并为开发者添加正确的MsgType和BeginString。使用set方法，编译器不允许添加不是FIX字典中定义的消息的字段。
void sendOrderCancelRequest()
{
  FIX41::OrderCancelRequest message(
    FIX::OrigClOrdID("123"),
    FIX::ClOrdID("321"),
    FIX::Symbol("LNUX"),
    FIX::Side(FIX::Side_BUY));

  message.set(FIX::Text("Cancel My Order!"));

  FIX::Session::sendToTarget(message, SenderCompID("TW"), TargetCompID("TARGET"));
}
3、类型安全字段
setField方法用于增加任何字段到消息。
void sendOrderCancelRequest()
{
  FIX::Message message;
  FIX::Header header& = message.getHeader();

  header.setField(FIX::BeginString("FIX.4.2"));
  header.setField(FIX::SenderCompID(TW));
  header.setField(FIX::TargetCompID("TARGET"));
  header.setField(FIX::MsgType(FIX::MsgType_OrderCancelRequest));
  message.setField(FIX::OrigClOrdID("123"));
  message.setField(FIX::ClOrdID("321"));
  message.setField(FIX::Symbol("LNUX"));
  message.setField(FIX::Side(FIX::Side_BUY));
  message.setField(FIX::Text("Cancel My Order!"));

  FIX::Session::sendToTarget(message);
}
4、非类型安全
可以使用setField方法传递消息原语。
void sendOrderCancelRequest()
{
  FIX::Message message;
  // BeginString
  message.getHeader().setField(8, "FIX.4.2");

  // SenderCompID
  message.getHeader().setField(49, "TW");

  // TargetCompID, with enumeration
  message.getHeader().setField(FIX::FIELD::TargetCompID, "TARGET");

  // MsgType
  message.getHeader().setField(35, 'F');

  // OrigClOrdID
  message.setField(41, "123");

  // ClOrdID
  message.setField(11, "321");

  // Symbol
  message.setField(55, "LNUX");

  // Side, with value enumeration
  message.setField(54, FIX::Side_BUY);

  // Text
  message.setField(58, "Cancel My Order!");

  FIX::Session::sendToTarget(message);
}
十、循环组
QuickFIX能够发送包含循环组甚至递归循环组的消息。所有循环组都以一个字段开头，用于指示一个集合中有多少个循环组，可以通过引用在父消息或父组中以该字段命名的类来创建组。
1、使用循环组创建消息
创建消息时，声明循环组的数量的必填字段设置为零。当添加组时，QuickFIX会自动增加字段值。
// create a market data message
FIX42::MarketDataSnapshotFullRefresh message(FIX::Symbol("QF"));

// repeating group in the form of MessageName::NoField
FIX42::MarketDataSnapshotFullRefresh::NoMDEntries group;

group.set(FIX::MDEntryType('0'));
group.set(FIX::MDEntryPx(12.32));
group.set(FIX::MDEntrySize(100));
group.set(FIX::OrderID("ORDERID"));
message.addGroup(group);

// no need to create a new group class if we are reusing the fields
group.set(FIX::MDEntryType('1'));
group.set(FIX::MDEntryPx(12.32));
group.set(FIX::MDEntrySize(100));
group.set(FIX::OrderID("ORDERID"));
message.addGroup(group);
2、使用循环组读取消息
要从消息中拉出组，需要提供要拉出的组对象。应该首先检查实体字段的数量以获得组的总数。
// should be 2
FIX::NoMDEntries noMDEntries;
message.get(noMDEntries);

FIX42::MarketDataSnapshotFullRefresh::NoMDEntries group;
FIX::MDEntryType MDEntryType;
FIX::MDEntryPx MDEntryPx;
FIX::MDEntrySize MDEntrySize;
FIX::OrderID orderID;

message.getGroup(1, group);
group.get(MDEntryType);
group.get(MDEntryPx);
group.get(MDEntrySize);
group.get(orderID);

message.getGroup(2, group);
group.get(MDEntryType);
group.get(MDEntryPx);
group.get(MDEntrySize);
group.get(orderID);
十一、用户自定义字段
FIX允许用户定义未在FIX协议规范中定义的字段。
非类型安全的字段操作如下：
message.setField(6123, "value");
message.getField(6123);
QuickFIX提供了创建类型安全字段对象的宏。
#include "quickfix/Field.h"

namespace FIX
{
  USER_DEFINE_STRING(MyStringField, 6123);
  USER_DEFINE_PRICE(MyPriceField, 8756);
}
用户自定义字段必须定义在FIX命名空间内，应用程序中可以如下使用：
MyStringField stringField("string");
MyPriceField priceField(14.54);

message.setField(stringField);
message.setField(priceField);

message.getField(stringField);
message.getField(priceField);
下列宏允许定义所有支持的FIX类型的字段。只要提供一个新的宏和转换器，可以将类型与字符串进行转换，就可以编写任何类型的字段。
USER_DEFINE_STRING( NAME, NUM )
USER_DEFINE_CHAR( NAME, NUM )
USER_DEFINE_PRICE( NAME, NUM )
USER_DEFINE_INT( NAME, NUM )
USER_DEFINE_AMT( NAME, NUM )
USER_DEFINE_QTY( NAME, NUM )
USER_DEFINE_CURRENCY( NAME, NUM )
USER_DEFINE_MULTIPLEVALUESTRING( NAME, NUM )
USER_DEFINE_EXCHANGE( NAME, NUM )
USER_DEFINE_UTCTIMESTAMP( NAME, NUM )
USER_DEFINE_BOOLEAN( NAME, NUM )
USER_DEFINE_LOCALMKTDATE( NAME, NUM )
USER_DEFINE_DATA( NAME, NUM )
USER_DEFINE_FLOAT( NAME, NUM )
USER_DEFINE_PRICEOFFSET( NAME, NUM )
USER_DEFINE_MONTHYEAR( NAME, NUM )
USER_DEFINE_DAYOFMONTH( NAME, NUM )
USER_DEFINE_UTCDATE( NAME, NUM )
USER_DEFINE_UTCTIMEONLY( NAME, NUM )
USER_DEFINE_NUMINGROUP( NAME, NUM )
USER_DEFINE_SEQNUM( NAME, NUM )
USER_DEFINE_LENGTH( NAME, NUM )
USER_DEFINE_PERCENTAGE( NAME, NUM )
USER_DEFINE_COUNTRY( NAME, NUM )
十二、测试
1、单元测试
QuickFIX提供了一套综合的自动化单元测试套件。测试组件运行在UnitTest++框架上。UnTest++框架允许开发人员通过编写调用对象上的函数并声明正确行为的代码来测试C++代码。测试不仅验证了代码的正确工作，还验证了它在所有平台上的工作原理。
下列示例显示测试的设置和执行，测试用例测试验证解析器对象是否可以从流中正确提取消息。
struct readFixMessageFixture
{
  readFixMessageFixture()
  {
    fixMsg1 = "8=FIX.4.2\0019=12\00135=A\001108=30\00110=31\001";
    fixMsg2 = "8=FIX.4.2\0019=17\00135=4\00136=88\001123=Y\00110=34\001";
    fixMsg3 = "8=FIX.4.2\0019=19\00135=A\001108=30\0019710=8\00110=31\001";

    object.addToStream( fixMsg1 + fixMsg2 + fixMsg3 );
  }

  std::string fixMsg1;
  std::string fixMsg2;
  std::string fixMsg3;
  Parser object;
};

TEST_FIXTURE(readFixMessageFixture, readFixMessage)
{
  std::string readFixMsg1;
  CHECK( object.readFixMessage( readFixMsg1 ) );
  CHECK_EQUAL( fixMsg1, readFixMsg1 );

  std::string readFixMsg2;
  CHECK( object.readFixMessage( readFixMsg2 ) );
  CHECK_EQUAL( fixMsg2, readFixMsg2 );

  std::string readFixMsg3;
  CHECK( object.readFixMessage( readFixMsg3 ) );
  CHECK_EQUAL( fixMsg3, readFixMsg3 );
}
2、验证测试
QuickFIX由一个脚本化的测试运行器，其附带一系列自动化验收测试。QuickFIX附带的基本测试基于FIX协议组织提供的《FIX会话层测试用例和预期行为》。QuickFIX的测试会验证QuickFIX是否符合FIX协议规范。QuickFIX测试的自动化特性保证了QuickFIX的未来版本不会破坏任何当前功能。
也许更重要的是如何使用测试驱动QuickFIX的开发。在编写任何一行支持FIX协议的代码前，必须先编写测试用例。
这种测试优先的方法为开发人员建立了一个目标，开发人员将客观地验证其是否正确地实现了FIX标准。
下列测试脚本的示例测试在接收到小于预期MsgSeqNum的NewSeqNo值时FIX引擎的行为。
iCONNECT

I8=FIX.4.235=A34=149=TW52=>TIME>56=ISLD98=0108=30
E8=FIX.4.29=5735=A34=149=ISLD52=00000000-00:00:0056=TW98=0108=3010=0

# sequence reset without gap fill flag (default to N)
I8=FIX.4.235=434=049=TW52=>TIME>56=ISLD36=1
E8=FIX.4.29=11235=334=249=ISLD52=00000000-00:00:0056=TW45=058=Value is incorrect (out of range) for this tag372=4373=510=0

I8=FIX.4.235=134=249=TW52=>TIME>56=ISLD112=HELLO
E8=FIX.4.29=5535=034=349=ISLD52=00000000-00:00:0056=TW112=HELLO10=0

# sequence reset without gap fill flag (default to N)
I8=FIX.4.235=434=049=TW52=>TIME>56=ISLD36=1123=N
E8=FIX.4.29=11235=334=449=ISLD52=00000000-00:00:0056=TW45=058=Value is incorrect (out of range) for this tag372=4373=510=0

I8=FIX.4.235=134=349=TW52=>TIME>56=ISLD112=HELLO
E8=FIX.4.29=5535=034=549=ISLD52=00000000-00:00:0056=TW112=HELLO10=0

iDISCONNECT
示例脚本中有两种命令类型，action命令和messages命令，action命令以小写字母开头，messages命令以大写字母开头。
（1）action命令
i<ACTION> ：初始化action
e<ACTION> ：预期action
支持的Action如下：
iCONNECT ：初始化到FIX Acceptor的连接
eCONNECT：等待来自FIX Initiator的连接
iDISCONNECT：断开到FIX Acceptor的连接
eDISCONNECT：等待来自FIX Initiator的连接断开
（2）messages命令
I<MESSAGE>：初始化（发送）一条消息
E<MESSAGE>：等待一条消息
使用I命令时，不必增加Length（9）、CheckSum（10）字段，命令会自动增加相应的值到合适位置。开发者只有故意使这些字段不正确时才需要增加字段。
I命令也为字段提供了TIME宏，通过设置字段等于<TIME>，当前系统时间会被替换，也可以使用TIME的偏移，如52=<TIME-120>或52=<TIME+15>。
E命令验证是否收到正确消息。E命令会比较每个字段的值确保其是否正确。有些字段在运行时前无法确定地验证，例如SendingTime和CheckSum字段。这些字段可以添加到fields.fmt文件，文件中可以定义正则表达式至少验证字段的格式是否正确。
10=\d{3},，checksum必须是三个数字。
52=\d{8}-\d{2}:\d{2}:\d{2}，发送时间必须是DDDDDDDD-DD:DD:DD格式。
I命令和E命令可以包含FILE宏，用于将文件内容传递给字段，如：
58=<FILE:test.txt>




交易系统开发（十三）——QuickFIX源码分析


一、QuickFIX源码目录
QuickFIX主要目录如下：
doc：QuickFIX说明和简要HTML文件。
example：QuickFIX示例程序。
spec：存放FIX数据字典。
UnitTest++：单元测试框架。
test：测试脚本。
src：源代码目录。
src/C++：C++实现代码。
src/python：Python实现。
src/python2：Python2实现。
src/python3：Python3实现。
src/ruby：Ruby实现。
二、C++实现
1、C++实现简介
QuickFIX的C++实现代码位于src/C++目录，C++目录下的代码为QuickFIX实现的通用代码，使用FIX命名空间进行限定，不同FIX协议的实现放在C++目录下的不同目录，并使用相应的FIX协议版本命名空间进行限定，如FIX42协议实现目录为fix42，命名空间为FIX42。
2、XML解析
QuickFIX在pugixml parser基础上封装了PUGIXML_DOMAttributes、PUGIXML_DOMNode、PUGIXML_DOMDocument三个类，用于解析XML文件，定义在在头文件PUGIXML_DOMDocument.h中。
#ifndef FIX_PUGIXMLDOMDOCUMENT_H
#define FIX_PUGIXMLDOMDOCUMENT_H

#include "DOMDocument.h"
#include "Exceptions.h"
#include "pugixml.hpp"

namespace FIX
{
/// XML attribute as represented by pugixml.
class PUGIXML_DOMAttributes : public DOMAttributes
{
public:
    PUGIXML_DOMAttributes( pugi::xml_node pNode )
        : m_pNode(pNode) {}

    bool get( const std::string&, std::string& );
    DOMAttributes::map toMap();

private:
    pugi::xml_node m_pNode;
};

/// XML node as represented by pugixml.
class PUGIXML_DOMNode : public DOMNode
{
public:
    PUGIXML_DOMNode( pugi::xml_node pNode )
        : m_pNode(pNode) {}
    ~PUGIXML_DOMNode() {}

    DOMNodePtr getFirstChildNode();
    DOMNodePtr getNextSiblingNode();
    DOMAttributesPtr getAttributes();
    std::string getName();
    std::string getText();

private:
    pugi::xml_node m_pNode;
};

/// XML document as represented by pugixml.
class PUGIXML_DOMDocument : public DOMDocument
{
public:
    PUGIXML_DOMDocument() EXCEPT ( ConfigError );
    ~PUGIXML_DOMDocument();

    bool load( std::istream& );
    bool load( const std::string& );
    bool xml( std::ostream& );

    DOMNodePtr getNode( const std::string& );

private:
    pugi::xml_document m_pDoc;
};
}

#endif
开发者只需要关心PUGIXML_DOMDocument类的load()函数，用于加载XML文件。
3、数据字典解析
DataDictionary类用于解析FIX数据字典。
void DataDictionary::readFromURL( const std::string& url )
EXCEPT ( ConfigError )
{
  DOMDocumentPtr pDoc(new PUGIXML_DOMDocument());
  if(!pDoc->load(url))
    throw ConfigError(url + ": Could not parse data dictionary file");
  try
  {
    readFromDocument( pDoc );
  }
  catch( ConfigError& e )
  {
    throw ConfigError( url + ": " + e.what() );
  }
}

void DataDictionary::readFromDocument( const DOMDocumentPtr &pDoc )
EXCEPT ( ConfigError )
{
  // VERSION
  DOMNodePtr pFixNode = pDoc->getNode("/fix");
  if(!pFixNode.get())
    throw ConfigError("Could not parse data dictionary file"
                      ", or no <fix> node found at root");
  DOMAttributesPtr attrs = pFixNode->getAttributes();
  std::string type = "FIX";
  if(attrs->get("type", type))
  {
    if(type != "FIX" && type != "FIXT")
      throw ConfigError("type attribute must be FIX or FIXT");
  }

  std::string major;
  if(!attrs->get("major", major))
    throw ConfigError("major attribute not found on <fix>");

  std::string minor;
  if(!attrs->get("minor", minor))
    throw ConfigError("minor attribute not found on <fix>");
  setVersion(type + "." + major + "." + minor);

  // FIELDS
  DOMNodePtr pFieldsNode = pDoc->getNode("/fix/fields");
  if(!pFieldsNode.get())
    throw ConfigError("<fields> section not found in data dictionary");

  DOMNodePtr pFieldNode = pFieldsNode->getFirstChildNode();
  if(!pFieldNode.get()) throw ConfigError("No fields defined");

  while(pFieldNode.get())
  {
    if(pFieldNode->getName() == "field")
    {
      DOMAttributesPtr attrs = pFieldNode->getAttributes();
      std::string name;
      if(!attrs->get("name", name))
        throw ConfigError("<field> does not have a name attribute");

      std::string number;
      if(!attrs->get("number", number))
        throw ConfigError("<field> " + name + " does not have a number attribute");

      int num = atoi(number.c_str());
      std::string type;
      if(!attrs->get("type", type))
        throw ConfigError("<field> " + name + " does not have a type attribute");

      addField(num);
      addFieldType(num, XMLTypeToType(type));
      addFieldName(num, name);

      DOMNodePtr pFieldValueNode = pFieldNode->getFirstChildNode();
      while(pFieldValueNode.get())
      {
        if(pFieldValueNode->getName() == "value")
        {
          DOMAttributesPtr attrs = pFieldValueNode->getAttributes();
          std::string enumeration;
          if(!attrs->get("enum", enumeration))
            throw ConfigError("<value> does not have enum attribute in field " + name);

          addFieldValue(num, enumeration);
          std::string description;
          if(attrs->get("description", description))
            addValueName(num, enumeration, description);
        }
        RESET_AUTO_PTR(pFieldValueNode, pFieldValueNode->getNextSiblingNode());
      }
    }
    RESET_AUTO_PTR(pFieldNode, pFieldNode->getNextSiblingNode());
  }

  // HEADER
  if( type == "FIXT" || (type == "FIX" && major < "5") )
  {
    DOMNodePtr pHeaderNode = pDoc->getNode("/fix/header");
    if(!pHeaderNode.get())
      throw ConfigError("<header> section not found in data dictionary");

    DOMNodePtr pHeaderFieldNode = pHeaderNode->getFirstChildNode();
    if(!pHeaderFieldNode.get()) throw ConfigError("No header fields defined");

    while(pHeaderFieldNode.get())
    {
      if(pHeaderFieldNode->getName() == "field" || pHeaderFieldNode->getName() == "group" )
      {
        DOMAttributesPtr attrs = pHeaderFieldNode->getAttributes();
        std::string name;
        if(!attrs->get("name", name))
          throw ConfigError("<field> does not have a name attribute");

        std::string required = "false";
        attrs->get("required", required);
        addHeaderField(lookupXMLFieldNumber(pDoc.get(), name), required == "true");
      }

      if(pHeaderFieldNode->getName() == "group")
      {
        DOMAttributesPtr attrs = pHeaderFieldNode->getAttributes();
        std::string required;
        attrs->get("required", required);
        bool isRequired = (required == "Y" || required == "y");
        addXMLGroup(pDoc.get(), pHeaderFieldNode.get(), "_header_", *this, isRequired);
      }

      RESET_AUTO_PTR(pHeaderFieldNode, pHeaderFieldNode->getNextSiblingNode());
    }
  }

  // TRAILER
    if( type == "FIXT" || (type == "FIX" && major < "5") )
    {
    DOMNodePtr pTrailerNode = pDoc->getNode("/fix/trailer");
    if(!pTrailerNode.get())
      throw ConfigError("<trailer> section not found in data dictionary");

    DOMNodePtr pTrailerFieldNode = pTrailerNode->getFirstChildNode();
    if(!pTrailerFieldNode.get()) throw ConfigError("No trailer fields defined");

    while(pTrailerFieldNode.get())
    {
      if(pTrailerFieldNode->getName() == "field" || pTrailerFieldNode->getName() == "group" )
      {
        DOMAttributesPtr attrs = pTrailerFieldNode->getAttributes();
        std::string name;
        if(!attrs->get("name", name))
          throw ConfigError("<field> does not have a name attribute");
        std::string required = "false";
        attrs->get("required", required);
        addTrailerField(lookupXMLFieldNumber(pDoc.get(), name), required == "true");
      }

      if(pTrailerFieldNode->getName() == "group")
      {
        DOMAttributesPtr attrs = pTrailerFieldNode->getAttributes();
        std::string required;
        attrs->get("required", required);
        bool isRequired = (required == "Y" || required == "y");
        addXMLGroup(pDoc.get(), pTrailerFieldNode.get(), "_trailer_", *this, isRequired);
      }

      RESET_AUTO_PTR(pTrailerFieldNode, pTrailerFieldNode->getNextSiblingNode());
    }
  }

  // MSGTYPE
  DOMNodePtr pMessagesNode = pDoc->getNode("/fix/messages");
  if(!pMessagesNode.get())
    throw ConfigError("<messages> section not found in data dictionary");

  DOMNodePtr pMessageNode = pMessagesNode->getFirstChildNode();
  if(!pMessageNode.get()) throw ConfigError("No messages defined");

  while(pMessageNode.get())
  {
    if(pMessageNode->getName() == "message")
    {
      DOMAttributesPtr attrs = pMessageNode->getAttributes();
      std::string msgtype;
      if(!attrs->get("msgtype", msgtype))
        throw ConfigError("<message> does not have a msgtype attribute");
      addMsgType(msgtype);

      std::string name;
      if(attrs->get("name", name))
        addValueName( 35, msgtype, name );

      DOMNodePtr pMessageFieldNode = pMessageNode->getFirstChildNode();
      while( pMessageFieldNode.get() )
      {
        if(pMessageFieldNode->getName() == "field"
           || pMessageFieldNode->getName() == "group")
        {
          DOMAttributesPtr attrs = pMessageFieldNode->getAttributes();
          std::string name;
          if(!attrs->get("name", name))
            throw ConfigError("<field> does not have a name attribute");

          int num = lookupXMLFieldNumber(pDoc.get(), name);
          addMsgField(msgtype, num);

          std::string required;
          if(attrs->get("required", required)
             && (required == "Y" || required == "y"))
          {
            addRequiredField(msgtype, num);
          }
        }
        else if(pMessageFieldNode->getName() == "component")
        {
          DOMAttributesPtr attrs = pMessageFieldNode->getAttributes();
          std::string required;
          attrs->get("required", required);
          bool isRequired = (required == "Y" || required == "y");
          addXMLComponentFields(pDoc.get(), pMessageFieldNode.get(),
                                msgtype, *this, isRequired);
        }

        if(pMessageFieldNode->getName() == "group")
        {
          DOMAttributesPtr attrs = pMessageFieldNode->getAttributes();
          std::string required;
          attrs->get("required", required);
          bool isRequired = (required == "Y" || required == "y");
          addXMLGroup(pDoc.get(), pMessageFieldNode.get(), msgtype, *this, isRequired);
        }
        RESET_AUTO_PTR(pMessageFieldNode,
                       pMessageFieldNode->getNextSiblingNode());
      }
    }
    RESET_AUTO_PTR(pMessageNode, pMessageNode->getNextSiblingNode());
  }
}
4、FIX消息解析
QuickFIX中使用Message类处理FIX消息，在Message.h如下：
class Header : public FieldMap
{
  enum { REQUIRED_FIELDS = 8 };
public:
  Header() : FieldMap( message_order( message_order::header ), REQUIRED_FIELDS )
  {}

  Header(const message_order & order) : FieldMap(order)
  {}

  void addGroup( const FIX::Group& group )
  { FieldMap::addGroup( group.field(), group ); }

  void replaceGroup( unsigned num, const FIX::Group& group )
  { FieldMap::replaceGroup( num, group.field(), group ); }

  Group& getGroup( unsigned num, FIX::Group& group ) const EXCEPT ( FieldNotFound )
  { 
    group.clear();
    return static_cast < Group& >
      ( FieldMap::getGroup( num, group.field(), group ) );
  }

  void removeGroup( unsigned num, const FIX::Group& group )
  { FieldMap::removeGroup( num, group.field() ); }

  void removeGroup( const FIX::Group& group )
  { FieldMap::removeGroup( group.field() ); }

  bool hasGroup( const FIX::Group& group ) const
  { return FieldMap::hasGroup( group.field() ); }

  bool hasGroup( unsigned num, const FIX::Group& group ) const
  { return FieldMap::hasGroup( num, group.field() ); }
};

class Trailer : public FieldMap
{
  enum { REQUIRED_FIELDS = 1 };
public:
  Trailer() : FieldMap( message_order( message_order::trailer ), REQUIRED_FIELDS )
  {}

  Trailer(const message_order & order) : FieldMap(order)
  {}

  void addGroup( const FIX::Group& group )
  { FieldMap::addGroup( group.field(), group ); }

  void replaceGroup( unsigned num, const FIX::Group& group )
  { FieldMap::replaceGroup( num, group.field(), group ); }

  Group& getGroup( unsigned num, FIX::Group& group ) const EXCEPT ( FieldNotFound )
  { group.clear();
    return static_cast < Group& >
      ( FieldMap::getGroup( num, group.field(), group ) );
  }

  void removeGroup( unsigned num, const FIX::Group& group )
  { FieldMap::removeGroup( num, group.field() ); }

  void removeGroup( const FIX::Group& group )
  { FieldMap::removeGroup( group.field() ); }

  bool hasGroup( const FIX::Group& group ) const
  { return FieldMap::hasGroup( group.field() ); }

  bool hasGroup( unsigned num, const FIX::Group& group ) const
  { return FieldMap::hasGroup( num, group.field() ); }
};


/**
 * Base class for all %FIX messages.
 *
 * A message consists of three field maps.  One for the header, the body,
 * and the trailer.
 */
class Message : public FieldMap
{
  friend class DataDictionary;
  friend class Session;
  enum field_type { header, body, trailer };
public:
  Message();
  /// Construct message with a specified order of fields
  Message( const message_order& hdrOrder, const message_order& trlOrder,  
           const message_order& order);
  /// Construct a message from a string
  Message( const std::string& string, bool validate = true )
  EXCEPT ( InvalidMessage );

  /// Construct a message from a string using a data dictionary
  Message( const std::string& string, const FIX::DataDictionary& dataDictionary,
           bool validate = true )
  EXCEPT ( InvalidMessage );

  /// Construct a message from a string using a session and application data dictionary
  Message( const std::string& string, const FIX::DataDictionary& sessionDataDictionary,
           const FIX::DataDictionary& applicationDataDictionary, bool validate = true )
  EXCEPT ( InvalidMessage );

  /// Construct a message from a string using a data dictionary
  Message( const message_order& hdrOrder, const message_order& trlOrder,  
           const message_order& order, const std::string& string, 
           const FIX::DataDictionary& dataDictionary,
           bool validate = true )
  EXCEPT ( InvalidMessage );

  /// Construct a message from a string using a session and application data dictionary
  Message( const message_order& hdrOrder, const message_order& trlOrder,  
            const message_order& order, const std::string& string, 
            const FIX::DataDictionary& sessionDataDictionary,
            const FIX::DataDictionary& applicationDataDictionary, 
            bool validate = true )
  EXCEPT ( InvalidMessage );

  Message( const Message& copy );

  ~Message();

  /// Set global data dictionary for encoding messages into XML
  static bool InitializeXML( const std::string& string );

  void addGroup( const FIX::Group& group )
  { FieldMap::addGroup( group.field(), group ); }

  void replaceGroup( unsigned num, const FIX::Group& group )
  { FieldMap::replaceGroup( num, group.field(), group ); }

  Group& getGroup( unsigned num, FIX::Group& group ) const EXCEPT ( FieldNotFound )
  { group.clear();
    return static_cast < Group& >
      ( FieldMap::getGroup( num, group.field(), group ) );
  }

  void removeGroup( unsigned num, const FIX::Group& group )
  { FieldMap::removeGroup( num, group.field() ); }

  void removeGroup( const FIX::Group& group )
  { FieldMap::removeGroup( group.field() ); }

  bool hasGroup( const FIX::Group& group ) const
  { return FieldMap::hasGroup( group.field() ); }

  bool hasGroup( unsigned num, const FIX::Group& group ) const
  { return FieldMap::hasGroup( num, group.field() ); }
protected:
  // Constructor for derived classes
  Message( const BeginString& beginString, const MsgType& msgType );
public:
  /// Get a string representation of the message
  std::string toString( int beginStringField = FIELD::BeginString,
                        int bodyLengthField = FIELD::BodyLength,
                        int checkSumField = FIELD::CheckSum ) const;
  /// Get a string representation without making a copy
  std::string& toString( std::string&,
                         int beginStringField = FIELD::BeginString,
                         int bodyLengthField = FIELD::BodyLength,
                         int checkSumField = FIELD::CheckSum ) const;
  /// Get a XML representation of the message
  std::string toXML() const;
  /// Get a XML representation without making a copy
  std::string& toXML( std::string& ) const;
  /**
   * Add header informations depending on a source message.
   * This can be used to add routing informations like OnBehalfOfCompID
   * and DeliverToCompID to a message.
   */
  void reverseRoute( const Header& );

  /**
   * Set a message based on a string representation
   * This will fill in the fields on the message by parsing out the string
   * that is passed in.  It will return true on success and false
   * on failure.
   */

  void setString( const std::string& string )
  EXCEPT ( InvalidMessage )
  { setString(string, true); }

  void setString( const std::string& string, bool validate )
  EXCEPT ( InvalidMessage )
  { setString(string, validate, 0); }

  void setString( const std::string& string,
                  bool validate,
                  const FIX::DataDictionary* pDataDictionary )
  EXCEPT ( InvalidMessage )
  { setString(string, validate, pDataDictionary, pDataDictionary); }

  void setString( const std::string& string,
                  bool validate,
                  const FIX::DataDictionary* pSessionDataDictionary,
                  const FIX::DataDictionary* pApplicationDataDictionary )
  EXCEPT ( InvalidMessage );

  void setGroup( const std::string& msg, const FieldBase& field,
                 const std::string& string, std::string::size_type& pos,
                 FieldMap& map, const DataDictionary& dataDictionary );

  /**
   * Set a messages header from a string
   * This is an optimization that can be used to get useful information
   * from the header of a FIX string without parsing the whole thing.
   */
  bool setStringHeader( const std::string& string );

  /// Getter for the message header
  const Header& getHeader() const { return m_header; }

  /// Mutable getter for the message header
  Header& getHeader() { return m_header; }

  /// Getter for the message trailer
  const Trailer& getTrailer() const { return m_trailer; }

  /// Mutable getter for the message trailer
  Trailer& getTrailer() { return m_trailer; }

  bool hasValidStructure(int& tag) const
  { tag = m_tag;
    return m_validStructure;
  }

  int bodyLength( int beginStringField = FIELD::BeginString,
                  int bodyLengthField = FIELD::BodyLength,
                  int checkSumField = FIELD::CheckSum ) const
  { return m_header.calculateLength(beginStringField, bodyLengthField, checkSumField)
           + calculateLength(beginStringField, bodyLengthField, checkSumField)
           + m_trailer.calculateLength(beginStringField, bodyLengthField, checkSumField);
  }

  int checkSum( int checkSumField = FIELD::CheckSum ) const
  { return ( m_header.calculateTotal(checkSumField)
             + calculateTotal(checkSumField)
             + m_trailer.calculateTotal(checkSumField) ) % 256;
  }

  bool isAdmin() const
  { 
    MsgType msgType;
    if( m_header.getFieldIfSet( msgType ) )
      return isAdminMsgType( msgType );
    return false;
  }

  bool isApp() const
  { 
    MsgType msgType;
    if( m_header.getFieldIfSet( msgType ) )
      return !isAdminMsgType( msgType );
    return false;
  }

  bool isEmpty()
  { return m_header.isEmpty() && FieldMap::isEmpty() && m_trailer.isEmpty(); }

  void clear()
  {
    m_tag = 0;
    m_validStructure = true;
    m_header.clear();
    FieldMap::clear();
    m_trailer.clear();
  }

  static bool isAdminMsgType( const MsgType& msgType )
  { if ( msgType.getValue().length() != 1 ) return false;
    return strchr
           ( "0A12345",
             msgType.getValue().c_str() [ 0 ] ) != 0;
  }

  static ApplVerID toApplVerID(const BeginString& value)
  {
    if( value == BeginString_FIX40 )
      return ApplVerID(ApplVerID_FIX40);

    if( value == BeginString_FIX41 )
      return ApplVerID(ApplVerID_FIX41);

    if( value == BeginString_FIX42 )
      return ApplVerID(ApplVerID_FIX42);

    if( value == BeginString_FIX43 )
      return ApplVerID(ApplVerID_FIX43);

    if( value == BeginString_FIX44 )
      return ApplVerID(ApplVerID_FIX44);

    if( value == BeginString_FIX50 )
      return ApplVerID(ApplVerID_FIX50);

    if( value == "FIX.5.0SP1" )
      return ApplVerID(ApplVerID_FIX50SP1);

    if( value == "FIX.5.0SP2" )
      return ApplVerID(ApplVerID_FIX50SP2);

    return ApplVerID(ApplVerID(value));
  }

  static BeginString toBeginString( const ApplVerID& applVerID )
  {
    if( applVerID == ApplVerID_FIX40 )
      return BeginString(BeginString_FIX40);
    else if( applVerID == ApplVerID_FIX41 )
      return BeginString(BeginString_FIX41);
    else if( applVerID == ApplVerID_FIX42 )
      return BeginString(BeginString_FIX42);
    else if( applVerID == ApplVerID_FIX43 )
      return BeginString(BeginString_FIX43);
    else if( applVerID == ApplVerID_FIX44 )
      return BeginString(BeginString_FIX44);
    else if( applVerID == ApplVerID_FIX50 )
      return BeginString(BeginString_FIX50);
    else if( applVerID == ApplVerID_FIX50SP1 )
      return BeginString(BeginString_FIX50);
    else if( applVerID == ApplVerID_FIX50SP2 )
      return BeginString(BeginString_FIX50);
    else
      return BeginString("");
  }

  static bool isHeaderField( int field );
  static bool isHeaderField( const FieldBase& field,
                             const DataDictionary* pD = 0 );
  static bool isHeaderField( int field,
                             const DataDictionary* pD );

  static bool isTrailerField( int field );
  static bool isTrailerField( const FieldBase& field,
                              const DataDictionary* pD = 0 );
  static bool isTrailerField( int field,
                              const DataDictionary* pD );

  /// Returns the session ID of the intended recipient
  SessionID getSessionID( const std::string& qualifier = "" ) const
  EXCEPT ( FieldNotFound );
  /// Sets the session ID of the intended recipient
  void setSessionID( const SessionID& sessionID );

#ifdef HAVE_EMX
  void  setSubMessageType(const std::string & subMsgType) { m_subMsgType.assign(subMsgType); }
  const std::string & getSubMessageType() const { return m_subMsgType; }
#endif

private:
  FieldBase extractField(
    const std::string& string, std::string::size_type& pos,
    const DataDictionary* pSessionDD = 0, const DataDictionary* pAppDD = 0,
    const Group* pGroup = 0) const;

  static bool IsDataField(
    int field,
    const DataDictionary* pSessionDD,
    const DataDictionary* pAppDD )
  {
    if( (pSessionDD && pSessionDD->isDataField( field )) ||
        (pAppDD && pAppDD != pSessionDD && pAppDD->isDataField( field )) )
    {
      return true;
    }

    return false;
  }

  void validate() const;
  std::string toXMLFields(const FieldMap& fields, int space) const;
protected:
  mutable Header m_header;
  mutable Trailer m_trailer;
  bool m_validStructure;
  int m_tag;
#ifdef HAVE_EMX
  std::string m_subMsgType;
#endif
  static SmartPtr<DataDictionary> s_dataDictionary;
};

/*! @} */
inline std::ostream& operator <<
( std::ostream& stream, const Message& message )
{
  std::string str;
  stream << message.toString( str );
  return stream;
}

/// Parse the type of a message from a string.
inline MsgType identifyType( const std::string& message )
EXCEPT ( MessageParseError )
{
  std::string::size_type pos = message.find( "\001" "35=" );
  if ( pos == std::string::npos ) throw MessageParseError();

  std::string::size_type startValue = pos + 4;
  std::string::size_type soh = message.find_first_of( '\001', startValue );
  if ( soh == std::string::npos ) throw MessageParseError();

  std::string value = message.substr( startValue, soh - startValue );
  return MsgType( value );
}
Message.h中定义的Message类继承自类FieldMap，是不同FIX协议版本实现的Message基类，并且包含3个FiledMap，分别为消息头、消息体、消息尾。
FieldMap类是Message类的基类，用于存储和组织FIX消息字段集合，如消息头、消息体、消息尾。
5、不同FIX协议实现
src/C++目录中fix40、fix41、fix42、fix43、fix44、fix50、fix50sp1、fix50sp2、fixt11是针对不同FIX协议版本的实现，其代码使用不同命名空间进行限定。FIX42的Message.h文件如下：
namespace FIX42
{
  class Header : public FIX::Header
  {
  public:
    FIELD_SET(*this, FIX::BeginString);
    FIELD_SET(*this, FIX::BodyLength);
    FIELD_SET(*this, FIX::MsgType);
    FIELD_SET(*this, FIX::SenderCompID);
    FIELD_SET(*this, FIX::TargetCompID);
    FIELD_SET(*this, FIX::OnBehalfOfCompID);
    FIELD_SET(*this, FIX::DeliverToCompID);
    FIELD_SET(*this, FIX::SecureDataLen);
    FIELD_SET(*this, FIX::SecureData);
    FIELD_SET(*this, FIX::MsgSeqNum);
    FIELD_SET(*this, FIX::SenderSubID);
    FIELD_SET(*this, FIX::SenderLocationID);
    FIELD_SET(*this, FIX::TargetSubID);
    FIELD_SET(*this, FIX::TargetLocationID);
    FIELD_SET(*this, FIX::OnBehalfOfSubID);
    FIELD_SET(*this, FIX::OnBehalfOfLocationID);
    FIELD_SET(*this, FIX::DeliverToSubID);
    FIELD_SET(*this, FIX::DeliverToLocationID);
    FIELD_SET(*this, FIX::PossDupFlag);
    FIELD_SET(*this, FIX::PossResend);
    FIELD_SET(*this, FIX::SendingTime);
    FIELD_SET(*this, FIX::OrigSendingTime);
    FIELD_SET(*this, FIX::XmlDataLen);
    FIELD_SET(*this, FIX::XmlData);
    FIELD_SET(*this, FIX::MessageEncoding);
    FIELD_SET(*this, FIX::LastMsgSeqNumProcessed);
    FIELD_SET(*this, FIX::OnBehalfOfSendingTime);
  };

  class Trailer : public FIX::Trailer
  {
  public:
    FIELD_SET(*this, FIX::SignatureLength);
    FIELD_SET(*this, FIX::Signature);
    FIELD_SET(*this, FIX::CheckSum);
  };

  class Message : public FIX::Message
  {
  public:
    Message( const FIX::MsgType& msgtype )
    : FIX::Message(
      FIX::BeginString("FIX.4.2"), msgtype )
     {} 

    Message(const FIX::Message& m) : FIX::Message(m) {}
    Message(const Message& m) : FIX::Message(m) {}
    Header& getHeader() { return (Header&)m_header; }
    const Header& getHeader() const { return (Header&)m_header; }
    Trailer& getTrailer() { return (Trailer&)m_trailer; }
    const Trailer& getTrailer() const { return (Trailer&)m_trailer; }
  };
}
FIX42协议解析的MessageCracker类定义如下：
namespace FIX42
{

class MessageCracker
{
public:
    virtual ~MessageCracker() {}
    virtual void onMessage( const Message&, const FIX::SessionID& )
    {
        throw FIX::UnsupportedMessageType();
    }

    virtual void onMessage( Message&, const FIX::SessionID& )
    {
        throw FIX::UnsupportedMessageType();
    }

    virtual void onMessage( const Heartbeat&, const FIX::SessionID& )
    {}

    virtual void onMessage( const TestRequest&, const FIX::SessionID& )
    {}

    virtual void onMessage( const ResendRequest&, const FIX::SessionID& )
    {}

    virtual void onMessage( const Reject&, const FIX::SessionID& )
    {}

    virtual void onMessage( const SequenceReset&, const FIX::SessionID& )
    {}

    virtual void onMessage( const Logout&, const FIX::SessionID& )

    {}

    virtual void onMessage( const ExecutionReport&, const FIX::SessionID& )
    {
        throw FIX::UnsupportedMessageType();
    }

    virtual void onMessage( const OrderCancelReject&, const FIX::SessionID& )
    {
        throw FIX::UnsupportedMessageType();
    }

    virtual void onMessage( const Logon&, const FIX::SessionID& )
    {}

    virtual void onMessage( const NewOrderSingle&, const FIX::SessionID& )
    {
        throw FIX::UnsupportedMessageType();
    }

    virtual void onMessage( const OrderCancelRequest&, const FIX::SessionID& )
    {
        throw FIX::UnsupportedMessageType();
    }

    virtual void onMessage( const OrderStatusRequest&, const FIX::SessionID& )
    {
        throw FIX::UnsupportedMessageType();
    }

    virtual void onMessage( Heartbeat&, const FIX::SessionID& ) {}
public:
    void crack( const Message& message,
                const FIX::SessionID& sessionID )
    {
        const std::string& msgTypeValue
            = message.getHeader().getField( FIX::FIELD::MsgType );

        if( msgTypeValue == "0" )
            onMessage( (const Heartbeat&)message, sessionID );
        else if( msgTypeValue == "1" )
            onMessage( (const TestRequest&)message, sessionID );
        else if( msgTypeValue == "2" )
            onMessage( (const ResendRequest&)message, sessionID );
        else if( msgTypeValue == "3" )
            onMessage( (const Reject&)message, sessionID );
        else if( msgTypeValue == "4" )
            onMessage( (const SequenceReset&)message, sessionID );
        else if( msgTypeValue == "5" )
            onMessage( (const Logout&)message, sessionID );
        else if( msgTypeValue == "6" )
            onMessage( (const IOI&)message, sessionID );
        else if( msgTypeValue == "7" )
            onMessage( (const Advertisement&)message, sessionID );
        else if( msgTypeValue == "8" )
            onMessage( (const ExecutionReport&)message, sessionID );
        else if( msgTypeValue == "9" )
            onMessage( (const OrderCancelReject&)message, sessionID );
        else if( msgTypeValue == "A" )
            onMessage( (const Logon&)message, sessionID );
        else if( msgTypeValue == "B" )
            onMessage( (const News&)message, sessionID );
        else if( msgTypeValue == "C" )
            onMessage( (const Email&)message, sessionID );
        else if( msgTypeValue == "D" )
            onMessage( (const NewOrderSingle&)message, sessionID );
        else if( msgTypeValue == "E" )
            onMessage( (const NewOrderList&)message, sessionID );
        else if( msgTypeValue == "F" )
            onMessage( (const OrderCancelRequest&)message, sessionID );
        else if( msgTypeValue == "G" )
            onMessage( (const OrderCancelReplaceRequest&)message, sessionID );
        else if( msgTypeValue == "H" )
            onMessage( (const OrderStatusRequest&)message, sessionID );
        else if( msgTypeValue == "J" )
            onMessage( (const Allocation&)message, sessionID );
        else if( msgTypeValue == "K" )
            onMessage( (const ListCancelRequest&)message, sessionID );
        else if( msgTypeValue == "L" )
            onMessage( (const ListExecute&)message, sessionID );
        else if( msgTypeValue == "M" )
            onMessage( (const ListStatusRequest&)message, sessionID );
        else if( msgTypeValue == "N" )
            onMessage( (const ListStatus&)message, sessionID );
        else if( msgTypeValue == "P" )
            onMessage( (const AllocationInstructionAck&)message, sessionID );
        else if( msgTypeValue == "Q" )
            onMessage( (const DontKnowTrade&)message, sessionID );
        else if( msgTypeValue == "R" )
            onMessage( (const QuoteRequest&)message, sessionID );
        else if( msgTypeValue == "S" )
            onMessage( (const Quote&)message, sessionID );
        else if( msgTypeValue == "T" )
            onMessage( (const SettlementInstructions&)message, sessionID );
        else if( msgTypeValue == "V" )
            onMessage( (const MarketDataRequest&)message, sessionID );
        else if( msgTypeValue == "W" )
            onMessage( (const MarketDataSnapshotFullRefresh&)message, sessionID );
        else if( msgTypeValue == "X" )
            onMessage( (const MarketDataIncrementalRefresh&)message, sessionID );
        else if( msgTypeValue == "Y" )
            onMessage( (const MarketDataRequestReject&)message, sessionID );
        else if( msgTypeValue == "Z" )
            onMessage( (const QuoteCancel&)message, sessionID );
        else if( msgTypeValue == "a" )
            onMessage( (const QuoteStatusRequest&)message, sessionID );
        else if( msgTypeValue == "b" )
            onMessage( (const QuoteAcknowledgement&)message, sessionID );
        else if( msgTypeValue == "c" )
            onMessage( (const SecurityDefinitionRequest&)message, sessionID );
        else if( msgTypeValue == "d" )
            onMessage( (const SecurityDefinition&)message, sessionID );
        else if( msgTypeValue == "e" )
            onMessage( (const SecurityStatusRequest&)message, sessionID );
        else if( msgTypeValue == "f" )
            onMessage( (const SecurityStatus&)message, sessionID );
        else if( msgTypeValue == "g" )
            onMessage( (const TradingSessionStatusRequest&)message, sessionID );
        else if( msgTypeValue == "h" )
            onMessage( (const TradingSessionStatus&)message, sessionID );
        else if( msgTypeValue == "i" )
            onMessage( (const MassQuote&)message, sessionID );
        else if( msgTypeValue == "j" )
            onMessage( (const BusinessMessageReject&)message, sessionID );
        else if( msgTypeValue == "k" )
            onMessage( (const BidRequest&)message, sessionID );
        else if( msgTypeValue == "l" )
            onMessage( (const BidResponse&)message, sessionID );
        else if( msgTypeValue == "m" )
            onMessage( (const ListStrikePrice&)message, sessionID );
        else onMessage( message, sessionID );
    }

    void crack( Message& message,
                const FIX::SessionID& sessionID )
    {
        FIX::MsgType msgType;
        message.getHeader().getField(msgType);
        std::string msgTypeValue = msgType.getValue();

        if( msgTypeValue == "0" )
            onMessage( (Heartbeat&)message, sessionID );
        else if( msgTypeValue == "1" )
            onMessage( (TestRequest&)message, sessionID );
        else if( msgTypeValue == "2" )
            onMessage( (ResendRequest&)message, sessionID );
        else if( msgTypeValue == "3" )
            onMessage( (Reject&)message, sessionID );
        else if( msgTypeValue == "4" )
            onMessage( (SequenceReset&)message, sessionID );
        else if( msgTypeValue == "5" )
            onMessage( (Logout&)message, sessionID );
        else if( msgTypeValue == "6" )
            onMessage( (IOI&)message, sessionID );
        else if( msgTypeValue == "7" )
            onMessage( (Advertisement&)message, sessionID );
        else if( msgTypeValue == "8" )
            onMessage( (ExecutionReport&)message, sessionID );
        else if( msgTypeValue == "9" )
            onMessage( (OrderCancelReject&)message, sessionID );
        else if( msgTypeValue == "A" )
            onMessage( (Logon&)message, sessionID );
        else if( msgTypeValue == "B" )
            onMessage( (News&)message, sessionID );
        else if( msgTypeValue == "C" )
            onMessage( (Email&)message, sessionID );
        else if( msgTypeValue == "D" )
            onMessage( (NewOrderSingle&)message, sessionID );
        else if( msgTypeValue == "E" )
            onMessage( (NewOrderList&)message, sessionID );
        else if( msgTypeValue == "F" )
            onMessage( (OrderCancelRequest&)message, sessionID );
        else if( msgTypeValue == "G" )
            onMessage( (OrderCancelReplaceRequest&)message, sessionID );
        else if( msgTypeValue == "H" )
            onMessage( (OrderStatusRequest&)message, sessionID );
        else if( msgTypeValue == "J" )
            onMessage( (Allocation&)message, sessionID );
        else if( msgTypeValue == "K" )
            onMessage( (ListCancelRequest&)message, sessionID );
        else if( msgTypeValue == "L" )
            onMessage( (ListExecute&)message, sessionID );
        else if( msgTypeValue == "M" )
            onMessage( (ListStatusRequest&)message, sessionID );
        else if( msgTypeValue == "N" )
            onMessage( (ListStatus&)message, sessionID );
        else if( msgTypeValue == "P" )
            onMessage( (AllocationInstructionAck&)message, sessionID );
        else if( msgTypeValue == "Q" )
            onMessage( (DontKnowTrade&)message, sessionID );
        else if( msgTypeValue == "R" )
            onMessage( (QuoteRequest&)message, sessionID );
        else if( msgTypeValue == "S" )
            onMessage( (Quote&)message, sessionID );
        else if( msgTypeValue == "T" )
            onMessage( (SettlementInstructions&)message, sessionID );
        else if( msgTypeValue == "V" )
            onMessage( (MarketDataRequest&)message, sessionID );
        else if( msgTypeValue == "W" )
            onMessage( (MarketDataSnapshotFullRefresh&)message, sessionID );
        else if( msgTypeValue == "X" )
            onMessage( (MarketDataIncrementalRefresh&)message, sessionID );
        else if( msgTypeValue == "Y" )
            onMessage( (MarketDataRequestReject&)message, sessionID );
        else if( msgTypeValue == "Z" )
            onMessage( (QuoteCancel&)message, sessionID );
        else if( msgTypeValue == "a" )
            onMessage( (QuoteStatusRequest&)message, sessionID );
        else if( msgTypeValue == "b" )
            onMessage( (QuoteAcknowledgement&)message, sessionID );
        else if( msgTypeValue == "c" )
            onMessage( (SecurityDefinitionRequest&)message, sessionID );
        else if( msgTypeValue == "d" )
            onMessage( (SecurityDefinition&)message, sessionID );
        else if( msgTypeValue == "e" )
            onMessage( (SecurityStatusRequest&)message, sessionID );
        else if( msgTypeValue == "f" )
            onMessage( (SecurityStatus&)message, sessionID );
        else if( msgTypeValue == "g" )
            onMessage( (TradingSessionStatusRequest&)message, sessionID );
        else if( msgTypeValue == "h" )
            onMessage( (TradingSessionStatus&)message, sessionID );
        else if( msgTypeValue == "i" )
            onMessage( (MassQuote&)message, sessionID );
        else if( msgTypeValue == "j" )
            onMessage( (BusinessMessageReject&)message, sessionID );
        else if( msgTypeValue == "k" )
            onMessage( (BidRequest&)message, sessionID );
        else if( msgTypeValue == "l" )
            onMessage( (BidResponse&)message, sessionID );
        else if( msgTypeValue == "m" )
            onMessage( (ListStrikePrice&)message, sessionID );
        else onMessage( message, sessionID );
    }
};

}
6、TCP Socket封装
SocketConnection类封装了TCP Socket客户端连接的相关操作，IO操作使用Select，SocketConnection类定义如下：
/// Encapsulates a socket file descriptor (single-threaded).
class SocketConnection : Responder
{
public:
  typedef std::set<SessionID> Sessions;

  SocketConnection( socket_handle s, Sessions sessions, SocketMonitor* pMonitor );
  SocketConnection( SocketInitiator&, const SessionID&, socket_handle, SocketMonitor* );
  virtual ~SocketConnection();

  socket_handle getSocket() const { return m_socket; }
  Session* getSession() const { return m_pSession; }

  bool read( SocketConnector& s );
  bool read( SocketAcceptor&, SocketServer& );
  bool processQueue();

  void signal()
  {
    Locker l( m_mutex );
    if( m_sendQueue.size() == 1 )
      m_pMonitor->signal( m_socket );
  }

  void unsignal()
  {
    Locker l( m_mutex );
    if( m_sendQueue.size() == 0 )
      m_pMonitor->unsignal( m_socket );
  }

  void onTimeout();
private:
  typedef std::deque<std::string, ALLOCATOR<std::string> > Queue;

  bool isValidSession();
  void readFromSocket() EXCEPT ( SocketRecvFailed );
  bool readMessage( std::string& msg );
  void readMessages( SocketMonitor& s );
  bool send( const std::string& );
  void disconnect();

  socket_handle m_socket;
  char m_buffer[BUFSIZ];

  Parser m_parser;
  Queue m_sendQueue;
  unsigned m_sendLength;
  Sessions m_sessions;
  Session* m_pSession;
  SocketMonitor* m_pMonitor;
  Mutex m_mutex;
  fd_set m_fds;
};
ThreadedSocketConnection类封装了支持多线程的TCP Socket客户端连接的相关操作，IO操作使用Select；SSLSocketConnection类封装了支持SSL的TCP Socket客户端连接的相关操作，IO操作使用Select；ThreadedSSLSocketConnection类封装了支持SSL以及多线程支持的TCP Socket客户端连接的相关操作，IO操作使用Select。
SocketConnector类封装了Socket连接远程服务端的操作。
SocketMonitor类封装了对Socket连接集合的事件的监听操作。
/// Monitors events on a collection of sockets.
class SocketMonitor
{
public:
    class Strategy;

    SocketMonitor( int timeout = 0 );
    virtual ~SocketMonitor();

    bool addConnect(socket_handle socket );
    bool addRead(socket_handle socket );
    bool addWrite(socket_handle socket );
    bool drop(socket_handle socket );
    void signal(socket_handle socket );
    void unsignal(socket_handle socket );
    void block( Strategy& strategy, bool poll = 0, double timeout = 0.0 );

    size_t numSockets()
    {
        return m_readSockets.size() - 1;
    }
private:
    typedef std::set < socket_handle > Sockets;
    typedef std::queue < socket_handle > Queue;

    void setsockopt();
    bool bind();
    bool listen();
    void buildSet( const Sockets&, fd_set& );
    inline timeval* getTimeval( bool poll, double timeout );
    inline bool sleepIfEmpty( bool poll );

    void processReadSet( Strategy&, fd_set& );
    void processWriteSet( Strategy&, fd_set& );
    void processExceptSet( Strategy&, fd_set& );

    int m_timeout;
    timeval m_timeval;
#ifndef SELECT_DECREMENTS_TIME
    clock_t m_ticks;
#endif

    socket_handle m_signal;
    socket_handle m_interrupt;
    Sockets m_connectSockets;
    Sockets m_readSockets;
    Sockets m_writeSockets;
    Queue m_dropped;
public:
    class Strategy
    {
    public:
        virtual ~Strategy()
        {}

        virtual void onConnect( SocketMonitor&, socket_handle socket ) = 0;
        virtual void onEvent( SocketMonitor&, socket_handle socket ) = 0;
        virtual void onWrite( SocketMonitor&, socket_handle socket ) = 0;
        virtual void onError( SocketMonitor&, socket_handle socket ) = 0;
        virtual void onError( SocketMonitor& ) = 0;
        virtual void onTimeout( SocketMonitor& )
        {}
    }
    ;
};

SocketServer类封装了Socket服务端实现的相关操作，SocketServer类定义如下：
/// Listens for and accepts incoming socket connections on a port.
class SocketServer
{
public:
  class Strategy;

  SocketServer( int timeout = 0 );
  socket_handle add( int port, bool reuse = false, bool noDelay = false,
           int sendBufSize = 0, int rcvBufSize = 0 ) EXCEPT( SocketException& );
  socket_handle accept(socket_handle socket );
  void close();
  bool block( Strategy& strategy, bool poll = 0, double timeout = 0.0 );

  size_t numConnections() { return m_monitor.numSockets() - 1; }
  SocketMonitor& getMonitor() { return m_monitor; }

  int socketToPort(socket_handle socket );
  socket_handle portToSocket( int port );
private:
  typedef std::map<socket_handle, SocketInfo> SocketToInfo;
  typedef std::map<int, SocketInfo> PortToInfo;

  SocketToInfo m_socketToInfo;  
  PortToInfo m_portToInfo;
  SocketMonitor m_monitor;
public:
  class Strategy
  {
  public:
    virtual ~Strategy() {}
    virtual void onConnect( SocketServer&, socket_handle acceptSocket, 
                            socket_handle socket ) = 0;
    virtual void onWrite( SocketServer&, socket_handle socket ) = 0;
    virtual bool onData( SocketServer&, socket_handle socket ) = 0;
    virtual void onDisconnect( SocketServer&, socket_handle socket ) = 0;
    virtual void onError( SocketServer& ) = 0;
    virtual void onTimeout( SocketServer& ) {};
  };
};
7、FIX Session配置解析
SessionSettings类实现了FIX Session配置文件解析，SessionSettings.h如下：
class SessionSettings
{
public:
  SessionSettings() { m_resolveEnvVars = false; }
  SessionSettings( std::istream& stream, bool resolveEnvVars = false ) 
    EXCEPT ( ConfigError );
  SessionSettings( const std::string& file, bool resolveEnvVars = false ) 
    EXCEPT ( ConfigError );

  /// Check if session setings are present
  const bool has( const SessionID& ) const;

  /// Get a dictionary for a session.
  const Dictionary& get( const SessionID& ) const EXCEPT ( ConfigError );

  /// Set a dictionary for a session
  void set( const SessionID&, Dictionary ) EXCEPT ( ConfigError );

  /// Get global default settings
  const Dictionary& get() const { return m_defaults; }

  /// Set global default settings
  void set( const Dictionary& defaults ) EXCEPT ( ConfigError );

  /// Number of session settings
  size_t size() const { return m_settings.size(); }

  typedef std::map < SessionID, Dictionary > Dictionaries;
  std::set < SessionID > getSessions() const;
private:
  void validate( const Dictionary& ) const EXCEPT ( ConfigError );
  Dictionaries m_settings;
  Dictionary m_defaults;
  bool m_resolveEnvVars;  // while reading, replace $var, $(var) and ${var} by environment variable var

  friend std::istream& operator>>( std::istream&, SessionSettings& ) 
    EXCEPT ( ConfigError );
  friend std::ostream& operator<<( std::ostream&, const SessionSettings& );
};
8、FIX Session封装
FIX::Session提供了FIX Session的相关操作，常用的sendToTarget方法声明如下：
static bool FIX::Session::sendToTarget( Message& message,
                                        const std::string& qualifier = "" )
EXCEPT ( SessionNotFound );

static bool FIX::Session::sendToTarget( Message& message,
                                        const SessionID& sessionID )
EXCEPT ( SessionNotFound );

static bool FIX::Session::sendToTarget( Message&,
                          const SenderCompID& senderCompID,
                          const TargetCompID& targetCompID,
                          const std::string& qualifier = "" )
EXCEPT ( SessionNotFound );

static bool FIX::Session::sendToTarget( Message& message,
                          const std::string& senderCompID,
                          const std::string& targetCompID,
                          const std::string& qualifier = "" )
EXCEPT ( SessionNotFound );
9、SocketInitiator
QuickFIX中，Initiator客户端基于SocketConnection客户端连接实现，SocketInitiator类定义如下：
/// Socket implementation of Initiator.
class SocketInitiator : public Initiator, SocketConnector::Strategy
{
public:
  SocketInitiator( Application&, MessageStoreFactory&,
                   const SessionSettings& ) EXCEPT ( ConfigError );

  SocketInitiator( Application&, MessageStoreFactory&,
                   const SessionSettings&, LogFactory& ) EXCEPT ( ConfigError );

  virtual ~SocketInitiator();
private:
  typedef std::map < socket_handle, SocketConnection* > SocketConnections;
  typedef std::map < SessionID, int > SessionToHostNum;

  void onConfigure( const SessionSettings& ) EXCEPT ( ConfigError );
  void onInitialize( const SessionSettings& ) EXCEPT ( RuntimeError );

  void onStart();
  bool onPoll( double timeout );
  void onStop();

  void doConnect( const SessionID&, const Dictionary& d );
  void onConnect( SocketConnector&, socket_handle);
  void onWrite( SocketConnector&, socket_handle);
  bool onData( SocketConnector&, socket_handle);
  void onDisconnect( SocketConnector&, socket_handle);
  void onError( SocketConnector& );
  void onTimeout( SocketConnector& );

  void getHost( const SessionID&, const Dictionary&, std::string&, 
                short&, std::string&, short& );

  SessionSettings m_settings;
  SessionToHostNum m_sessionToHostNum;
  SocketConnector m_connector;
  SocketConnections m_pendingConnections;
  SocketConnections m_connections;
  time_t m_lastConnect;
  int m_reconnectInterval;
  bool m_noDelay;
  int m_sendBufSize;
  int m_rcvBufSize;
};
SSLSocketInitiator是支持SSL的Initiator客户端实现。
ThreadedSocketInitiator是支持多线程的Initiator客户端实现。
ThreadedSSLSocketInitiator是支持SSL和多线程的Initiator客户端实现。
10、SocketAcceptor
QuickFIX中，Acceptor服务端基于SocketServer实现。SocketAcceptor类定义如下：
/// Socket implementation of Acceptor.
class SocketAcceptor : public Acceptor, SocketServer::Strategy
{
  friend class SocketConnection;
public:
  SocketAcceptor( Application&, MessageStoreFactory&,
                  const SessionSettings& ) EXCEPT ( ConfigError );
  SocketAcceptor( Application&, MessageStoreFactory&,
                  const SessionSettings&, LogFactory& ) EXCEPT ( ConfigError );

  virtual ~SocketAcceptor();
private:
  bool readSettings( const SessionSettings& );
  typedef std::set < SessionID > Sessions;
  typedef std::map < int, Sessions > PortToSessions;
  typedef std::map < socket_handle, SocketConnection* > SocketConnections;

  void onConfigure( const SessionSettings& ) EXCEPT ( ConfigError );
  void onInitialize( const SessionSettings& ) EXCEPT ( RuntimeError );

  void onStart();
  bool onPoll( double timeout );
  void onStop();

  void onConnect( SocketServer&, socket_handle, socket_handle );
  void onWrite( SocketServer&, socket_handle );
  bool onData( SocketServer&, socket_handle );
  void onDisconnect( SocketServer&, socket_handle );
  void onError( SocketServer& );
  void onTimeout( SocketServer& );

  SocketServer* m_pServer;
  PortToSessions m_portToSessions;
  SocketConnections m_connections;
};
SSLSocketAcceptor是支持SSL的Acceptor应用实现。
ThreadedSocketAcceptor是支持多线程的Acceptor应用实现。
ThreadedSSLSocketAcceptor是支持SSL和多线程的Acceptor应用实现。
11、Fix Application
FIX::Application接口定义如下：
class Application
{
public:
  virtual ~Application() {};

  /// Notification of a session begin created
  virtual void onCreate( const SessionID& ) = 0;

  /// Notification of a session successfully logging on
  virtual void onLogon( const SessionID& ) = 0;

  /// Notification of a session logging off or disconnecting
  virtual void onLogout( const SessionID& ) = 0;

  /// Notification of admin message being sent to target
  virtual void toAdmin( Message&, const SessionID& ) = 0;

  /// Notification of app message being sent to target
  virtual void toApp( Message&, const SessionID& )
  EXCEPT ( DoNotSend ) = 0;

  /// Notification of admin message being received from target
  virtual void fromAdmin( const Message&, const SessionID& )
  EXCEPT ( FieldNotFound, IncorrectDataFormat, IncorrectTagValue, RejectLogon ) = 0;

  /// Notification of app message being received from target
  virtual void fromApp( const Message&, const SessionID& )
  EXCEPT ( FieldNotFound, IncorrectDataFormat, IncorrectTagValue, 
            UnsupportedMessageType ) = 0;
};
对于FIX应用开发，除了实现FIX::Application接口，还需要重新实现FIX::MessageCracker从具体的FIX协议版本实现继承而来的onMessage方法，如FIX42::MessageCracker部分接口如下：
class MessageCracker
{
public:
    virtual ~MessageCracker() {}
    virtual void onMessage( const Message&, const FIX::SessionID& )
    {
        throw FIX::UnsupportedMessageType();
    }

    virtual void onMessage( Message&, const FIX::SessionID& )
    {
        throw FIX::UnsupportedMessageType();
    }

    virtual void onMessage( const Heartbeat&, const FIX::SessionID& ){}
    virtual void onMessage( const TestRequest&, const FIX::SessionID& ){}
    virtual void onMessage( const ResendRequest&, const FIX::SessionID& ){}
    virtual void onMessage( const Reject&, const FIX::SessionID& ){}
    virtual void onMessage( const SequenceReset&, const FIX::SessionID& ){}
    virtual void onMessage( const Logout&, const FIX::SessionID& ){}
    virtual void onMessage( const ExecutionReport&, const FIX::SessionID& )
    {
        throw FIX::UnsupportedMessageType();
    }

    virtual void onMessage( const OrderCancelReject&, const FIX::SessionID& )
    {
        throw FIX::UnsupportedMessageType();
    }

    virtual void onMessage( const Logon&, const FIX::SessionID& ){}
    virtual void onMessage( const NewOrderSingle&, const FIX::SessionID& )
    {
        throw FIX::UnsupportedMessageType();
    }

    virtual void onMessage( const OrderCancelRequest&, const FIX::SessionID& )
    {
        throw FIX::UnsupportedMessageType();
    }

    virtual void onMessage( const OrderStatusRequest&, const FIX::SessionID& )
    {
        throw FIX::UnsupportedMessageType();
    }

    virtual void onMessage( const BusinessMessageReject&, const FIX::SessionID& ){}
    virtual void onMessage( Heartbeat&, const FIX::SessionID& ) {}
    virtual void onMessage( TestRequest&, const FIX::SessionID& ) {}
    virtual void onMessage( ResendRequest&, const FIX::SessionID& ) {}
    virtual void onMessage( Reject&, const FIX::SessionID& ) {}
    virtual void onMessage( SequenceReset&, const FIX::SessionID& ) {}
    virtual void onMessage( Logout&, const FIX::SessionID& ) {}
    virtual void onMessage( ExecutionReport&, const FIX::SessionID& ) {}
    virtual void onMessage( OrderCancelReject&, const FIX::SessionID& ) {}
    virtual void onMessage( Logon&, const FIX::SessionID& ) {}
    virtual void onMessage( NewOrderSingle&, const FIX::SessionID& ) {}
    virtual void onMessage( OrderCancelRequest&, const FIX::SessionID& ) {}
    virtual void onMessage( OrderStatusRequest&, const FIX::SessionID& ) {}
};
三、示例程序
1、示例程序简介
QuickFIX示例程序位于quickfix/examples目录。
ordermatch：FIX交易网关服务，撮合限价单。
tradeclient ：控制台交易客户端。
tradeclientgui：Java GUI交易客户端。
executor：对接收的限价单申报返回成交回报。
2、ordermatch
ordermatch示例包含IDGenerator、Order、OrderMatcher、Market、ordermatch、Application。
IDGenerator：ID生成器
Order：订单类
OrderMatcher：撮合引擎
Market：订单簿
Application：FIX Application
ordermatch：程序入口
IDGenerator.h文件：
#ifndef IDGENERATOR_H
#define IDGENERATOR_H

#include <string>
#include <sstream>

class IDGenerator
{
public:
  IDGenerator() : m_orderID(0), m_executionID(0) 
  {

  }

  std::string genOrderID()
  {
    m_stream.clear();
    m_stream.str("");
    m_stream << ++m_orderID;
    return m_stream.str();
  }

  std::string genExecutionID()
  {
    m_stream.clear();
    m_stream.str("");
    m_stream << ++m_executionID;
    return m_stream.str();
  }
private:
  long m_orderID;
  long m_executionID;
  std::stringstream m_stream;
};

#endif
Order.h文件：
#ifndef ORDER_H
#define ORDER_H

#include <string>
#include <iomanip>
#include <ostream>

class Order
{
  friend std::ostream& operator<<( std::ostream&, const Order& );
public:
  enum Side { buy, sell };
  enum Type { market, limit };
  Order( const std::string& clientId, const std::string& symbol,
         const std::string& owner, const std::string& target,
         Side side, Type type, double price, long quantity )
: m_clientId( clientId ), m_symbol( symbol ), m_owner( owner ),m_target( target ), 
m_side( side ), m_type( type ), m_price( price ),m_quantity( quantity )
  {
    m_openQuantity = m_quantity;
    m_executedQuantity = 0;
    m_avgExecutedPrice = 0;
    m_lastExecutedPrice = 0;
    m_lastExecutedQuantity = 0;
  }

  const std::string& getClientID() const 
  { 
    return m_clientId; 
  }

  const std::string& getSymbol() const 
  { 
    return m_symbol; 
  }

  const std::string& getOwner() const 
  { 
    return m_owner; 
  }

  const std::string& getTarget() const 
  { 
    return m_target; 
  }

  Side getSide() const 
  { 
    return m_side; 
  }

  Type getType() const 
  {
    return m_type; 
  }

  double getPrice() const 
  { 
    return m_price; 
  }

  long getQuantity() const 
  { 
    return m_quantity; 
  }

  long getOpenQuantity() const 
  { 
    return m_openQuantity; 
  }

  long getExecutedQuantity() const 
  { 
    return m_executedQuantity; 
  }

  double getAvgExecutedPrice() const 
  { 
    return m_avgExecutedPrice; 
  }

  double getLastExecutedPrice() const 
  { 
    return m_lastExecutedPrice; 
  }

  long getLastExecutedQuantity() const 
  { 
    return m_lastExecutedQuantity; 
  }

  bool isFilled() const 
  { 
    return m_quantity == m_executedQuantity; 
  }

  bool isClosed() const 
  { 
    return m_openQuantity == 0; 
  }

  void execute( double price, long quantity )
  {
    m_avgExecutedPrice =
      ( ( quantity * price ) + ( m_avgExecutedPrice * m_executedQuantity ) )
      / ( quantity + m_executedQuantity );

    m_openQuantity -= quantity;
    m_executedQuantity += quantity;
    m_lastExecutedPrice = price;
    m_lastExecutedQuantity = quantity;
  }

  void cancel()
  {
    m_openQuantity = 0;
  }
private:
  std::string m_clientId;// 客户端ID
  std::string m_symbol;// Ticker
  std::string m_owner;// 本地端
  std::string m_target;// 目标端
  Side m_side;// 买卖方向
  Type m_type;// 订单类型
  double m_price;// 委托价格
  long m_quantity;// 委托数量
  long m_openQuantity;
  long m_executedQuantity;
  double m_avgExecutedPrice;
  double m_lastExecutedPrice;
  long m_lastExecutedQuantity;
};

inline std::ostream& operator<<( std::ostream& ostream, const Order& order )
{
  return ostream
         << "ID: " <<  order.getClientID()
         << " Ticker: " << order.getSymbol()
         << " OWNER: " << order.getOwner()
         << " PRICE: " << order.getPrice()
         << " OPENQUANTITY: " << order.getOpenQuantity();
}

#endif
Market.h文件：
#ifndef MARKET_H
#define MARKET_H

#include "Order.h"
#include <map>
#include <queue>
#include <string>
#include <functional>

class Market
{
public:
  // 插入新订单到订单队列
  bool insert( const Order& order );
  // 从订单队列中删除订单
  void erase( const Order& order );
  // 查找订单
  Order& find( Order::Side side, std::string id );
  // 撮合成交
  bool match( std::queue < Order > & );

  void display() const;
protected:
  void match( Order& bid, Order& ask );
private:
  // 买单，降序排列
  typedef std::multimap < double, Order, std::greater < double > > BidOrders;
  // 卖单，升序排序
  typedef std::multimap < double, Order, std::less < double > > AskOrders;
  BidOrders m_bidOrders;// 订单簿：买单队列
  AskOrders m_askOrders;// 订单簿：卖单队列
};

#endif
Market.cpp文件：
#include "Market.h"
#include <iostream>

bool Market::insert( const Order& order )
{
  // 买单
  if ( order.getSide() == Order::buy )
    m_bidOrders.insert( BidOrders::value_type( order.getPrice(), order ) );
  else
    m_askOrders.insert( AskOrders::value_type( order.getPrice(), order ) );
  return true;
}

void Market::erase( const Order& order )
{
  std::string id = order.getClientID();
  // 买单
  if ( order.getSide() == Order::buy )
  {
    BidOrders::iterator i;
    for ( i = m_bidOrders.begin(); i != m_bidOrders.end(); ++i )
      if ( i->second.getClientID() == id )
      {
        m_bidOrders.erase( i );
        return ;
      }
  }
  // 卖单
  else if ( order.getSide() == Order::sell )
  {
    AskOrders::iterator i;
    for ( i = m_askOrders.begin(); i != m_askOrders.end(); ++i )
      if ( i->second.getClientID() == id )
      {
        m_askOrders.erase( i );
        return ;
      }
  }
}

bool Market::match( std::queue < Order > & orders )
{
  while ( true )
  {
    if ( !m_bidOrders.size() || !m_askOrders.size() )
      return orders.size() != 0;

    BidOrders::iterator iBid = m_bidOrders.begin();
    AskOrders::iterator iAsk = m_askOrders.begin();
    // 买单队列的第一档的价格大于等于卖单队列第一档价格
    if ( iBid->second.getPrice() >= iAsk->second.getPrice() )
    {
      Order & bid = iBid->second;
      Order& ask = iAsk->second;

      match( bid, ask );
      orders.push( bid );
      orders.push( ask );

      if ( bid.isClosed() ) 
        m_bidOrders.erase( iBid );
      if ( ask.isClosed() )
        m_askOrders.erase( iAsk );
    }
    else
      return orders.size() != 0;
  }
}

Order& Market::find( Order::Side side, std::string id )
{
  // 买单
  if ( side == Order::buy )
  {
    BidOrders::iterator i;
    for ( i = m_bidOrders.begin(); i != m_bidOrders.end(); ++i )
      if ( i->second.getClientID() == id ) return i->second;
  }
  // 卖单
  else if ( side == Order::sell )
  {
    AskOrders::iterator i;
    for ( i = m_askOrders.begin(); i != m_askOrders.end(); ++i )
      if ( i->second.getClientID() == id ) return i->second;
  }
  throw std::exception();
}

void Market::match( Order& bid, Order& ask )
{
  double price = ask.getPrice();
  long quantity = 0;

  if ( bid.getOpenQuantity() > ask.getOpenQuantity() )
    quantity = ask.getOpenQuantity();
  else
    quantity = bid.getOpenQuantity();

  bid.execute( price, quantity );
  ask.execute( price, quantity );
}

void Market::display() const
{
  BidOrders::const_iterator iBid;
  AskOrders::const_iterator iAsk;

  std::cout << "BIDS:" << std::endl;
  for ( iBid = m_bidOrders.begin(); iBid != m_bidOrders.end(); ++iBid )
    std::cout << iBid->second << std::endl;

  std::cout << std::endl << std::endl;

  std::cout << "ASKS:" << std::endl;
  for ( iAsk = m_askOrders.begin(); iAsk != m_askOrders.end(); ++iAsk )
    std::cout << iAsk->second << std::endl;
}
OrderMatch.h文件：
#ifndef ORDERMATCHER_H
#define ORDERMATCHER_H

#include "Market.h"
#include <map>
#include <iostream>

class OrderMatcher
{
  typedef std::map < std::string, Market > Markets;
public:
  // 插入订单
  bool insert( const Order& order )
  {
    Markets::iterator i = m_markets.find( order.getSymbol() );
    if ( i == m_markets.end() )
      i = m_markets.insert( std::make_pair( order.getSymbol(), Market() ) ).first;
    return i->second.insert( order );
  }

  // 删除订单
  void erase( const Order& order )
  {
    Markets::iterator i = m_markets.find( order.getSymbol() );
    if ( i == m_markets.end() ) 
      return ;
    i->second.erase( order );
  }

  // 订单查找
  Order& find(const std::string symbol, Order::Side side, std::string id )
  {
    Markets::iterator i = m_markets.find( symbol );
    if ( i == m_markets.end() ) 
      throw std::exception();
    return i->second.find( side, id );
  }

  // 撮合成交
  bool match( const std::string symbol, std::queue < Order > & orders )
  {
    Markets::iterator i = m_markets.find( symbol );
    if ( i == m_markets.end() ) 
      return false;
    return i->second.match( orders );
  }

  bool match( std::queue < Order > & orders )
  {
    Markets::iterator i;
    for ( i = m_markets.begin(); i != m_markets.end(); ++i )
      i->second.match( orders );
    return orders.size() != 0;
  }

  void display( std::string symbol ) const
  {
    Markets::const_iterator i = m_markets.find( symbol );
    if ( i == m_markets.end() )
      return ;
    i->second.display();
  }

  void display() const
  {
    std::cout << "SYMBOLS:" << std::endl;
    std::cout << "--------" << std::endl;
    Markets::const_iterator i;
    for ( i = m_markets.begin(); i != m_markets.end(); ++i )
    {
      i->second.display();
    }
  }

private:
  Markets m_markets;// 全市场订单簿
};


#endif
Application.h文件：
#ifndef APPLICATION_H
#define APPLICATION_H

#include "IDGenerator.h"
#include "OrderMatcher.h"
#include "Order.h"
#include <queue>
#include <iostream>

#include "quickfix/Application.h"
#include "quickfix/MessageCracker.h"
#include "quickfix/Values.h"
#include "quickfix/Utility.h"
#include "quickfix/Mutex.h"

#include "quickfix/fix42/NewOrderSingle.h"
#include "quickfix/fix42/OrderCancelRequest.h"
#include "quickfix/fix42/MarketDataRequest.h"
#include "quickfix/fix43/MarketDataRequest.h"

class Application
      : public FIX::Application,
        public FIX::MessageCracker
{
public:
  const OrderMatcher& orderMatcher() 
  { 
    return m_orderMatcher; 
  }

protected:
  // Application overloads
  void onCreate( const FIX::SessionID& ) {}
  void onLogon( const FIX::SessionID& sessionID );
  void onLogout( const FIX::SessionID& sessionID );
  void toAdmin( FIX::Message&, const FIX::SessionID& ) {}
  void toApp( FIX::Message&, const FIX::SessionID& )
  EXCEPT( FIX::DoNotSend ) {}
  void fromAdmin( const FIX::Message&, const FIX::SessionID& )
  EXCEPT( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, 
          FIX::RejectLogon ) {}
  void fromApp( const FIX::Message& message, const FIX::SessionID& sessionID )
  EXCEPT( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, 
          FIX::UnsupportedMessageType );
protected:
  // MessageCracker overloads
  void onMessage( const FIX42::NewOrderSingle&, const FIX::SessionID& );
  void onMessage( const FIX42::OrderCancelRequest&, const FIX::SessionID& );
  void onMessage( const FIX42::MarketDataRequest&, const FIX::SessionID& );
  void onMessage( const FIX43::MarketDataRequest&, const FIX::SessionID& );
protected:
  // 订单处理
  void processOrder( const Order& );

  // 撤单处理
  void processCancel( const std::string& id, const std::string& symbol, Order::Side );

  // 订单成交回报
  void updateOrder( const Order&, char status );

  // 拒单处理
  void rejectOrder( const Order& order )
  { 
    updateOrder( order, FIX::OrdStatus_REJECTED ); 
  }

  // 委托ACK回报
  void acceptOrder( const Order& order )
  { 
    updateOrder( order, FIX::OrdStatus_NEW );
  }

  // 成交回报
  void fillOrder( const Order& order )
  {
    updateOrder( order,
                 order.isFilled() ? FIX::OrdStatus_FILLED
                 : FIX::OrdStatus_PARTIALLY_FILLED );
  }

  // 撤单回报
  void cancelOrder( const Order& order )
  { 
    updateOrder( order, FIX::OrdStatus_CANCELED ); 
  }

  // 拒单回报
  void rejectOrder( const FIX::SenderCompID&, const FIX::TargetCompID&,
                    const FIX::ClOrdID& clOrdID, const FIX::Symbol& symbol,
                    const FIX::Side& side, const std::string& message );

  // 将FIX消息的买卖方向转换为订单的买卖方向
  Order::Side convert( const FIX::Side& );

  // 将订单的买卖方向转换为FIX消息的买卖方向
  FIX::Side convert( Order::Side );

  // 将FIX消息的订单类型转换为订单的类型
  Order::Type convert( const FIX::OrdType& );

  // 将订单类型转换为FIX的订单类型
  FIX::OrdType convert( Order::Type );
private:
  OrderMatcher m_orderMatcher;// 订单撮合引擎
  IDGenerator m_generator;// ID生成器
};

#endif
Application.cpp文件：
#include "config.h"
#include "Application.h"
#include "quickfix/Session.h"

#include "quickfix/fix42/ExecutionReport.h"

void Application::onLogon( const FIX::SessionID& sessionID ) {}
void Application::onLogout( const FIX::SessionID& sessionID ) {}
void Application::fromApp( const FIX::Message& message,
                           const FIX::SessionID& sessionID )
EXCEPT( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, 
        FIX::UnsupportedMessageType )
{
  crack( message, sessionID );
}

void Application::onMessage( const FIX42::NewOrderSingle& message, 
                             const FIX::SessionID& )
{
  FIX::SenderCompID senderCompID;
  FIX::TargetCompID targetCompID;
  FIX::ClOrdID clOrdID;
  FIX::Symbol symbol;
  FIX::Side side;
  FIX::OrdType ordType;
  FIX::Price price;
  FIX::OrderQty orderQty;
  FIX::TimeInForce timeInForce( FIX::TimeInForce_DAY );

  message.getHeader().get( senderCompID );
  message.getHeader().get( targetCompID );
  message.get( clOrdID );
  message.get( symbol );
  message.get( side );
  message.get( ordType );
  // 限价单
  if ( ordType == FIX::OrdType_LIMIT )
    message.get( price );
  message.get( orderQty );
  message.getFieldIfSet( timeInForce );

  try
  {
    if ( timeInForce != FIX::TimeInForce_DAY )
      throw std::logic_error( "Unsupported TIF, use Day" );

    Order order( clOrdID, symbol, senderCompID, targetCompID,
                 convert( side ), convert( ordType ),
                 price, (long)orderQty );
    // 订单处理
    processOrder( order );
  }
  catch ( std::exception & e )
  {
    // 拒单处理
    rejectOrder( senderCompID, targetCompID, clOrdID, symbol, side, e.what() );
  }
}

void Application::onMessage( const FIX42::OrderCancelRequest& message, 
                             const FIX::SessionID& )
{
  FIX::OrigClOrdID origClOrdID;
  FIX::Symbol symbol;
  FIX::Side side;

  message.get( origClOrdID );
  message.get( symbol );
  message.get( side );

  try
  {
    // 撤单处理
    processCancel( origClOrdID, symbol, convert( side ) );
  }
  catch ( std::exception& ) {}
}



void Application::onMessage( const FIX42::MarketDataRequest& message, 
                             const FIX::SessionID& )
{
  FIX::MDReqID mdReqID;
  FIX::SubscriptionRequestType subscriptionRequestType;
  FIX::MarketDepth marketDepth;
  FIX::NoRelatedSym noRelatedSym;
  FIX42::MarketDataRequest::NoRelatedSym noRelatedSymGroup;

  message.get( mdReqID );
  message.get( subscriptionRequestType );
  if ( subscriptionRequestType != FIX::SubscriptionRequestType_SNAPSHOT )
    EXCEPT( FIX::IncorrectTagValue( subscriptionRequestType.getField() ) );
  message.get( marketDepth );
  message.get( noRelatedSym );

  for ( int i = 1; i <= noRelatedSym; ++i )
  {
    FIX::Symbol symbol;
    message.getGroup( i, noRelatedSymGroup );
    noRelatedSymGroup.get( symbol );
  }
}

void Application::onMessage( const FIX43::MarketDataRequest& message, 
                             const FIX::SessionID& )
{
    std::cout << message.toXML() << std::endl;
}

void Application::updateOrder( const Order& order, char status )
{
  FIX::TargetCompID targetCompID( order.getOwner() );
  FIX::SenderCompID senderCompID( order.getTarget() );

  FIX42::ExecutionReport fixOrder
  ( FIX::OrderID ( order.getClientID() ),
    FIX::ExecID ( m_generator.genExecutionID() ),
    FIX::ExecTransType ( FIX::ExecTransType_NEW ),
    FIX::ExecType ( status ),
    FIX::OrdStatus ( status ),
    FIX::Symbol ( order.getSymbol() ),
    FIX::Side ( convert( order.getSide() ) ),
    FIX::LeavesQty ( order.getOpenQuantity() ),
    FIX::CumQty ( order.getExecutedQuantity() ),
    FIX::AvgPx ( order.getAvgExecutedPrice() ) 
  );

  fixOrder.set( FIX::ClOrdID( order.getClientID() ) );
  fixOrder.set( FIX::OrderQty( order.getQuantity() ) );

  if ( status == FIX::OrdStatus_FILLED ||
       status == FIX::OrdStatus_PARTIALLY_FILLED )
  {
    fixOrder.set( FIX::LastShares( order.getLastExecutedQuantity() ) );
    fixOrder.set( FIX::LastPx( order.getLastExecutedPrice() ) );
  }

  try
  {
    FIX::Session::sendToTarget( fixOrder, senderCompID, targetCompID );
  }
  catch ( FIX::SessionNotFound& ) {}
}

void Application::rejectOrder
( const FIX::SenderCompID& sender, const FIX::TargetCompID& target,
  const FIX::ClOrdID& clOrdID, const FIX::Symbol& symbol,
  const FIX::Side& side, const std::string& message )
{
  FIX::TargetCompID targetCompID( sender.getValue() );
  FIX::SenderCompID senderCompID( target.getValue() );

  FIX42::ExecutionReport fixOrder
  ( FIX::OrderID ( clOrdID.getValue() ),
    FIX::ExecID ( m_generator.genExecutionID() ),
    FIX::ExecTransType ( FIX::ExecTransType_NEW ),
    FIX::ExecType ( FIX::ExecType_REJECTED ),
    FIX::OrdStatus ( FIX::ExecType_REJECTED ),
    symbol, side, FIX::LeavesQty( 0 ), FIX::CumQty( 0 ), FIX::AvgPx( 0 ) 
  );

  fixOrder.set( clOrdID );
  fixOrder.set( FIX::Text( message ) );

  try
  {
    FIX::Session::sendToTarget( fixOrder, senderCompID, targetCompID );
  }
  catch ( FIX::SessionNotFound& ) {}
}

void Application::processOrder( const Order& order )
{
  if ( m_orderMatcher.insert( order ) )
  {
    // 订单委托确认回报
    acceptOrder( order );
    std::queue < Order > orders;
    // 撮合成交
    m_orderMatcher.match( order.getSymbol(), orders );
    // 订单成交回报
    while ( orders.size() )
    {
      fillOrder( orders.front() );
      orders.pop();
    }
  }
  else
    rejectOrder( order );// 拒单回报
}

void Application::processCancel( const std::string& id,
                                 const std::string& symbol, Order::Side side )
{
  Order & order = m_orderMatcher.find( symbol, side, id );
  order.cancel();
  cancelOrder( order );
  m_orderMatcher.erase( order );
}

Order::Side Application::convert( const FIX::Side& side )
{
  switch ( side )
  {
    case FIX::Side_BUY: 
      return Order::buy;
    case FIX::Side_SELL: 
      return Order::sell;
    default: 
      throw std::logic_error( "Unsupported Side, use buy or sell" );
  }
}

Order::Type Application::convert( const FIX::OrdType& ordType )
{
  switch ( ordType )
  {
    case FIX::OrdType_LIMIT: 
      return Order::limit;
    default: 
      throw std::logic_error( "Unsupported Order Type, use limit" );
  }
}

FIX::Side Application::convert( Order::Side side )
{
  switch ( side )
  {
    case Order::buy: 
      return FIX::Side( FIX::Side_BUY );
    case Order::sell: 
      return FIX::Side( FIX::Side_SELL );
    default: 
      throw std::logic_error( "Unsupported Side, use buy or sell" );
  }
}


FIX::OrdType Application::convert( Order::Type type )
{
  switch ( type )
  {
    case Order::limit:
      return FIX::OrdType( FIX::OrdType_LIMIT );
    default: 
      throw std::logic_error( "Unsupported Order Type, use limit" );
  }
}
ordermatch.cpp文件：
#include "config.h"
#include "quickfix/FileStore.h"
#include "quickfix/SocketAcceptor.h"
#include "quickfix/SessionSettings.h"
#include "Application.h"
#include <string>
#include <iostream>
#include <fstream>

int main( int argc, char** argv )
{
  if ( argc != 2 )
  {
    std::cout << "usage: " << argv[ 0 ] << " FILE." << std::endl;
    return 0;
  }

  std::string file = argv[ 1 ];

  try
  {
    FIX::SessionSettings settings( file );

    Application application;
    FIX::FileStoreFactory storeFactory( settings );
    FIX::ScreenLogFactory logFactory( settings );
    FIX::SocketAcceptor acceptor( application, storeFactory, settings, logFactory );

    acceptor.start();
    while ( true )
    {
      application.orderMatcher().display();
      std::cout << std::endl;
      sleep(5);
    }

    acceptor.stop();
    return 0;
  }
  catch ( std::exception & e )
  {
    std::cout << e.what() << std::endl;
    return 1;
  }
}
CMakeLists.txt文件：
cmake_minimum_required(VERSION 3.10)

project(OrderMatch)

set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_COMPILER "g++")
set(CMAKE_CXX_FLAGS "-std=c++11 ${CMAKE_CXX_FLAGS}")


include_directories(/usr/local/include/quickfix)
link_directories(/usr/local/lib)
link_libraries(quickfix)

add_executable(ordermatch Application.cpp Market.cpp ordermatch.cpp)
Acceptor Session配置文件：
[DEFAULT]
ConnectionType=acceptor
ReconnectInterval=60
SenderCompID=GATEWAY
FileStorePath=./log
SocketAcceptPort=8088

[SESSION]
BeginString=FIX.4.2
TargetCompID=CLIENT
UseLocalTime=Y
StartTime=00:00:00
EndTime=23:30:00
HeartBtInt=30
SocketReuseAddress=Y
UseDataDictionary=Y
DataDictionary=./FIX42.xml
ResetOnLogon=Y
3、tradeclient
tradeclient是Initiator应用。
Application.h文件：
#ifndef TRADECLIENT_APPLICATION_H
#define TRADECLIENT_APPLICATION_H

#include "quickfix/Application.h"
#include "quickfix/MessageCracker.h"
#include "quickfix/Values.h"
#include "quickfix/Mutex.h"

#include "quickfix/fix42/NewOrderSingle.h"
#include "quickfix/fix42/ExecutionReport.h"
#include "quickfix/fix42/OrderCancelRequest.h"
#include "quickfix/fix42/OrderCancelReject.h"
#include "quickfix/fix42/OrderCancelReplaceRequest.h"

#include <queue>

class Application :
      public FIX::Application,
      public FIX::MessageCracker
{
public:
  void run();
private:
  void onCreate( const FIX::SessionID& ) {}
  void onLogon( const FIX::SessionID& sessionID );
  void onLogout( const FIX::SessionID& sessionID );
  void toAdmin( FIX::Message&, const FIX::SessionID& ) {}
  void toApp( FIX::Message&, const FIX::SessionID& )
  EXCEPT( FIX::DoNotSend );

  void fromAdmin( const FIX::Message&, const FIX::SessionID& )
  EXCEPT( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, 
          FIX::RejectLogon ) {}

  void fromApp( const FIX::Message& message, const FIX::SessionID& sessionID )
  EXCEPT( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, 
          FIX::UnsupportedMessageType );

  void onMessage( const FIX42::ExecutionReport&, const FIX::SessionID& );
  void onMessage( const FIX42::OrderCancelReject&, const FIX::SessionID& );

  void queryEnterOrder();
  void queryCancelOrder();
  void queryReplaceOrder();
  void queryMarketDataRequest();

  FIX42::NewOrderSingle queryNewOrderSingle42();
  FIX42::OrderCancelRequest queryOrderCancelRequest42();
  FIX42::OrderCancelReplaceRequest queryCancelReplaceRequest42();

  void queryHeader( FIX::Header& header );
  char queryAction();
  int queryVersion();
  bool queryConfirm( const std::string& query );

  FIX::SenderCompID querySenderCompID();
  FIX::TargetCompID queryTargetCompID();
  FIX::TargetSubID queryTargetSubID();
  FIX::ClOrdID queryClOrdID();
  FIX::OrigClOrdID queryOrigClOrdID();
  FIX::Symbol querySymbol();
  FIX::Side querySide();
  FIX::OrderQty queryOrderQty();
  FIX::OrdType queryOrdType();
  FIX::Price queryPrice();
  FIX::StopPx queryStopPx();
  FIX::TimeInForce queryTimeInForce();
};

#endif
Application.cpp文件：
#include "config.h"
#include "Application.h"
#include "quickfix/Session.h"
#include <iostream>

void Application::onLogon( const FIX::SessionID& sessionID )
{
  std::cout << std::endl << "Logon - " << sessionID << std::endl;
}

void Application::onLogout( const FIX::SessionID& sessionID )
{
  std::cout << std::endl << "Logout - " << sessionID << std::endl;
}

void Application::fromApp( const FIX::Message& message, const FIX::SessionID& sessionID )
EXCEPT( FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, 
        FIX::UnsupportedMessageType )
{
  crack( message, sessionID );
  std::cout << std::endl << "IN: " << message << std::endl;
}

void Application::toApp( FIX::Message& message, const FIX::SessionID& sessionID )
EXCEPT( FIX::DoNotSend )
{
  try
  {
    FIX::PossDupFlag possDupFlag;
    message.getHeader().getField( possDupFlag );
    if ( possDupFlag ) throw FIX::DoNotSend();
  }
  catch ( FIX::FieldNotFound& ) {}

  std::cout << std::endl
  << "OUT: " << message << std::endl;
}

void Application::onMessage
( const FIX42::ExecutionReport&, const FIX::SessionID& ) {}

void Application::onMessage
( const FIX42::OrderCancelReject&, const FIX::SessionID& ) {}

void Application::run()
{
  while ( true )
  {
    try
    {
      char action = queryAction();

      if ( action == '1' )
        queryEnterOrder();
      else if ( action == '2' )
        queryCancelOrder();
      else if ( action == '3' )
        queryReplaceOrder();
      else if ( action == '4' )
        queryMarketDataRequest();
      else if ( action == '5' )
        break;
    }
    catch ( std::exception & e )
    {
      std::cout << "Message Not Sent: " << e.what();
    }
  }
}

void Application::queryEnterOrder()
{
  int version = queryVersion();
  std::cout << "\nNewOrderSingle\n";
  FIX::Message order;

  switch ( version ) {
  case 42:
    order = queryNewOrderSingle42();
    break;
  default:
    std::cerr << "No test for version " << version << std::endl;
    break;
  }

  if ( queryConfirm( "Send order" ) )
    FIX::Session::sendToTarget( order );
}

void Application::queryCancelOrder()
{
  int version = queryVersion();
  std::cout << "\nOrderCancelRequest\n";
  FIX::Message cancel;

  switch ( version ) {
  case 42:
    cancel = queryOrderCancelRequest42();
    break;
  default:
    std::cerr << "No test for version " << version << std::endl;
    break;
  }

  if ( queryConfirm( "Send cancel" ) )
    FIX::Session::sendToTarget( cancel );
}



void Application::queryReplaceOrder()
{
  int version = queryVersion();
  std::cout << "\nCancelReplaceRequest\n";
  FIX::Message replace;

  switch ( version ) {
  case 42:
    replace = queryCancelReplaceRequest42();
    break;
  default:
    std::cerr << "No test for version " << version << std::endl;
    break;
  }

  if ( queryConfirm( "Send replace" ) )
    FIX::Session::sendToTarget( replace );
}

void Application::queryMarketDataRequest()
{
  int version = queryVersion();
  std::cout << "\nMarketDataRequest\n";
  FIX::Message md;

  switch (version) {
  default:
    std::cerr << "No test for version " << version << std::endl;
    break;
  }

  FIX::Session::sendToTarget( md );
}

FIX42::NewOrderSingle Application::queryNewOrderSingle42()
{
  FIX::OrdType ordType;
  FIX42::NewOrderSingle newOrderSingle(
    queryClOrdID(), FIX::HandlInst( '1' ), querySymbol(), querySide(),
    FIX::TransactTime(), ordType = queryOrdType() );

  newOrderSingle.set( queryOrderQty() );
  newOrderSingle.set( queryTimeInForce() );
  if ( ordType == FIX::OrdType_LIMIT || ordType == FIX::OrdType_STOP_LIMIT )
    newOrderSingle.set( queryPrice() );

  if ( ordType == FIX::OrdType_STOP || ordType == FIX::OrdType_STOP_LIMIT )
    newOrderSingle.set( queryStopPx() );

  queryHeader( newOrderSingle.getHeader() );
  return newOrderSingle;
}

FIX42::OrderCancelRequest Application::queryOrderCancelRequest42()
{
  FIX42::OrderCancelRequest orderCancelRequest( queryOrigClOrdID(),
      queryClOrdID(), querySymbol(), querySide(), FIX::TransactTime() );

  orderCancelRequest.set( queryOrderQty() );
  queryHeader( orderCancelRequest.getHeader() );
  return orderCancelRequest;
}

FIX42::OrderCancelReplaceRequest Application::queryCancelReplaceRequest42()
{
  FIX42::OrderCancelReplaceRequest cancelReplaceRequest(
    queryOrigClOrdID(), queryClOrdID(), FIX::HandlInst( '1' ),
    querySymbol(), querySide(), FIX::TransactTime(), queryOrdType() );

  if ( queryConfirm( "New price" ) )
    cancelReplaceRequest.set( queryPrice() );
  if ( queryConfirm( "New quantity" ) )
    cancelReplaceRequest.set( queryOrderQty() );

  queryHeader( cancelReplaceRequest.getHeader() );
  return cancelReplaceRequest;
}

void Application::queryHeader( FIX::Header& header )
{
  header.setField( querySenderCompID() );
  header.setField( queryTargetCompID() );

  if ( queryConfirm( "Use a TargetSubID" ) )
    header.setField( queryTargetSubID() );
}

char Application::queryAction()
{
  char value;
  std::cout << std::endl
  << "1) Enter Order" << std::endl
  << "2) Cancel Order" << std::endl
  << "3) Replace Order" << std::endl
  << "4) Market data test" << std::endl
  << "5) Quit" << std::endl
  << "Action: ";
  std::cin >> value;
  switch ( value )
  {
    case '1': case '2': case '3': case '4': case '5': break;
    default: throw std::exception();
  }
  return value;
}

int Application::queryVersion()
{
  char value;
  std::cout << std::endl
  << "1) FIX.4.0" << std::endl
  << "2) FIX.4.1" << std::endl
  << "3) FIX.4.2" << std::endl
  << "4) FIX.4.3" << std::endl
  << "5) FIX.4.4" << std::endl
  << "6) FIXT.1.1 (FIX.5.0)" << std::endl
  << "BeginString: ";
  std::cin >> value;
  switch ( value )
  {
    case '1': return 40;
    case '2': return 41;
    case '3': return 42;
    case '4': return 43;
    case '5': return 44;
    case '6': return 50;
    default: throw std::exception();
  }
}

bool Application::queryConfirm( const std::string& query )
{
  std::string value;
  std::cout << std::endl << query << "?: ";
  std::cin >> value;
  return toupper( *value.c_str() ) == 'Y';
}

FIX::SenderCompID Application::querySenderCompID()
{
  std::string value;
  std::cout << std::endl << "SenderCompID: ";
  std::cin >> value;
  return FIX::SenderCompID( value );
}

FIX::TargetCompID Application::queryTargetCompID()
{
  std::string value;
  std::cout << std::endl << "TargetCompID: ";
  std::cin >> value;
  return FIX::TargetCompID( value );
}

FIX::TargetSubID Application::queryTargetSubID()
{
  std::string value;
  std::cout << std::endl << "TargetSubID: ";
  std::cin >> value;
  return FIX::TargetSubID( value );
}

FIX::ClOrdID Application::queryClOrdID()
{
  std::string value;
  std::cout << std::endl << "ClOrdID: ";
  std::cin >> value;
  return FIX::ClOrdID( value );
}

FIX::OrigClOrdID Application::queryOrigClOrdID()
{
  std::string value;
  std::cout << std::endl << "OrigClOrdID: ";
  std::cin >> value;
  return FIX::OrigClOrdID( value );
}

FIX::Symbol Application::querySymbol()
{
  std::string value;
  std::cout << std::endl << "Symbol: ";
  std::cin >> value;
  return FIX::Symbol( value );
}

FIX::Side Application::querySide()
{
  char value;
  std::cout << std::endl
  << "1) Buy" << std::endl
  << "2) Sell" << std::endl
  << "3) Sell Short" << std::endl
  << "4) Sell Short Exempt" << std::endl
  << "5) Cross" << std::endl
  << "6) Cross Short" << std::endl
  << "7) Cross Short Exempt" << std::endl
  << "Side: ";

  std::cin >> value;
  switch ( value )
  {
    case '1': return FIX::Side( FIX::Side_BUY );
    case '2': return FIX::Side( FIX::Side_SELL );
    case '3': return FIX::Side( FIX::Side_SELL_SHORT );
    case '4': return FIX::Side( FIX::Side_SELL_SHORT_EXEMPT );
    case '5': return FIX::Side( FIX::Side_CROSS );
    case '6': return FIX::Side( FIX::Side_CROSS_SHORT );
    case '7': return FIX::Side( 'A' );
    default: throw std::exception();
  }
}

FIX::OrderQty Application::queryOrderQty()
{
  long value;
  std::cout << std::endl << "OrderQty: ";
  std::cin >> value;
  return FIX::OrderQty( value );
}

FIX::OrdType Application::queryOrdType()
{
  char value;
  std::cout << std::endl
  << "1) Market" << std::endl
  << "2) Limit" << std::endl
  << "3) Stop" << std::endl
  << "4) Stop Limit" << std::endl
  << "OrdType: ";

  std::cin >> value;
  switch ( value )
  {
    case '1': return FIX::OrdType( FIX::OrdType_MARKET );
    case '2': return FIX::OrdType( FIX::OrdType_LIMIT );
    case '3': return FIX::OrdType( FIX::OrdType_STOP );
    case '4': return FIX::OrdType( FIX::OrdType_STOP_LIMIT );
    default: throw std::exception();
  }
}

FIX::Price Application::queryPrice()
{
  double value;
  std::cout << std::endl << "Price: ";
  std::cin >> value;
  return FIX::Price( value );
}

FIX::StopPx Application::queryStopPx()
{
  double value;
  std::cout << std::endl << "StopPx: ";
  std::cin >> value;
  return FIX::StopPx( value );
}

FIX::TimeInForce Application::queryTimeInForce()
{
  char value;
  std::cout << std::endl
  << "1) Day" << std::endl
  << "2) IOC" << std::endl
  << "3) OPG" << std::endl
  << "4) GTC" << std::endl
  << "5) GTX" << std::endl
  << "TimeInForce: ";

  std::cin >> value;
  switch ( value )
  {
    case '1': return FIX::TimeInForce( FIX::TimeInForce_DAY );
    case '2': return FIX::TimeInForce( FIX::TimeInForce_IMMEDIATE_OR_CANCEL );
    case '3': return FIX::TimeInForce( FIX::TimeInForce_AT_THE_OPENING );
    case '4': return FIX::TimeInForce( FIX::TimeInForce_GOOD_TILL_CANCEL );
    case '5': return FIX::TimeInForce( FIX::TimeInForce_GOOD_TILL_CROSSING );
    default: throw std::exception();
  }
}
tradeclient.cpp文件：
#include "config.h"
#include "quickfix/FileStore.h"
#include "quickfix/SocketInitiator.h"
#include "quickfix/SessionSettings.h"
#include "quickfix/Log.h"
#include "Application.h"
#include <string>
#include <iostream>
#include <fstream>
#include <unistd.h>

int main( int argc, char** argv )
{
  if ( argc < 2 )
  {
    std::cout << "usage: " << argv[ 0 ]
    << " FILE." << std::endl;
    return 0;
  }
  std::string file = argv[ 1 ];

  FIX::Initiator * initiator = 0;
  try
  {
    FIX::SessionSettings settings( file );
    Application application;
    FIX::FileStoreFactory storeFactory( settings );
    FIX::ScreenLogFactory logFactory( settings );
    initiator = new FIX::SocketInitiator( application, storeFactory, 
                                          settings, logFactory );
    initiator->start();
    application.run();
    initiator->stop();

    delete initiator;

    return 0;
  }
  catch ( std::exception & e )
  {
    std::cout << e.what();
    delete initiator;
    return 1;
  }
}
CMakeLists.txt文件：
cmake_minimum_required(VERSION 3.10)

project(tradeclient)

set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_COMPILER "g++")
set(CMAKE_CXX_FLAGS "-std=c++11 ${CMAKE_CXX_FLAGS}")

include_directories(/usr/local/include/quickfix)
link_directories(/usr/local/lib)
link_libraries(quickfix)

add_executable(tradeclient Application.cpp tradeclient.cpp)
Initiator Session配置文件：
[DEFAULT]
ConnectionType=initiator
ReconnectInterval=60
SenderCompID=CLIENT
FileStorePath=./log

[SESSION]
BeginString=FIX.4.2
TargetCompID=GATEWAY
UseLocalTime=Y
StartTime=00:00:00
EndTime=23:30:00
HeartBtInt=30
SocketConnectPort=8088
SocketConnectHost=192.168.0.102
UseDataDictionary=Y
DataDictionary=./FIX42.xml





AI量化交易（一）——量化交易简介

一、量化交易简介
1、量化交易简介
量化交易是以数学模型为交易思维，以历史数据为基础，以数学建模、统计学分析、编程设计为工具，利用计算机技术从庞大的历史数据中海选出能带来超额收益的多种大概率获利事件以制定交易策略。
2、量化交易的特点
（1）纪律性。量化投资决策都是依据模型做出的，模型会模拟测试成千上万次来达到高容错率。
（2）系统性。量化交易数据分析有一套非常全面的数据评测系统，会从多方面考量市场，比如：宏观周期、数字货币估值、换手率、盈利质量、市场情绪等。
（3）概率性。通过模型并结合数学方法，测算在什么样的情况下盈利率最高，适当仓位就可以加仓。
（4）套利思想。利用数学分析并结合计算机技术寻找估值洼地，卖高买低，赚取中间的差价，收得利益的经济。
3、量化交易的优点
（1）投资业绩稳定，回撤低。量化交易从历史数据中不断地挖掘有望在未来重复的历史规律并进行利用；量化交易依靠一组股票来获胜，而不是一个或者几个股票获胜。
（2）能够克服人性的弱点，实现理性投资。在容易失去理性的情况下帮助投资者保持理性；因而在市场反应过度、丧失理性的时候能够及时把握住时机。
（3）信息的处理能力强。量化交易使用计算机技术对海量数据进行处理，对信息的处理能力更强。
4、量化交易的应用
（1）统计套利
统计套利的主要思路是先找出相关性最好的若干对投资品种，再找出每一对投资品种的长期均衡关系（协整关系），当某一对品种的价差（协整方程的残差）偏离到一定程度时开始建仓，买进被相对低估的品种、卖空被相对高估的品种，等价差回归均衡后获利了结。
（2）算法交易
算法交易的主要思路是可以根据量化的公式对未来进行涨跌的预测，是一种趋势交易，算法策略的预测有对有错，属于高风险交易，但利润空间大，市场容量也较大。
（3）高频交易
高频交易持仓时间短，通过大量的交易又快速撤单，每笔交易平均利润小，但风险也小。
二、量化交易方式
1、量化交易方式简介
按照数学模型的理念和对计算机技术的利用方式，量化交易可以细分为自动化交易（Automatic Trading）、量化投资（Quantitative Investment）、程序化交易（Program Trading）、算法交易（Algorithm Trading）以及高频交易（High Frequency Trading）。不同量化交易方式的侧重点各有不同，是量化交易技术发展到不同阶段的产物，也是不同量化交易用户群的不同交易方式。
2、自动化交易
自动化交易是指将技术分析投资方式固化成计算机可以理解的模型、技术指标，计算机程序根据市场变化自动生成投资决策并付诸执行的交易方式。自动化交易是技术分析投资方式的自动化，可以避免投资人的心理变化和情绪波动，严格执行既定策略，是基本的量化交易方式。
3、量化投资
量化投资一般概指通过概率论、微积分等高等数学工具去研究金融市场各种资产价格的结构性原因来决定的投资。量化投资对投资者的数学能力要求很高，所以一般专门进行量化投资的基金和投资公司都喜欢招数学、物理等理科的博士。
4、程序化交易
程序化交易是利用程序进行交的易，交易时机、交易仓位、止损止盈获利标准可以包含在程序内，也可以独立于程序外，程序本身只是执行的方式。
5、算法交易
算法交易是指交易决定是根据一条或多条算法 (algorithm) 进行的，算法是交易的基础。算法交易的执行可以是手工的，也可以是自动化的。如果利用交易程序来执行，是程序化算法交易。
6、高频交易
高频交易是每次交易从开仓到平仓只有很短的时间间隔，一般从十几分钟到几微秒不等。高频交易主要目的是通过市场短暂的价格波动而获利。无论是趋势追随交易还是套利交易，只要频率达到，都可以被称为高频交易。人工达到高频交易的标准很难，所以一般都通过程序交易：设置好算法、策略后由下单软件执行。
7、策略交易
在投资领域中，一般习惯把买入持有、价值投资、成长投资等称为战略，而把惯性、反转、趋势、支撑阻力等等叫做策略。由于策略以技术分析为主，而在交易决策分析的计算机化历史中，技术分析走得比较早，所以Strategy Trading习惯上多指策略交易。通常，将交易策略称为策略，将系统交易称为策略交易。
三、主流量化交易平台
1、量化交易平台简介
量化交易平台是指能分别满足不同量化交易方式的平台，要求其从交易系统的行情和基础数据、交易和执行、策略研发和运营三个主要方面既要做到大而全，也要做到深而精。
目前的量化交易平台可以从开发语言、技术架构、系统架构、策略方向、交易方式等几个方面，分为中低端和高端量化交易平台。
2、中低端量化交易平台
中低端平台一般采用的技术架构是投资者使用平台商提供的客户端软件，采用互联网接入方式连接平台商或者金融经纪公司提供的行情和基础数据服务器，投资者在本地运行的策略触发后，通过经纪公司的普通交易席位进行交易。
受策略脚本解析和执行效率、技术架构的限制，中低端平台对于多品种、多周期、多账户、多交易市场、多策略、复杂金融工具包等复杂系统架构的支持都有一定的限制。一般的系统实现流程为：投资者的策略在本地接收市场数据后，根据策略简单计算的触发条件，进行简单的账户持仓、资金计算和管理，进而下达买卖方向、数量、价格等指令，进行自动交易。
中低端量化交易平台只支持复杂度不高的脚本语言实现策略逻辑，一般只能在图表上加载技术指标进行自动化交易、程序化交易等量化交易方式。
中低端平台适合投资者进行趋势、反趋势等对行情和交易逻辑要求不高的策略，是目前市场上个人投资者应用最多的一类大众化的量化交易平台。
国内中低端量化交易平台主要有文华赢智程序化交易、交易开拓者、金字塔决策交易系统、达钱&multicharts、安翼金融终端等。
（1）文华赢智程序化交易平台
文华赢智采用麦语言开发技术指标模型，产生买卖信号后驱动交易下单。在量化模型研发方面，赢智提供了国内股票和期货的全部品种多周期的时间序列历史行情数据和近期的TICK数据，同时提供了丰富的行情函数、账户和交易的部分函数和一些统计函数用于策略开发，还提供了丰富的策略回测报告项作为策略绩效评估的依据。在量化交易方面，赢智提供支持最多24个品种进行的多线程独立的程序化交易，同时使用下单精细化组件，实现了部分算法交易的功能。由于采用客户端的技术架构，虽然赢智实现了高频交易的功能模块，但在实际应用中，高频交易建议托管在文华机房。现阶段，赢智以程序化实现简单、性价比高等特点，在中低端量化交易平台中占有一定的优势。
（2）交易开拓者程序化交易平台
交易开拓者（TB）采用TBL语言开发策略模型，根据账户持仓状况和图表买卖信号驱动交易下单。在量化模型研发方面，TB提供了国内期货多周期的历史行情数据和近期的TICK数据；提供了较为全面的行情数据函数、账户和交易函数、统计函数用于策略开发；提供了丰富策略回测报告项作为策略绩效评估的依据。在量化交易方面，单个TB终端支持20-30个单品种的图表并发接收行情并交易，但由于客户端技术架构的限制，其对于高频和更复杂策略的支持不足。现阶段，TB市场推广做得较好，合作的期货公司较多，在中低端量化交易平台的市场占有率较高。
（3）金字塔决策交易系统
金字塔决策交易系统（下称金字塔）采用VB脚本语言开发策略模型，使用较复杂的账户函数和交易函数进行资金管理，既可以使用图表买卖点，也可使用非图表的交易判断驱动交易下单。在量化模型研发方面，金字塔提供了国内股票和期货的历史行情数据和TICK数据，也可以使用外盘数据；提供了更为全面的行情数据函数、较多的账户和交易函数、统计函数用于策略开发，同时也支持外接统计数据库和专业的统计分析软件Lib库做扩展；提供了较为丰富策略回测报告项作为策略绩效评估的依据。在量化交易方面，除了支持图表驱动的程序化交易外，也可以进行篮子交易、算法交易和较复杂的对冲交易的实现，但是同样受客户端的技术架构限制，其对于高频交易、全市场策略的交易等更复杂的策略支持不够。现阶段，金字塔合作的期货公司逐渐增多，在中低端量化交易平台的市场占有率较高。
（4）达钱multicharts自动化交易
达钱multicharts自动化交易系统（MC）采用power language开发策略模型，达钱提供行情和交易网关，multicharts实现策略开发和执行平台。在量化模型研发方面，由达钱提供的一段时间内的国内期货历史行情和TICK行情。MC承袭了TradeStation的丰富的函数库和策略库，以及便捷的开发特点，提供了更为完善的回测和绩效评价体系，为策略的研发提供了完善的评估。在量化交易方面，MC只支持程序化和自动化交易，对于高端的量化交易模式支持不够。由于MC进入国内不久，在中低端量化交易平台的市场占有率还不高。
（5）安翼金融终端程序化交易
安翼金融终端（下称安翼）采用技术指标的通用脚本语言开发交易模型，进行图表驱动的自动化交易，是由某券商独立开发的进行国内股票和期货的自动化交易工具。目前安翼提供了国内股票和期货的历史行情，可以进行相对简单的图表交易和股票、期货的对冲交易，程序化交易工具免费使用。虽然安翼只能用安信证券交易通道进行交易，但却标志着国内股票和期货的量化交易已经提升到一个全面发展阶段。
3、高端量化交易平台
高端量化平台除了支持复杂脚本语言实现策略逻辑外，均支持直接使用C++、JAVA等开发语言实现复杂的策略逻辑，一般为了追求执行效率，不采用界面显示图表，而采用多进程、多线程方式进行自动化交易、程序化交易、算法交易，甚至为了追求极致，使用硬件技术进行高频交易等量化交易方式。
高端交易平台通常采用的技术架构是使用服务器执行策略的架构，行情使用转发路径最少的极速、深度行情，交易通道采用专用、直连的交易通道进行交易。行情和交易的延时都要求尽可能最低。
高端交易平台定位于资产管理，在系统架构上严格区分策略研发和策略运营执行两个阶段。对于策略研发阶段，需要多品种、多周期、多账户、多交易市场、多策略、复杂金融工程包的支持，以实现复杂的策略逻辑；对于策略运营执行阶段，系统架构要保证各种风控、应急处理、交易方式和策略的平稳有效执行。系统的实现流程除了满足交易本身的要求外，还要满足机构本身的业务流程和规范，以及监管层的要求。
高端交易平台适合机构投资者进行趋势、套利、对冲、高频等对行情和交易要求高、逻辑复杂度高的策略。随着国内金融市场创新的提速，机构投资者对高端交易平台的需求和潜在需求呈快速上升趋势。
国内高端量化交易平台主要有Progress Apama、龙软DTS、国泰安量化投资平台、天软量化平台、飞创STP、易盛程序化交易、盛立SPT平台等。
（1）Progress Apama
Apama采用EPL和JAVA语言开发或者定制策略模型，通过行情、资讯等驱动CEP引擎进行交易、风控等操作。在量化模型研发方面，Apama使用第三方的行情授权，提供了各市场行情接口和各种柜台交易接口的接入，可以接入国内股票和期货多周期的时间序列历史行情数据和TICK数据；提供了丰富的金融工具包进行复杂策略开发；提供了便捷的studio开发工具，可以进行复杂策略的快速开发和定制；提供了1万倍加速测试进行策略回测，可以方便地定制测试报告。在量化交易方面，Apama提供了150万笔/秒的交易并发处理能力，进行高频交易、算法交易。Apama高端的并发处理能力，使全市场的多品种并发套利、对冲等交易策略和实时风控策略可以高速执行。现阶段，Apama在国际投行的自营、资管、经纪业务中占有很大的市场份额。从2012年开始，Apama逐步拓展国内的业务，几家较大的证券和期货公司已经开始正式上线推广Apama和相关的量化交易应用。
（2）龙软DTS
DTS采用LUA脚本语言开发策略模型，通过平台提供的历史和实时行情、基本资料数据、宏观数据的统计分析，实现投研和交易。在量化模型研发方面，DTS既可使用平台自有的数据源，也可以接入第三方数据源。DTS还提供了一些金融工具包，进行复杂策略开发、回测和绩效评价。在量化交易方面，DTS提供的可以扩展的服务器端技术架构，保证了策略的高并发和高速执行，其在程序化交易、量化交易、算法交易、对冲和套利交易方面都有实际应用。
（3）国泰安量化投资平台
国泰安量化投资平台分为研究平台（QIA-Lite）和交易平台（QRC），采用matlab的toolbox的形式无缝兼容了matlab的研发环境，由交易平台实现策略交易。在量化模型研发方面，国泰安投研平台使用自有的行情源、基本面数据、高频数据、量化因子数据库，完全兼容matlab所有的函数，实现了模型的研发和回测。在量化交易方面，其支持了国内主流证券和期货的柜台，在股票和期货的程序化交易、算法交易等方面都有实际应用。
（4）天软量化研究和交易平台
天软量化研究和交易平台采用天软特有的TSL语言开发策略模型，通过天软的交易网关，实现量化交易的执行。在量化模型研发方面，采用高性能数据仓库提供的历史和TICK行情、基础资料数据、宏观数据等数据源，同时提供了7000种开源的函数库，进行策略的研发、回测、绩效分析。在量化交易方面，其基本实现了自动交易、程序化交易、算法交易等量化交易方式。
（5）飞创STP
飞创量化交易平台采用JAVA语言，通过可定制的模板开发策略模型，进行高频交易。STP通过统一的开发和资管运营平台，实现策略的研发、回测、风控和资管运营。由于使用了高速的柜台交易接口，其主要面向高频套利、程序化交易等交易模式的用户。
（6）易盛程序化交易平台
易盛程序化交易既可采用类似Easy Language的语言开发策略模型，实现程序化交易和套利交易，也可以根据易盛柜台提供的行情和交易API，采用C++开发外接应用的方式，实现期货、股票的更复杂的量化交易。在量化模型研发方面，易盛程序化提供的EL开发模型，类似于中低端的量化交易平台，但在行情的速度、交易和账户函数的实时性和精细化处理方面，达到了高端量化交易平台的要求。在量化交易方面，易盛柜台的行情和交易速度具有一定的比较优势，量化交易平台支撑的应用主要是期货的程序化交易、自动交易、对冲和套利交易。
（7）盛立SPT平台
盛立金融软件的SPT平台，采用C++语言和定制的策略开发模板进行策略研发，采用独立的运营和回测平台进行模拟和真实交易。虽然SPT平台在国内应用不多，但凭借其100万笔/秒的行情并发处理能力、交易的毫秒级别的延迟，在量化交易平台中引人注目。SPT提供了一些策略模板，可以很方便地实现程序化交易、套利和对冲交易、算法交易、高频交易等。
四、主流量化基金
1、桥水基金
桥水对冲基金公司（Bridgewater Associates）由Ray Dalio于1975年创立，总部设在美国康涅狄格州，目前总共拥有约1500名雇员。桥水基金是对冲基金中的常青树，常年在世界对冲基金榜单上位居前列甚至是榜首，掌管约1500亿美元，客户主要由机构客户组成，包括外国政府、央行，企业和公共养老金，大学捐款和慈善基金。
桥水基金具有独特的投资理念，以全球宏观策略为主，提出了全天候投资策略、alpha与beta策略分离等理论，其中的全天候投资策略强调在不同的宏观经济时期进行不同类型的资产组合配置，从而达到始终盈利的状态。桥水基金在2008金融危机中获得了正收益，并在2009年雷曼兄弟破产后仍然表现良好。
2018年6月，桥水基金在中国证券投资基金业协会完成私募基金管理人登记，正式成为境内私募管理人，标志其在华私募业务已经正式启动。
2、AQR资本管理公司
AQR是原高盛投资组合经理阿斯内斯与合伙人1998年共同创办的一家量化对冲基金
，总部在美国康涅狄格州的格林尼治，目前管理规模达1592亿美元，雇员数量达到693人，在波士顿、芝加哥、洛杉矶、伦敦和悉尼设立有办公室。
AQR的客户以机构投资者为主，例如养老基金、保险公司、共同基金、主权财富基金等。
AQR通过算法和计算机模型来寻找市场暂时的无效性并从中获利，其投资策略十分广泛，包括长短仓、套利、股权、全球宏观、保险、绝对收益、动量、多策略等。AQR的首要目标是价值股和动量股；选择投资组合时，AQR强调基本面与量化分析和自下而上选股的结合；投资核心三个原则是系统化方法、多样化投资和alpha技艺。
AQR资本在2008年的金融危机中损失惨重，其旗舰基金“绝对回报基金”亏损幅度超过50%，而公司管理的资产规模从2007年9月巅峰时期的391亿美元一路下跌至2009年3月的172亿美元。
3、千禧管理公司
千禧管理（Millennium Management LLC）由英格兰德于1989年在加拿大富豪贝尔兹伯格家族等投资人的帮助下创立，初始资产规模为3500万美元，目前管理规模达336亿美元，拥有超过2000名雇员，在美国、欧洲和亚洲均设有办公室。
千禧管理的投资方法十分注重风险，更偏向于在一定的风险（比如低的夏普率）下有较高的收益，对于风险厌恶的投资理念成为了交易团队的规则。因此，千禧管理要求交易团队能在赚钱的日子里有较小的收益，在亏钱的日子里有较小的亏损，争取较多的赚钱日。
千禧管理的投资策略着重分散投资和全球化，包括相对价值、统计套利、并购套利、固定收益和商品等，在资产类别、商品所属行业、投资标的所属地等方面十分多样化，投资标的包括国内外股权、债权、货币、期货、远期、期权等。千禧管理十分注重高科技的运用，其附属量化部门有能够让业余交易员提交算法来进行特定交易的系统。
4、城堡投资集团
城堡投资集团（Citadel Investment Group）由肯尼斯·格里芬于1990年创立，总部设立于芝加哥，在北美、亚洲、欧洲均设有办公室，目前城堡资产管理公司管理规模超过240亿美元，公司拥有超过1400名雇员，城堡投资集团的客户包括主权财富基金、养老金、大学捐款等。
城堡的投资方法由严密的基本面研究、高端量化分析和一个经过验证的技术平台共同驱动。投资原则是努力、情景规划和重复。投资策略注重世界上最大的金融市场上主要的一些资产类别，主要包括股票、信贷、量化策略、商品、固定收益和宏观。
5、索罗斯量子基金
索罗斯量子基金（Soros Fund Management）由乔治索罗斯于成1969年创立，曾经是对冲基金行业的翘楚，总部设立在纽约，现在已经转变为一家家族办公室，管理规模超过200亿美元。
量子基金的投资标的包括股票、世界范围内的固定收益产品和外汇、货币、商品、私募股权基金和风险投资基金，在交通、能源、零售、金融等行业有大量的投资。
创始人索罗斯曾经阻击英镑从而打垮英格兰银行，狙击泰铢和港元，引发亚洲金融风暴。

6、元盛资本
元盛资本（Winton Capital Management）由基金经理David Harding于1997年创立，目前管理规模超过300亿美元，在全球25个国家拥有员工330人，是全球最大的期货投资基金公司。
元盛资本是一家系统化的投资公司，运用科学手段进行交易，通过对历史数据的统计学分析和数学建模来寻找获利机会。

7、德劭投资
德劭（D.E. Shaw）由创始人David E. Shaw于1988年创立，目前公司管理规模达到500亿美元，员工数量超过1300。
创始人David E. Shaw是哥伦比亚大学计算机系的教师，担任过政府科技顾问等职位，精通信息技术与相关科技，公司十分注重量化技巧在投资中的运用，也开发了高精尖的计算机技术用于交易。
创始人David E. Shaw在斯坦福博士毕业后快速拿到了哥伦比亚大学的教职，随后加入摩根士丹利的量化部门。1988年，因在公司内部斗争中败北而创立德劭基金，并运用当时罕见的高频交易技术在华尔街横空出世，利用市场的无效性剪市场的羊毛。
2004年，实现财务自由的David E. Shaw将自己在量化投资领域赚取的财富投入到自己的本行计算化学领域，成立了D.E.Shaw Research，招聘了一批基础科学博士，使用三年时间开发出Anton第一代，比一般的超级计算机快10000倍，团队不断斩获世界知名科学杂志的论文发表机会，学术声誉节节攀升。
2015年，David E. Shaw个人财富已达到41亿美元。
2019年4月，德劭投资管理（上海）在中国证券投资基金业协会完成备案登记，正式进入中国市场。
8、文艺复兴
文艺复兴科技（Renaissance Technologies LLC）由詹姆斯-西蒙斯（James Simons）于1982年创立，目前管理规模超过650亿美元，旗下包括仅向内部员工开放的大奖章基金(Medallion Fund)以及向外部投资者开放的RIEF (机构股票基金)和RIDA (机构多元化阿尔法基金)。
James Simons在23岁获得加州大学伯克利分校数学博士学位，24岁出任哈佛大学数学系讲师，30岁到纽约州立石溪大学出任数学系主任，并8年的纯数学研究，其间与华裔知名数学家陈省身联合创立了对数学和物理学影响深远的Chern-Simons理论。
1976年，James Simons摘得数学界的皇冠——全美维布伦（Veblen）奖，其个人数学事业的成就达到顶峰。
在金融方面，James Simons发明独特的壁虎式投资法，即在投资时进行短线方向性预测，同时交易很多品种，依靠在短期内完成的大量交易来获利，即交易要像壁虎一样，平时趴在墙上一动不动，蚊子一旦出现就迅速将其吃掉，然后恢复平静，等待下一个机会。
1989年到2009年间，大奖章基金平均年回报率高达35%，较同期标普500指数年均回报率高20多个百分点，比“金融大鳄”索罗斯和“股神”巴菲特的操盘表现都高出10余个百分点。即便是在次贷危机爆发的2007年，回报率仍高达85%。
大奖章基金的数学模型主要通过对历史数据的统计，找出金融产品价格、宏观经济、市场指标、技术指标等各种指标间变化的数学关系，发现市场目前存在的微小获利机会，并通过杠杆比率进行快速而大规模的交易获利。现在大奖章基金的投资组合包含了全球上千种股市以及其他市场的投资标的，模型对国债
、期货
、货币、股票等主要投资标的的价格进行不间断的监控，并作出买入或卖出的指令。
9、Two Sigma
Two Sigma由创始人John Overdeck和David Siegel于2001年创立，目前管理规模达到500亿美元，研发部门员工占比超过三分之二，超过百分之六十员工无金融背景。
Two Sigma遵循技术与创新的原则，在机器学习、分布式计算的引领下进行决策，并始终研发最新的技术，用以做出更好的决策。创始人都是技术投资领域的佼佼者，在电脑驱动、以模型为基础的交易系统发展领域有超过40年的经验，John Overdeck是华尔街量化基金教父、德劭投资创始人D.E. Shaw的得力爱将，在数学和统计学方面颇有造诣；David Siegel擅长计算机、人工智能；公司结合海量数据、世界级的电脑系统和金融专家来完成高端的交易模型，同时也用科技的眼光来优化投资、管理风险。
2019年9月，Two Sigma宣布子公司腾胜投资管理(上海)有限公司已经成功在中国证券投资基金业协会(AMAC)登记成为私募基金管理人。
五、主流PB机构
1、PB简介
主券商业务（Prime Brokerage，简称PB），作为券商的一项机构业务，是指券商为专业投资者提供交易结算、资产托管、后台运营、研究支持、杠杆融资、资金募集等一站式综合金融服务 。
 PB(Prime Brokerage)，中文名叫主经纪商，在国外主要是券商为机构客户（特别是对冲基金）提供服务和管理的业务平台，也是对冲基金投资策略得以实施所依赖的重要组成部分。因此，PB是华尔街券商的重要业务部门，为70%的国际对冲基金提供融资和管理服务。主经纪商作为对冲基金的资金方，处于强势地位，PB一方面希望扩大融资规模，另一方面又要面对严峻的融资风险，这本身就对主经纪业务提出了极强的专业化要求。
2、高盛集团
作为国外最大的PB服务机构，高盛对技术和创新的坚定承诺，引领其开发出许多已成为行业标准的作法及技术。高盛一直是电子交易和连接系统方面的先锋，其电子交易平台REDIPlus在交易前分析、增值的执行服务、算法交易、组合交易方案及交易后分析方面具有全球领导地位。其中，高盛算法交易（GSAT）是一组涉及全球多种资产的算法程序，包括股票、期货、合成衍生工具和期权，通过与GSAT进行交易，客户还可获得高盛的各种资源，包括交易前后及交易期间的分析、交易成本分析和执行策略 。
除了交易工具外，高盛在各项业务上均大力运用科技促进业务创新发展。在外汇和衍生品交易方面，高盛独创和专有的数据建模技术使客户在投资组合基础上计算保证金，从而高效管理风险及优化资本运用，而且高盛内部技术平台简化了交易确认、组合对账和管理。在托管结算方面，高盛开发了功能强大、范围广泛的全球结算与交收网络。高盛的平台提供了一套完整的工具，允许客户在一个单一的综合账户里跨越多类资产和货币交易。在融资融券方面，高盛运用专有的、采用前沿技术的投资组合风险建模工具，评估客户投资组合和策略的融资方案。在报告服务方面，高盛机构客户网可让客户在线获取高盛的全球在线资源，包括交易理念、投资机会、市场洞察、个性化的投资研究及其它资源。同时，高盛开发了一个可定制程度高的综合报告平台，向客户提供度身定制的涵盖众多产品和市场的业务解决方案。
3、盈透证券
盈透证券（Interactive Brokers，IB）是一家以低交易成本和技术驱动业务而知名的美国网络券商，机构和个人客户各占一半。PB业务是IB近年来快速开拓的领域。IB在PB服务方面具备两项核心竞争力：一项是IB研发的IB SmartRouting SM智能交易系统，另一项则是IB在成本控制上的绝对优势，IB可以选择免费为客户提供托管服务。
受Basel III、MiFID II等监管政策的影响，高盛、摩根士丹利等银行控股的主经纪商受到严格的流动性管理约束，被迫抬高客户准入标准和服务定价。IB则接纳了大型主经纪商不愿服务的对冲基金，同时也吸引了一大批费率敏感型的客户。由于具有出色的技术储备和规划，在面对诸如MiFID II等监管新规时，不必被迫进行全面技术升级和增聘一批新员工。IB为客户研发了一套智能交易系统—IB SmartRouting SM，通过算法寻找全市场最优的价格完成交易。SmartRouting通过技术手段替代人工化操作，并融入到各个业务流程中改造成自动化的工作流程，从而能极大降低成本。由此，IB在成本控制上具有绝对优势，进而实现不对客户提出最低管理规模或收入贡献的要求。
此外，IB拥有一套支持C++、Java以及Python等语言的编程接口，主要服务于程序化交易客户。IB还推出了一套外汇掉期自动化交易程序，使客户以更合理的价格持有外汇头寸。为了满足对冲基金希望只通过一个平台便可以触达全球市场的不同资产，IB开发了Investors’ Marketplace，为配置对冲基金的机构提供搜索工具，平台上目前有2911只对冲基金。
4、瑞士联合银行
瑞士联合银行集团（UBS Group AG，瑞银集团或瑞银）创立于1862年，总部位于瑞士苏黎世，全职雇员67481人，是欧洲最大的金融控股集团。旗下由瑞银华宝、瑞银机构资产管理与瑞银瑞士私人银行三大分支机构组成，瑞银集团的业务主要包括财富管理、投资银行及证券和资产管理三大块。UBS瑞银是一家全能银行，为国内外客户（企业、个人、公共机构等） 提供广泛的银行服务，其中包括流动资本贷款、建设贷款、特别融资、国际商业贷款、出口融资、项目融资、证券信贷与担保、投资咨询与托管、证券交易、证券管理与间接贷款、发行并经销股票、债券和票据，从事 银团贷款，经营外汇、银行票据、贵金属，从事货币市场业务，从事转移与支付等等。
5、中金公司
中国国际金融有限公司（CICC）是中国第一家中外合资投资银行，中金一直致力于为客户提供高质量金融增值服务，建立了以研究为基础，投资银行、股票业务、固定收益、财富管理和投资管理全方位发展的业务结构。




AI量化交易（二）——Tushare财经数据框架

一、Tushare简介
1、Tushare简介
Tushare是一个免费、开源的python财经数据接口包，目前为Tushare Pro版本，主要实现对股票等金融数据从数据采集、清洗加工到数据存储的过程，能够为金融分析人员提供快速、整洁和多样的便于分析的数据。Tushare返回的绝大部分的数据格式都是pandas DataFrame类型，非常便于用pandas、NumPy、Matplotlib进行数据分析和可视化。

2、Tushare安装
Github: https://github.com/waditu/Tushare
pip install tushare lxml
pip install beautifulsoup4
3、Token生成
Tushare使用需要注册账户，并生成Token。
本人邀请注册链接：Tushare大数据社区
注册成功，登录Tushare，点击个人信息设置：

在接口Token页找到个人的Token，Token是使用Tushare接口的惟一凭证，如果发现泄露，可以刷新生成新的Token。
import tushare as ts


if __name__ == '__main__':
    print(ts.__version__)
    # 设置Token
    ts.set_token('xxx0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()

#output:
#1.2.45
4、Tushare API简介
Tushare的数据接口分为沪深股票、指数、基金、期货、期权、债券、外汇、港股、行业经济、宏观经济、特色大数据共计十一大类，沪深其中股票分为基础数据、行情数据、财务数据、市场参考数据四类接口。Tushare也提供了区块链相关的基础数据、行情数据、资讯公告三类接口，以及新浪财经、东方财富、同花顺、云财经、华尔街见闻等财经网站的宏观经济、外汇、A股、区块链、美股、石油、黄金、黄金外汇、港股、商品、债券、公司、市场、焦点、央行等财经资讯类消息。
Tushare API接口需要根据注册账户的积分数量获取相应的访问权限，积分等级不够可能导致API接口无权限访问，区块链相关接口需要捐款获取相应权限。
Tushare API接口使用参考：Tushare大数据社区
二、Tushare股票数据接口
1、股票列表
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.stock_basic(exchange='', list_status='L', fields='ts_code,symbol,name,area,industry,list_date')
    # data = ts_api.query('stock_basic', exchange='', list_status='L',
    #                     fields='ts_code,symbol,name,area,industry,list_date')
    print(data)
获取股票基础信息数据，包括股票代码、名称、上市日期，行业、概念等。
2、IPO新股上市
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.new_share(start_date='20190101', end_date='20190901')
    print(data)
获取新股上市列表数据
3、日线行情
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.daily(ts_code='000001.SZ', start_date='20190101', end_date='20190901')
    print(data)
交易日每天15点～16点之间。本接口是未复权行情，停牌期间不提供数据。
4、周线行情
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.weekly(ts_code='000001.SZ', start_date='20180101', end_date='20181101',
                         fields='ts_code,trade_date,open,high,low,close,vol,amount')
    print(data)
获取A股周线行情
5、月线行情
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.monthly(ts_code='000001.SZ', start_date='20180101', 
                            end_date='20181101',
                            fields='ts_code,trade_date,open,high,low,
                            close,vol,amount')
    print(data)
获取A股月线数据。
6、通用行情接口
pro_bar接口整合了股票（未复权、前复权、后复权）、指数、数字货币、ETF基金、期货、期权的行情数据，未来会包括外汇在内的所有交易行情数据，同时提供分钟数据。
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts.pro_bar(api=ts_api, ts_code='000009.SZ', adj='qfq', 
                    start_date='20170101', end_date='20181011', ma=[5],
                      freq='D')
    print(data)
获取A股的K线数据，带有复权参数“adj”、均线参数“ma”、数据频度参数“freq”。
7、获取股票的全部数据
import tushare
import os
import datetime
import timedelta


def fetch_kline_data(code):
    filename = 'your path'
    if not os.path.exists(filename):
        end_date = datetime.strftime(datetime.now(), '%Y%m%d')#获取当前时间
        outputflag = True
        api = tushare.pro_api()
        while outputflag:#循环判断，直到返还的数据为空
           data = tushare.pro_bar(pro_api=api,ts_code=code,
                                end_date=end_date,asset='E', adj=None, freq='D')
           if data.empty == True:
               outputflag = False
           else:
                #计算下次请求数据的截止日期
                next_end_date = datetime.strptime(data.iloc[-1]['trade_date'],
                                              '%Y%m%d') - timedelta(hours=24)
                end_date = datetime.strftime(next_end_date, '%Y%m%d')
                #写csv文件
                if os.path.exists(filename):
                    data.to_csv(filename, header=None, mode='a')#追加写入模式
                else:
                    data.to_csv(filename, header=None, mode='a')
三、Tushare上市公司财务数据接口
1、利润表
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('xxxx0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.income(ts_code='600001.SH', start_date='20190101', end_date='20190901')
    print(data)
获取上市公司财务利润表数据
2、资产负债表
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.balancesheet(ts_code='600000.SH', 
           start_date='20190101', end_date='20190901',
           fields='ts_code,ann_date,f_ann_date,end_date,report_type,comp_type,cap_rese')
    print(data)
获取上市公司资产负债表。
3、现金流量表
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.cashflow(ts_code='600000.SH', start_date='20190101', end_date='20190901')
    print(data)
获取上市公司现金流量表。
4、业务预告
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.forecast(ann_date='20190131',
           fields='ts_code,ann_date,end_date,type,p_change_min,p_change_max,net_profit_min')
    print(data)
获取业绩预告数据。
5、分红送股数据
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.dividend(ts_code='600848.SH', 
            fields='ts_code,div_proc,stk_div,record_date,ex_date')
    print(data)
分红送股数据。
6、业绩快报
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.express(ts_code='600000.SH', start_date='20180101', 
                          end_date='20180701',
                          fields='ts_code,ann_date,end_date,revenue,operate_profit,total_profit,n_income,total_assets')
    print(data)
获取上市公司业绩快报。
7、财务指标数据
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.fina_indicator(ts_code='600000.SH')

    print(data)
获取上市公司财务指标数据，为避免服务器压力，现阶段每次请求最多返回60条记录，可通过设置日期多次请求获取更多数据。
8、财务审计意见
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.fina_audit(ts_code='600000.SH', start_date='20100101', end_date='20180808')
    print(data)
获取上市公司定期财务审计意见数据
9、主营业务构成
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.fina_mainbz(ts_code='000627.SZ', type='P')
    print(data)
获取某只股票的主营业务构成
df = ts_api.fina_mainbz_vip(period='20181231', 
                type='P', fields='ts_code,end_date,bz_item,bz_sales')
获取某一季度全部股票的主营业务构成
10、上市公司完整财务指标获取
import tushare
import datetime
import os
import timedelta


def fetch_finance_indicator(code):
    filename = 'your path'
    if not os.path.exists(filename):
        end_date = datetime.strftime(datetime.now(), '%Y%m%d')
        outputflag = True
        api = tushare.pro_api()
        while outputflag:
            data = api.fina_indicator(ts_code=code, end_date=end_date)
            if data.empty == True:
                outputflag = False
            else:
                next_end_date = datetime.strptime(
                    data.iloc[-1]['end_date'], '%Y%m%d') - timedelta(hours=24)
                end_date = datetime.strftime(next_end_date, '%Y%m%d')
                if os.path.exists(filename):
                    data.to_csv(filename, header=None, mode='a')
                else:
                    data.to_csv(filename)
四、Tushare指数接口
1、指数基本信息
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.index_basic(market='CSI')
    print(data)
获取指数基础信息。
MSCI:MSCI指数
CSI:中证指数
SSE:上交所指数
SZSE:深交所指数
CICC:中金所指数
SW:申万指数
2、指数日线行情
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.index_daily(ts_code='399300.SZ', start_date='20190101', end_date='20190910')
    print(data)
获取指数每日行情，还可以通过bar接口获取。由于服务器压力，目前规则是单次调取最多取8000行记录，可以设置start和end日期补全。指数行情也可以通过通用行情接口获取数据。
3、指数周线行情
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.index_weekly(ts_code='000001.SH', start_date='20180101', 
                                end_date='20190329',
                               fields='ts_code,trade_date,open,high,low,close,vol,amount')
    print(data)
获取指数周线行情，单次最大1000行记录，可分批获取，总量不限制。
4、指数月线行情
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.index_monthly(ts_code='000001.SH', start_date='20180101', 
            end_date='20190930',
                fields='ts_code,trade_date,open,high,low,close,vol,amount')
    print(data)
获取指数月线行情，每月更新一次，单次最大1000行记录，可多次获取，总量不限制。用户需要至少600积分才可以调取，积分越多频次越高。
5、指数成分和权重
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.index_weight(index_code='399300.SZ', start_date='20180901', 
            end_date='20190930')
    print(data)
获取各类指数成分和权重，月度数据 ，如需日度指数成分和权重，用户需要至少400积分才可以调取。
五、Tushare市场参考数据接口
1、港股通10大成交股
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.ggt_top10(trade_date='20190925')
    print(data)
获取港股通每日成交数据，其中包括沪市、深市详细数据。
2、融资融券交易汇总
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.margin(trade_date='20190925')
    print(data)
获取融资融券每日交易汇总数据。
3、融资融券交易明细
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.margin_detail(trade_date='20190925')
    print(data)
获取沪深两市每日融资融券明细。
4、前十大股东
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.top10_holders(ts_code='600000.SH', start_date='20190101', 
                    end_date='20191231')
    print(data)
获取上市公司前十大股东数据，包括持有数量和比例等信息。
5、前十大流通股东
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.top10_floatholders(ts_code='600000.SH', start_date='20190101', 
                            end_date='20191231')
    print(data)
获取上市公司前十大流通股东数据。
6、龙虎榜每日明细
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.top_list(trade_date='20190925')
    print(data)
龙虎榜每日交易明细，单次最大10000，用户需要至少300积分才可以调取。
7、龙虎榜机构交易明细
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.top_inst(trade_date='20190925')
    print(data)
龙虎榜机构成交明细，单次最大10000，用户需要至少300积分才可以调取。
8、大宗交易
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.block_trade(trade_date='20190925')
    print(data)
大宗交易，单次最大1000条，总量不限制，300积分可调取，每分钟内限制次数，超过5000积分无限制。
9、股票开户数据
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.stk_account(start_date='20190101', end_date='20191231')
    print(data)
获取股票账户开户数据，统计周期为一周，600积分可调取。
10、股东人数
import tushare as ts


if __name__ == '__main__':
    # 设置Token
    ts.set_token('b31e0ac207a5a45e0f7503aff25bf6bd929b88fe1d017a034ee0d530')
    # 初始化接口
    ts_api = ts.pro_api()
    data = ts_api.stk_holdernumber(ts_code='300209.SZ', start_date='20190101', 
                            end_date='20191231')
    print(data)
获取上市公司股东户数数据，数据不定期公布。单次最大3000，总量不限制，600积分可调取，基础积分每分钟调取100次，5000积分以上无限制。





策略测评指标

在量化交易策略中，可以从四个方面来进行衡量策略：收益、稳定性、胜率、风险。

大部分基金都有一条净值曲线，由基金每天的净值连接而成。每个策略也都有一条净值曲线，由策略每天的净值连接而成。这样一条净值曲线可以表示出这支基金（或策略）的收益、波动率、最大回撤、夏普比率等情况。

净值曲线：


净值计算：
InitialCapital−初始资产
Capital−账户总资产
Value−持仓股总市值
Cash−账户可用现金
Capital=Value+Cash
NetValue−账户净值
NetValue=Capital/InitialCapital
ProfitPct−账户总收益率
ProfitPct=(NetValue−1)∗100

计算流程图：

量化策略的评价指标：
1. 年化收益率（Annualized Returns）
年化收益率是衡量策略投资收益的指标，表示投资一年时的预期收益率，它的计算公式如下：

年化收益率是指把一段时间内的收益率换算成年收益率，分为单利和复利年化收益（一般采用复利年化收益）。

1.1 单利计算公式
单利年化收益率=当前投资收益率/(投资天数/365)∗100
举例：
某策略在2017年6月1日到6月30日期间的收益为30%
年化收益率 = 3% / (30/365)*100%,即36.5%

1.2 复利计算公式

代码：


2. 基准年化收益率（Benchmark Returns）
单独看策略年化收益率并不能体现策略的好坏，因此往往需要参考基准年化收益率。比如可以使用沪深300指数作为策略判断的基准，它的计算公式和年化收益率是一样的。


3. Sharpe Ratio（夏普比率）
——风险与收益的权衡
夏普比率（SHARPE）是指承受一单位总风险带来的超额回报，可以同时对收益与风险加以综合考虑
在给定的风险水平下使期望回报最大化
在给定的期望回报率的水平上使风险最小化
计算公式：

代码：


4. 最大回撤
最大回撤反映了投资者忍耐亏损的极限，从某种角度上说，最大回撤比收益率、夏普比率和信息比率更加重要。因为每个投资产品都有止损线，一旦短期回撤超过止损线，将会强制平仓
最坏的情况
在选定周期内任一历史时点往后推，策略的价值走到最低点时的收益率回撤幅度的最大值；
用来描述策略可能出现的最糟糕情况，衡量了最极端可能的亏损。

计算公式：


另外，最大回撤也决定了投资产品的杠杆比例。例如一个策略的最大回撤为20%，那么可以用20%的资金设计一个投资产品，当亏损20%的时候先从自有基金中扣除。这种产品可以获得5倍杠杆，放大了本金，可以获得更高的收益。
流程图：

代码：


5. Alpha阿尔法系数（ α ）
Alpha表示与市场波动无关的超额收益，也就是投资者面临的非系统性风险，常常用来衡量一个策略的好坏。
计算公式：

可以这样理解，如果将Beta值设为1，那么Alpha收益就是策略年化收益率和基准年化收益率的差值。
Alpha>0，策略相对风险获得了超额收益
Alpha=0，策略相对风险获得了适当收益
Alpha<0，策略相对风险获得了较少收益
在策略研究中，有一类中性Alpha策略，就是利用对冲的方式抵消市场（系统性）风险，从而获得超额收益。

6. Beta贝塔系数（ β）
衡量基金收益相对于市场收益的总体波动性，是一个相对指标。 β 越高，意味着基金相对于市场基准的波动性越大。β 大于 1 ，则基金的波动性大于市场基准的波动性。
Beta是由资本资产定价模型（CAPM）引申而来，能够衡量投资过程中的系统性风险，反映策略对基准变化的敏感性。

如果 β 为 1 ，则市场上涨 10 ％，基金上涨 10 ％；市场下滑 10 ％，基金相应下滑 10 ％。如果 β 为 1.1, 市场上涨 10 ％时，基金上涨 11%, ；市场下滑 10 ％时，基金下滑 11% 。如果 β为 0.9, 市场上涨 10 ％时，基金上涨 9% ；市场下滑 10 ％时，基金下滑 9% 。

7. 信息率
信息率用来衡量承担主动风险所带来的超额收益，表示单位主动风险所带来的超额收益。在承担适度风险的情况下，尽量追求高信息率。
计算公式：

信息比率等于策略超额收益和跟踪误差的比值。其中，跟踪误差是策略与基准每日收益差值的年化标准差，如果都选用了同一基准，可以看出信息比率大的策略是优于信息比率低的策略。而且相比夏普比率，信息比率更能反映策略的好坏：夏普比率以无风险收益率作为参考标准，而信息比率是以基准收益率作为参考标准。

代码：

对于风险指标分析而言，还有所提诺比率（Sortino）、策略波动率（Algorithm Volatility）、基准波动率（Bechmark Volatility）、胜率、盈亏比等，这里暂不一一列举。

不同收益类型，对指标的要求：
稳健性：正收益、回撤小
进取型：风险收益平衡、风险至上
激进型（理性的激进型投资者，更看重极端行情下会发生什么，更在乎压力测试，就是最坏情况下
本金是不是会亏，在极端行情下，活着就是最重要的）：在可承受的风险范围内追求收益最大化、极端行情配套的风控和严格的压力测试

不同交易品种和策略类型的指标要求（推荐）：


再来回顾下一个完整的交易系统：


可简单归纳为：
买什么（股票池选股）、何时买（技术指标、如金叉买入）、买多少（头寸管理）、何时卖（技术指标、如死叉卖出；止盈止损）、卖多少（头寸管理）



交易模型性能优劣的测试评价指标
(一)年化收益率
交易者最关心的是所建模型到底能不能赚钱,能赚多少?而年化收益率就是衡量交易模型的盈亏金额及盈亏速度的指标。年化收益率仅把不同时间段、周期的收益率(如日收益率、周收益率、月收益率)换算成年收益率,它是一种理论收益率,并不是真正的已取得的收益率。
最化交易中的年化收益率的计算公式为:
年化收益事=有效收益率/(总交易的天数/365)
有收益事=净利润最大使用资金
例如,某交易模型在五个交易日内三天赚两天赔,取得的有效收益率一共是0.1,则该模型的年化收益率是7.3%。该指标主要是为建模者提供比较直观的盈亏数据,方便投资者比较该模型收益与其他投资收益

(二)最大资产回撤
任何一个交易模型都不可能保证每次交易都是盈利的。出现亏损是正常的,但如果亏损幅度过大则会引发模型使用者的担心。尤其是如果用型辛辛苦苦赚了许多天,一天就亏得回到使用前,那表明该模型存在重大风险隐患。运用最大资产回撤指标,能够衡量模型在一段较长时
间内可能面临的最大亏损。
最大资产回撤,是指模型在选定的测试时间段内,在任一历史时点
的资产最高值,与资产再创新高之前回调到的资产最低值的差值。最大资产回撤用来描述型运行可能出现的最糟糕的情况,它是衡量量化交易模型性能的一个重要风险指标。有两种方式表示最大资产回撤。
一种是采用最大资产回撤的绝对值来表示,即:
最大资产回撤值=前期最高点一创新高前的最低点
另一种是采用最大资产回撤率来表示,即
最大资产回撤率=(前期最高点一创新高前的最低点)前期最高点
注意:
上述两个回撤指标的区别在于:前者是按回撤金额的最大绝对值来计算,而后者是按回撤比例的最大值来计算。比如说,一个原始金额为100元的账户,在刚开始交易的5次这一段时间内就发生了一个30万元的回撤。而此账户在交易一段时间后,总金额增长到了200万元,此
时又发生了一个40万元的回撤。如果以金额回撤来计算,后者40万元的回撤大,但是以比例来计算,则是前者30万元的回撤大。
通常,衡量模型回撤风险大小采用的都是回撤金额的最大绝对值这一指标,因为该指标能够知道究竞最多会亏损多少钱,对模型使用的风险性有实实在在的认知;如果采用回撤率指标,往往会让投资者觉得该模型的使用风险没有那么大。
【例4-1】某交易模型开始交易时的初始资金是100.00万元,每次交易手数固定。交易20次后账户资金增长到150.00万元,第21次交易出现亏损,账户资金减少到120.00万元。第22次交易后,账户资金又从最低值120.00万元增长到了150.01万元,那么该模型的最大资产回撤值为30.00万元。如果在以后的无数次交易中(每次交易手数固定)还有多次亏损,但最大亏损都没有超过30.00万元,则截止到最后一次交易,该模型的历史最大资产回撒为30.00万元。
可见,最大资产回撤的含义是使用该模型可能发生的最大亏损额,但并不知道什么时候会发生这个交易。如果像上面所述的先赚到钱然后资金才有回撤,那大部分人还是可以接受的,但如果刚开始使用模型就有30%的资金回撤,那使用者能接受吗?
(三)收益风险比
在模型设计过程中,采用的交易策略往往在思维上存在片面性。激进策略只重视模型的收益而忽视模型风险,保守策略只注重风险而轻视收益,而成功的交易策略会同时考虑收益和风险,追求低投入高回报。因此,评价交易模型的获利能力,并不是单纯看它的收益率,而应该看
盈利与最大资金回撤两者之比即收益风险比的大小。收益风险比,是指为了获取预期收益,投入的本金会冒多大的亏损风险,即所获取的潜在盈利与所承受的风险额度之间的比值。衡量量化交易模型的收益风险比公式为:
收益风险比=年度收益/最大资产回撤
比值越高说明模型的盈利能力越强,越值得釆用。假设预期投资收益为3万元,投入本金的最大亏损额度可能会达到1万元,则收益风险比为3:1。收益风险比是测试量化交易模型优劣的最重要的指标。因为每笔投资最终都要落实在两个问题上:一是敢不敢投资(最多亏多少钱)?二是值不值得投资(至少能赚多少钱)?收益风险比的意义,正是对以上两个问题的客观回答,也直接决定投资的结果。
【
例4-2】某量化模型设计者在交易策略上面临两种选
策略一:每次投资30万元。平均每年交易100次,盈亏次数为50%,其中,盈利交易每笔盈利1万元,亏损交易每笔亏损0.3万元、期间最大资产回撤为10万元。
策略二:每次投资30万元。平均每年交易100次,盈利次数40次,亏损次数60次,其中,盈利交易每笔盈利1万元,亏损交易每笔亏损0.25万元,期间最大资金回撤为5万元。
采用哪个策略建模更好呢?
先看看两种策略模型的收益风险比。
策略一的年均收益为:50×1-50×0.3=35万元,收益风险比为35/10=3.5
策略二的年均收益为:40×1-60×0.25=25万元,收益风险比为25/5=5
在其他条件都不变的情况下,策略一冒着1单位的最大损失,可以收获3.5单位的收益,而策略二冒着1单位的风险,可以收获5单位的收益。显然,策略二比策略一优越。这个例子同时展示了胜率高的模型不一定是最好的。但并不是说同样的收益风险比,模型的使用风险是相同的。比如A模型当年的收益率为40%,最大资金回撤为5%,那么收益风险比就是8;B模型当年的收益为200%,最大资金回撤为25%,那么收益风险比也是8。我们可以认为两种交易模型的盈利能力是一样优秀的,但哪个模型的风险性更大呢?显然是B模型。在相同收益风险比条件下,如果要追求更高的收益,比如800%的收益率,那么可能发生的最大资金回撤也有可能100%,一旦发生100%的资金回撤,资金赔光,交易就没有办法继续下去了。因此,只是追求模型的收益率而忽视模型的回撤风险是极其冒险的激进策略。所以说,尽管模型的收益风险比相同,但
交易结果还取决于不同的资金管理策略。一般认为,交易模型的收益风险比在3:1以上时,盈利才是比较有把握的,收益风险比在4:1或5:1时,结果则更好。再想提高收益风险比的难度就很大了。
(四)夏普比率
评估交易模型的优劣应该从收益期望和风险两方面综合考虑。风险调整后的收益率就是一个可以同时对收益与风险加以考虑的综合指标,以期能够排除风险因素对绩效评估的不利影响。
1966年,学者夏普在此基础上提出了著名的夏普比率
=(R-r)/a
其中,R是投资的回报期望值(平均回报率);r是无风险投资的回报率(可理解为同期银行存款利率);σ是回报率的标准方差(衡量波动性的最常用统计指标)。
夏普公式的核心思想是:理性的投资者将选择那些在给定的风险水平下使期望回报最大化的投资组合,或是那些在给定期望回报率的水平上使风险最小化的投资组合。解释起来非常简单,即投资时也要比较风险,尽可能用科学的方法以冒小风险的代价来换大回报。投资者在建立有风险的投资组合时,至少应该要求投资回报达到无风险投资回报的水平或者更高。
如果夏普比率为正值,说明在衡量期内投资的平均净值增长率超过了无风险利率,在以同期银行存款利率作为无风险利率的情况下,说明投资收益比银行存款利息要高。夏普比率越大,说明投资机会所获得的超额风险回报越高。
总之,夏普比率越高越好。交易模型的夏普比率多高才算是比较满意的模型呢?假设某交易模型5年的年平均回报率约为10%,波动性约为16%,无风险利率约为3.5%,计算出的夏普比率=(10%-3.5%)/16%=0.41。这个意思就是:该模型的年均回报率要比无风险利率高6.5%,但平均5年中也许有1年的回报率低于-6%,即10%-16%。对期货公司的资产管理业务经理来说,这样的夏普比率就偏低了:假设资产管理业务的投资回报目标是年回报率20%,就必须用2.5倍杠杆,这是需要再借贷1.5倍自有资金(回报期望=2.5×10%-1.5×3.5%≈20%),这意味着平均5
年中有1年的回报率将低于2.5×(10%-16%)-1.5×3.5%≈-20%,
即该模型使投资者的损失超过了20%,那样客户大概都跑光了。因此模型设计者常常想尽办法改善模型策略,提高夏普比率。
采用夏普比率评价模型的不足之处在于仅仅考虑了收益的平均波动水平,而没有考虑资金最大回撤情况。市场中真正的风险来自于极端的损失。下面通过一个简单例子加以说明。
【例4-3】假设模型A和模型B的每月收益情况见表4-2。
表4-2
模型A和模型B的每月收益情况 单位:%

设年化无风险利率为6%,计算得到夏普比率和其他指标(见表4-3
夏普比率及其他指标

如果仅仅比较夏普比率可以得知模型A要优于模型B,但是模型B的最大资金单月回撤仅为4%,累计回报率要高于模型A,而模型A的最大单月回撤达到10%,对于投资者而言,这是一个较大的单月回撤水平,投资风险较大。可见 仅仅比较夏普比率无法全面评价模型的五)胜率与盈亏比测评量化交易模型优劣的主要评估指标还有两个

(五)胜率与盈亏比

胜率是指在当前的成本设置下,模型盈利交易次数占总交易次数的比例。
公式如下
胜率=盈利交易次数/总交易次数
有部分投资者格外看重胜率,认为越高越好,至少希望胜率在50%以上,即获胜的概率超过一半,才算是好的模型,其实这是一个误解。事实上有的优秀的交易模型胜率并不高,这就与另
亏比有关。
盈亏比公式为
盈亏比=一段时间内所有盈利交易的总盈利额/同时段所有亏损交易的总亏损额
显然,盈亏比越高,交易模型获得的单笔收益越能够覆盖其他的亏损交易,对胜率的要求就没有那么高。反之,如果盈亏比很低,单笔亏损需要更多的盈利次数来覆盖,则要求更高的胜率。盈亏比的另一种理解方式为投资者承担一元钱的风险所能赚取的盈利。基于这种理解方
式,在不考虑交易成本的情况下,可以定义每一元钱的风险所能获得的期望收益为
Q=P-(1-P)/R
式中:P为胜率,R为盈亏比
假设盈亏比R为1,在上式中需要P大于50%才能使得期望收益为正,也就是说,对于一个盈亏比小于1的交易模型,胜率必须高于
0%才有可能赚取正的期望收益;反之如果盈亏比较高,例如R≥3,则胜率只需高于25%就可以保证期望收益Q为正。因此,胜率只有和盈亏比结合来评估模型才有意义。
【例4-4】设想一个模型,做10笔交易,盈利9笔,平均每笔盈利1万元,而亏损的那一笔一下就亏了10万元,这个模型的胜率虽然达到了90%,却还是亏损的模型,因为它的盈亏比太低;另外一个模型做10笔交易,盈利4笔,共盈利12万元;亏损6笔,共亏损6万型的胜率虽然只有40%,但总盈亏比为2。因此这个模型的盈利能力还是不错的。
值得注意的是,某些模型历史测试中的胜率可能包含有一些“伪盈利”交易,也就是一些交易的盈利非常小,几乎为0,在很低的手续费与滑点的设置下,它们是盈利交易,而在稍微严格一点的成本设置下就变成了亏损交易,很明显,追求这样的胜率没有什么意义。因此,单独考察模型的胜率这个评估指标意义不大。
除以上所论述的重要测评指标外,还有一些测评交易模型性能的指标,诸如净利润、最大连续盈利次数和最大连续亏损次数、平均盈利周期和平均亏损周期等。

综合上述测评体系,判断一个合格交易模型的评估原则大致为:
年化收益率至少应大于0,越高越好;最大资产回撤值当然是越小越好,但回撤的最大极限定为多少取决于投资者对亏损幅度的心理承受能力,因人而异;收益风险比也是越大越好,但提高的难度较大;夏普比率也是越大越好,但至少应该大于0;至于胜率,高当然好,但关键是要和盈亏比指标结合一起来评估,盈亏比高的模型胜率低一些也无所谓,所以胜率并不是关键性指标。再权衡其他测评指标,最终就能够获得初步满意的量化交易模型





风控模块

通常量化交易系统的风控模块需要进行两个类别的风控检查：
（1）交易所硬性指标，避免违反交易所监管要求。指标如：自成交风控、撤单数风控、单笔委托最大手数、各产品的最大撤单次数、
每秒最大报单笔数等。
（2）保障策略运行符合预期的风控指标，避免因程序的错误而造成巨额亏损。指标如：最大可用资金、最大持仓、最大报单数、最大报单频率、最大可亏损资金、单边最大持仓量、单边最大敞口量等。
数字货币量化投资风险归类与风控措施

风险归类
应用量化投资到数字货币市场的风险有两类：
一类是所有类型投资策略都要面对的数字货币风险，如市场风险、尾部事件、流动性风险等。
市场风险：数字货币本身的波动性，既是盈利来源，也是风险的来源。由于数字货币缺乏财务基本面，没有利息，也没有预期现金流，使得估值完全由预期和流动性定价，较一般金融产品波动更大。基于数字货币的衍生产品，继续把这种波动放大了好几倍。目前期货和期权市场，大部分也是基于比特币，小部分基于以太坊，其他币种的衍生品几乎没有，就是因为风险过大交易所都可能难以管理。
尾部风险：数字货币市场特有的尾部风险，是数字货币目前的基础设施不够完全导致的。总而言之就是流动性看似较大，但比较分裂，操控市场或者影响市场所需要的资金量其实很小。巨大的波动容易抽干流动性。可归因于是基础设施的缺乏，使得量化交易的量做不到太大。而这种情况，预计还会持续几年，直到新型的基础设施慢慢取代现有的设施。
流动性风险：前面已说明流动性是数字货币的定价来源之一。黄金本身就是流动性的池子，比特币也慢慢有向流动性池子发展的趋势。但是由于市值很小，所以相对黄金，很容易受到流动性的干扰，而且还兼具风险资产特征。典型的例子就是 3.12 的暴跌，以及暴跌后的迅速反弹，主因是流动性，次因是风险偏好。此外很多数字货币交易对的流动性也不稳定，不同交易所的交易对和上下币规则都略有不同，这对小币种的流动性干扰较大。
另一类是量化投资策略所特有的风险，如量化模型设计风险，数据的完整性风险，硬件故障等市场外黑天鹅风险，模型拟合、回测与未来的关系（市场条件变化），过拟合等多类风险，可以分成两类：
属于经验性的，如策略不够聪明、回测不到位、拟合没做好（如过拟合）、参数有问题、基础模型缺乏证明支持等。
属于技术性的，如缺乏足够的数据、硬件支撑，API 数据接口问题，网络延迟问题等。
风控措施
策略风控
策略主导的多指标风控原则
策略模型是一个负责从下单到平仓的一整套程序，大部分的策略模型，是把风控的模块包含进去了，如什么时候应该止损，什么时候应该停掉策略。
这部分模型是由量化策略员直接负责的。其中的各类指标，还要和和风控等部门协商。
此外就是一个团队基本能承担的风险是有上限的，当运用多策略模型时，单一策略又需要分配风险指标，所以策略模型的外在限制比较多，而这些可以内化为一个个多指标的风控程序。
高级算法过滤
除此以外，有些量化团队还专门设立独立的算法风控，比如使用自然语言处理 NLP、 关系网络、知识图谱等多类技术手段，去寻找和勾勒市场上并非显而易见，但是会有实质影响的风险。
相当于在策略和交易部门之外，单独设立一个算法为主导的风控监控体系，负责监控整体的风险暴露并和策略交易团队沟通。
风控预警和日志
预警属于前置的风控，即一般的风险提示、预警线、平仓线提示等。日志属于后置的风控，把风险事件和风控事件记录下来，以备日后查阅，并方便改进风控和策略模型。
合规风控
传统金融市场，比如 A 股会要求下单次数、撤单次数、下单和撤单之间的时间差等。预计以后合规的数字货币交易市场可能也会有类似要求，比如可交易 / 不可以交易什么类型的数字货币。这就需要修改策略模型，尤其是高频交易模型，以符合监管要求。
人工干预风控
主要是指策略启停、手工下单、系统急刹，以及各类人为定义的风控规则，目的是防止策略出现黑天鹅，尤其是自动交易类型的。历史上比如 2012 年骑士资本因为自动分单系统升级后，提示模块的缺失，导致 45 分钟内发送了天量订单，导致亏损 4. 6 亿美元。就是非常需要人工干预的情形。
量化模块虽然非常严谨，但是系统的 bug 非常难以避免，尤其是涉及升级、负责人员的更替、系统年代久远、缺乏开发日志及注释等多种情况的出现，都会导致出现 bug。此时就需要赋予高级风控和管理人员进行手工干预甚至启停的功能，并配合风控预警等模块进行干预。


期货交易柜台风控

对于程序化交易用户而言，无论是证券还是期货市场，每一个交易指令都需要进行充分的业务检查，通过后才能进入交易所的订单队列进行匹配成交。
在期货程序化交易中，除了验资、验持仓等基础的风控检查外，符合期货交易所异常交易管理办法规定的监管标准，杜绝和防范异常交易行为也是程序化交易风控的重中之重，比如是否存在自成交、日内过度交易、频繁报撤单、大额报撤单等情况。
如果交易指令没有进行严格的业务检查就进入市场，就会出现以下情况：
01 严重的交易事故——光大事件
8·16光大事件，老生常谈的典型案例。
因订单生成系统存在缺陷，导致瞬间生成几万笔预期外的市价委托订单。
而订单执行系统又未对可用资金额度进行风控检查，上述预期外的巨量市价委托订单被直接发送至交易所，并且后续还引发了股指期货市场的对冲交易行为。
该次事情给市场带来的巨大的影响，几十只权重股冲涨停，随后冲高回落，全天波及股票超过150只，相关投资者蒙受的损失或近百亿元。
相关负责人也因此次交易事故被证监会行政处罚及终身禁止进入市场交易。
图为当时的媒体报道配图，来源网络
02 来自交易所的“关心”
各家期货交易所对程序化交易指令的买卖价格和数量、委托次数、撤单次数等交易行为有明确的管理办法，并且会定期公示查处情况。
如有违规行为，那么就会收到来自交易所的警告和处罚。

图为2020年4月7日大商所官网的一则通告
所以，如果异常交易指令能在交易执行之前即被风控系统发现和拦截，可大大降低交易行为的违规率。
01风控一般有哪些类型
风控类型一般分为事前、事中、事后三种。
事前风控是指在交易指令发送到交易所前，对交易指令进行风险检测，通过检测的交易指令则提交到交易模块进行报单，未通过检测的交易指令将直接予以拒绝。
对于追求低延时的交易策略，事前风控需要在极短的时间内完成。
事中风控主要是指在交易过程中，交易团队对策略的信号生成、执行情况进行监控，以及盘中对策略的风险度进行实时监控。
事后风控更多地是对交易数据在盘后进行分析，比如策略算法是否存在错误、策略的回撤是否可控、是否有计划之外的持仓出现等，从而制定更严谨的业务风控预案和优化代码算法调整策略表现。
对于交易团队而言，最好的风控效果就是防患于未然。
所以程序化交易客户更多采用的是事前风控，在程序错误、操作失误出现之前就将其扼杀在摇篮中，确保交易策略满足业务风控要求和交易所的合规要求。
接下来我们来详细说说事前风控。
02事前风控的特点
1、与交易系统耦合极高
交易系统（这里的交易系统可以是订单生成系统、也可以是订单执行系统）会对所有交易指令进行筛选，通过风控检测的才会触发交易执行函数进行报单，不通过的进行拒单。
2、低延时、高可靠性
由于事前风控是对所有交易指令进行过滤，对可靠性有严格的要求，如果出现判断错误，很有可能导致交易事故。
在保证风控准确性的同时，还需考虑处理耗时，以避免对交易产生影响，错失交易机会。
03事前风控如何实现
事前风控可以在客户的交易策略程序内设置参数实现，也可以通过交易柜台的风控模块实现。
不同的交易柜台，风控的处理耗时不同。
对追求低延迟高频次的交易策略而言，Time is Value，无论是接收行情、风控判断、发送订单、或是接收成交回报都可以归结为信号。信号的价值随着时间的流逝而降低，所以信号出现后必须尽快地进行处理。
这些信号的快速识别与处理对策略的成交率、收益率会产生很大的影响。
如果选择通过高性能的交易柜台来实现风控检查，事前风控并不会显著增加交易延时，即可以保障交易速度，也可以得到全方位的风控保护。
比如小闪家的波塞东Poseidon期货极速量化交易系统，完成60+项风控指标的检查，耗时仅需百纳秒。
并且可以对单个策略、单个合约进行差异化的风控设置，帮助客户对每个策略、每个合约进行更精确的风险控制。
对于柜台自带的风控指标，如不需要，也可在柜台端选择关闭。
如需在盘中修改风控参数，实时即可生效。
04事前风控处理流程
以闪策波塞东柜台为例，柜台接收委托订单后，风控会根据预先设定的风控指标进行运算和判断，符合风控规则的订单才会进入交易模块，不符合则拒单。
并且日志系统会留痕所有风控、委托、成交信息，便于事后风控回顾。

05事前风控指标
以闪策科技波塞东Poseidon量化交易系统的风控模块为例，事前风控需要做到以下两个类别的风控判断：
1、交易所硬性指标，避免违反交易所监管要求。
比如：
√自成交风控
√撤单数风控
√单笔委托最大手数
√各产品的最大撤单次数
√每秒允许通过波塞东系统的报单笔数，等。
2、保障策略运行符合预期的风控指标，避免因程序的错误而造成巨额亏损。
举例：
√最大可用资金
√最大持仓
√最大报单数
√最大报单频率
√最大可亏损资金
√单边最大持仓量
√单边最大敞口量，等。
06总结
相比事中、事后风控的滞后性，事前风控可以在问题出现之前就实现对风险的识别和对交易进行保护。
选对柜台，风控耗时并不会明显影响交易速度。
只有在严格的事前风控体系保护下，市场参与者才不会被裸露在风险中。




风险指标
风险指标数据有利于对策略进行一个客观的评价，主要风险指标包括：
•策略收益（Total Returns）
•策略年化收益（Total Annualized Returns）
•基准收益（Benchmark Returns）
•基准年化收益（Benchmark Annualized Returns）
•阿尔法（Alpha）：投资中面临着系统性风险（Beta）和非系统性风险（Alpha），Alpha是投资者获得与市场波动无关的回报。比如投资者获得了15%的回报，其基准获得了10%的回报，那么Alpha获得价值增值的部分就是5%。

• 贝塔（Beta）：表示投资的系统性风险，反映了策略对大盘变化的敏感性。例如一个策略的Beta为1.5，则大盘上涨1%的时候，策略可能涨1.5%，反之亦然。如果一个策略的Beta为-1.5，说明大盘涨1%的时候，策略可能跌1.5%。

•夏普比率（Sharpe）：表示每承受一单位总风险，会产生多少的超额报酬，可以同时对策略的收益与风险进行综合考虑。
•索提诺比率（Sortino）：表示每承担一单位的下行风险，将会获得多少超额回报。
•信息比率（Information Ratio）：衡量单位超额风险带来的超额收益。信息比率越大，说明该策略单位跟踪误差所获得的超额收益越高。因此，信息比率较大的策略的表现要由于信息比率较低的基准。合理的投资目标应该是在承担适度风险下，尽可能追求高信息比率。
•策略波动率（Algorithm Volatility）：用来测量策略的风险性，波动越大代表策略风险越高。
•基准波动率（Benchmark Volatility）：用来策略基准的风险性，波动越大代表基准风险越高。
•最大回撤（Max Drawdown）：描述策略可能出现的最糟糕的情况，最极端可能的亏损情况。
•下行波动率（Downside Risk）：策略收益下行波动率。和普通收益波动率相比，下行标准差区分了好的和坏的波动。
•胜率：盈利的次数在总交易次数中的占比。
•日胜率：盈利超过基准的日数在总交易数中的占比。
•盈亏比：周期盈利亏损的比例
注意: 无论是回测还是模拟, 所有风险指标(alpha/beta/sharpe/max_drawdown等指标)都只会每天更新一次, 也只根据每天收盘后的收益计算, 并不考虑每天盘中的收益情况. 例外:
• 分钟和TICK模拟盘每分钟会更新策略收益和基准收益
• 按天模拟盘每天开盘后和收盘后会更新策略收益和基准收益
那么可能会造成这种现象: 模拟时收益曲线中有回撤, 但是 max_drawdown 可能为0.




交易风控系统

Octopus Trading是一个专注于数字货币交易的团队，在入行两年多的时间里，我们逐渐打磨交易系统，经历了好几轮市场的剧烈波动。成熟的风控系统是所有交易团队的标配，在这里我们分享一些我们的经验，或许能对一些新入行的朋友产生一些启发。
交易类型
在设计风控系统之前，首先要明白的是，你做的是什么类型的交易，你最大的风险在哪里？举个例子来说，如果你做的是套利，那你基本上不会持有一个敞口，所以当行情波动剧烈的时候，你只要保证你计算的持仓是正确的前提下，把订单撤掉，等风浪过去就可以了。反之，如果你做的是一个要持仓的策略，那在剧烈波动的时候，你要做的是不惜一切代价让你的策略的订单执行掉，错过了时机就是损失或者少赚。
不同的交易类型的风控策略肯定是不相同的，本文之后的系统设计均以套利策略为前提，简述如何构建一个可以给套利策略使用的风控系统。

敞口
套利策略的核心是，要尽量保持自己的敞口是0，即所有的交易都是对冲的。所以正确计算自己的持仓是关键的一步。一般我们都可以使用api从交易所获取实时的持仓，但是在一些特殊的情况下，交易所给你的持仓可能是错误的，或者延迟的。这样就会产生一个问题，在错误计算了持仓的情况下，程序错误地进行了对冲，而放飞的敞口随着价格变化，累积出了更多的亏损（当然有时候也可以是利润，但对风控系统来说，我们只考虑坏的情况）
所以，在计算持仓的时候，要考虑以下两种情况：

接口异常
这里的异常可能有多种情况，比如交易所维护升级，也有可能是api调用过于频繁被封。其表现形式是你无法通过接口获取到最新的持仓(余额)。在这种情况下，应该停止下单并且撤销现有挂单，停止交易一段时间，等待异常解除后继续。
另外一个需要小心的情况是，如果获取到一个"异常"的持仓，要不要采纳：比如交易所突然告诉你，你的持仓变0了，在没有成交的情况下，通常来说这是不可能发生的，这种情况下，丢掉错误的报文，告警，人工查看问题。

持仓延迟
持仓的变化是由订单引发的，当交易所的清算发生故障的时候，会发生明明订单已经成交，但是仓位没有变化的问题。订单的成交信息交易所是会有推送的，在这里，我们只需要在本地重新计算一下应该有多少持仓，如果和交易所返回的数据差距比较大，就应该停机检查。
此外，策略应该有逻辑在发现敞口时及时补回。通常的做法是定时补回一些，慢慢补，避免持仓计算出问题后，来回补单造成损失。按经验来说，一般每15-30秒补回一单即可。

挂单追踪
不管是什么类型的策略，都必须追踪自己的下单，直到交易所告知订单成交/取消。以下列出一些常见的异常情况，看看你的策略会在哪些情况下"中招"？

行情故障，你读到的行情比实际的延迟5秒以上，对着该行情的下单都不会成交。这些未成交的订单累积起来，是否会形成一个单边的敞口？
下单被拒，比如交易所升级了下单的精度参数，导致你在某个交易对上的下单请求全部都是被拒绝，这种情况下是否会导致该币种上的对冲不能正确执行？
下单超时，你下的挂单都因为超时没有收到回复，但实际上订单都下成功了，只是你没有收到订单ID，过一段时间后你会意外地发现有一些订单成交了，或者你的持仓发生了意外的改变。
ws推送延迟，你使用ws推送来订阅订单的更新状态，但是ws的推送断开/延迟了，你更新不到订单的状态，一些订单成交了你无法得知，应该如何容错？
一般来说，我们的策略是控制策略的总下单量，例如我们定义一个下单的通道，在每个通道上，我们只允许存在一个订单，如果前一个订单没有正确地清算，新的订单也不会继续发出，这样，我们策略持有的风险总量，就是我们在每个通道上能够下单的总金额，这样可以防止在异常情况下反复下单的最坏情况发生。
另外，一般来说下单的金额越高，承担的风险也就越高，所以在系统有部分订单追踪出现问题的时候，减少下单金额或者限制策略在大额订单通道上下单，都会有助于控制风险。
故障容错
如果你的策略运行在一些不太稳定的交易所上时，当交易所故障，或者维护时，策略能否优雅地容错，就成为了风控系统的重中之重。我们有过好几次回撤都是和交易所故障有关，可以说是花重金买来的经验教训也不为过。
有关故障容错，建议使用"白名单"法来处理，即，任何未知的错误，默认都会引发熔断，然后上线一段时间，把一些已知的，并不严重的异常归类进白名单，允许其偶尔发生但不引发熔断，从而提高系统运转效率。
这里列举了一些常见的异常（或者说是错误）：
订单被拒绝
下单超时
长时间收不到订单/账号推送
长时间收不到行情推送
IP Ban
持仓错误（例如你发起了子母账号的划转，一边扣了钱但另一边没加）
应对以上异常的核心原则是重试、熔断、告警。例如订单因为余额不足被拒绝，这个情况偶尔发生，相对来说比较正常，可以放过。但是如果一分钟内连续出现多次，就应当告警并熔断，人工检查是否有变更。在一些很难有人值守的时刻，比如凌晨四五点，使用熔断机制避免连续大额的亏损。

熔断
熔断机制的设计简单来说就是一个计数器外加一个延时装置，即一个错误第一次发生的时候，熔断系统1秒，第n次发生的时候熔断n*n秒，期间如果恢复正常，则清空计数器。
一般来说，熔断只需要针对下单进行即可，其他需要熔断的组件例如websocket连接的行情或者订单推送。
熔断机制的作用是当异常发生时，避免因重复重试导致的大量损失，或者引发交易所的IP Ban。
稍稍高级一些的熔断策略包括一个慢启动的机制，例如在熔断结束时只允许一些小额的订单操作，直到成功率超过阈值后再允许下更大金额的订单。

日志
日志是风控系统失效后，事后复盘的重要一环，日志能帮助你检视系统在风险事件发生的时刻，你的系统是如何被异常事件绕开了风控。
如果把交易所和你的策略想成一个调用链上下游的两个系统的话，日志系统所需要记录的基本由以下几个部分组成：行情推送、订单指令、订单推送。行情推送和订单推送都是交易所提供的信息，需要记录原始的报文以及客户端收到推送的时间戳，方便定位问题。订单指令是策略发出的信号，同样地也需要记录时间戳。通过以上三个日志的对比，我们就可以还原一个订单完整的决策和生命周期。
把每一个事件的日志，和相关的订单信息都打印到一行里，可以使我们方便的从日志中提取出有效的信息。使用内部的订单ID作为串联，通过该ID可以找到订单生命周期中的所有日志，这些和互联网企业广泛使用的日志系统设计其实并无多大差别。
日志系统的关键部分在于存储和检索，建议使用ELK或者TICK全家桶管理日志。简单的风控系统只需要保留七天的日志就可以了，一个问题如果超过七天都没有人去检查的话，那应该也不是什么大问题。
故障复盘
最后一个重中之重就是故障的复盘了，当异常发生时，通常来说伴随着亏损。通过日志系统，我们要还原故障发生时系统收到的信号，并且检查其中是否有不合理的逻辑。比如：交易所的行情发生了一些延时，而策略未能及时熔断，导致下单滑点增加，引发亏损。那么我们就要检查出问题当时的行情，看看有没有什么线索能识别出行情已经发生了延迟。例如，我已经下了订单，我预期它会在订单簿上拿走一部分的流动性，但推送过来的行情却没有这部分的信息，于是我便知道这个订单还没能及时进入撮合引擎，在此通道上应该进行熔断。
有些时候，交易所给到的信息可能无法让你准确地区分出异常情况。这个时候，你需要整理好日志，和交易所的技术支持做一下沟通，让他们明白客户端发生的异常情况，也许他们可以新增一些辅助信息，帮助你在下一次定位到此类问题。比如行情延时的问题，现在交易所推送时基本都会带上撮合的时间戳，如果策略发现行情的时间戳大幅落后时，可及时熔断避免风险。
小结
以上就是一个简易的交易风控系统了。我们的系统便是在以上基础上，根据一次次的故障和风险事件，加上各种补丁拼凑而成。当然，除了交易执行风险以外，还有类似行情插针、资产划转失效等其他系统外的风险，这些都需要构建在交易系统的外围，通过控制信号来指示交易系统停止交易，撤销订单，进行风险规避。另外，如果条件允许的话，写一个App，在手机上订阅风控事件，控制交易开关，可以让你更进一步地沉迷在数字货币的交易世界里。欢迎入坑。




数字货币交易的风险控制
 
2019年7月11日，24小时内EOS价格下跌超过30%，Okex出现上亿资金规模的爆仓订单，币圈哀鸿遍野。但这仅是期货交易一种很常见的风险，一些简单的风控措施即可避免。
一、市场风险
1、单一性风险【风险等级：4颗星，操作难度：1颗星】
如果只投资单一币种，或者单一策略，很容易遭受单一性攻击风险。通过分散投资方法可以有效降低此种风险。
以100万USDT的本金为例，我一般会分到两种策略，5个币种上，假设其他风控措施无效，出现了爆仓，如上EOS爆仓事件，对我的影响也仅仅是EOS单一币种出了问题，很有可能我的总账户上依然是盈利的。
同时分散投资不仅仅是分散风险，也是为了获得更高的收益，我们很难预测在下一个周期到底是哪一个币种利润率高，那么就分散着做。
2、价格极限波动，造成爆仓【风险等级：4颗星，操作难度：3颗星】
价格急速上升或者下降，俗称插针行情，很容易引发期货账户的爆仓。通过对保证金率监控，配合自动化的自动减仓和平仓操作可以降低此种风险影响。我的一些操作心得是这样的：
先说下保证金率这个算法，因为我们自己特殊处理了保证金率这个参数，当我说保证金率=35，则代表我当前仓位可以抗住价格35%的波动，超过就爆仓了。
（1）日常仓位严格控制，设定操作线为35左右。即当保证金率低于操作线就不再开仓了。那这个数值也根据各个币种不一样而有所不同，大致是根据最近2年各币种单日最大波动设置的。
（2）当保证金率低于25时，需要启动搬砖
（3）当保证金率低于15时，程序启动自动减仓机制，亏损一定的利润保住本金安全。
（4）如果前面的措施无法阻挡情况恶化，发生爆仓，则程序会自动启动爆仓后的处理方式，比如如果做套利，则会平掉其他交易所的仓位，来快速锁定亏损，防止扩大。
（5）贯穿这始终的，有一套保证金率监控和报警的程序，当保证金率低于30时，会开始发送不同程度和频率的报警
（6）轻易不要玩小币种，小币种是非常容易极限波动的，因为庄家的筹码实在太多，那就不是交易了，而是送人头
3、USDT/USD价格波动风险【风险等级：2颗星】
7月29日Tether和 bitfinex听证会事件搞的人心惶惶，投资人既担心USDT崩盘给自己带来的影响，又担心如果没崩盘那自己为崩盘而做的操作会带来的损失。
（1）避免直接持有USDT：买期货，然后做好对冲，期货对标的是USD，并非USDT，当USDT价格下跌时，账户金额不受影响。
（2）根据USDT以往的事例，USDT有过超15%的下跌，但也很快会回来，我建议大家在没有铁锤的情况下，不要轻举妄动，有时候过一段时间就回来了。
（3）如果是个风险厌恶者，那就提前兑换成法币出场，记住，提前！OTC交易要找靠谱的合作者，在靠谱的大的交易所平台交易，不要私下交易。
二、流动性风险
交易所或者链上出现异常，无法转账或者转账时间过长
（1）机构要建立好跟交易所的沟通通道，比如我司在各大交易所都有专门的大客户经理微信，转账不及时时，可以优先得到处理
（2）在交易所存风险备用金账户，当发生紧急状况时，使用交易所内部转账方式垫付资金，防止爆仓等
（3）一些人为操作也会触发这个问题，当更改账户安全设置信息，比如秘钥、绑定手机、邮箱等信息时，会触发交易所的风控规则，导致该账户24小时无法转帐。所以当更改以上账户信息时，必须严格控制频率，提前做好准备。
三、操作风险
1、内部人员腐败，转移客户资金
（1）权利分割，交易员不能拥有账户转账权限，APIKey只有交易权限，没有转账权限。或者做好转账白名单，只能在白名单账户内进行转账。
（2）独立的监控系统，时刻监控账户金额的变化，当金额变动超过10%时，或者有转账行为时，发送风控员报警。
（3）做好员工安全和法律教育
2、非工作时间，人员不在岗风险
（1）最大的风险，程序必须能够进行自动化处理，包括风险的监控、预警、处理、反馈四个阶段都要有。
（2）由于数字货币交易是7*24小时全年无休市的，运营人员需要轮岗来做，我们公司就达成了24小时都有人的状态，夜间也有人值班。
3、秘钥泄露
交易所的秘钥是非常重要的，要做好安全的防范措施
（1）不允许明文存放秘钥，不在其他任何地方共享此秘钥。
（2）秘钥信息在内部单线传递，在我们公司就只有我和对应的一个交易员知道这个信息，如果客户发到了群里，对不起，这个秘钥就作废了重新更新
（3）如果交易员或者换岗，秘钥要更新一版
（4）固定周期更换秘钥
4、代码更新，发版引发的问题
（1）做好版本管理，走灰度上线，若出现问题可以及时回滚
（2）代码上线前要经过严格的测试流程，有测试报告可供查询，程序员+测试双方确认后，方可灰度上线
（3）上线时，人员必须在线盯一小时左右，出现异常及时处理
（4）交易等数据存档，出现问题，可以追查原因
（5）代码保持固定周期的跑测试用例，防止交易所API更新，部分代码失效的问题
5、交易所API风险
（1）API返回值为空，或者无法访问的风险
6、服务器崩溃
（1）采用市场上的好的云服务器，崩溃的概率较小
（2）做好备用服务器，如果某一台发生故障，可以短时间内转移到其他服务器开工
7、账户所有者擅自操作账户的风险





币安API交易规则说明
 
为提供更好的交易环境，币安对用户的交易行为进行量化评估，建立了API风控系统，主要指标有：未成交率（UFR）、过期率（IFER）、撤单率（GCR）。
1.指标说明
1）未成交率（UFR）
未成交率=1-成交总量/委托总量
委托总量：所有委托单的挂单数量之和
成交总量：所有委托单的成交数量之和
数据范围取当周期、当交易对创建的委托单
2）过期率（IFER）
过期率 = 过期单总笔数 / FOK及IOC委托单委托总笔数
FOK及IOC委托单：委托单类型（timeInForce）为FOK或IOC的委托单
过期单：是指委托单类型（timeInForce）为FOK或IOC，委托单状态为已过期（EXPIRED），且成交数量为0的委托单
数据范围取当周期、当交易对创建的所有FOK及IOC委托单
3）撤单率（GCR）
撤单率 = 无效撤单总笔数 / GTC委托单总笔数
GTC委托单：委托单类型（timeInForce）为GTC的委托单
无效撤单：委托单类型（timeInForce）为GTC，委托单状态为已取消（CANCELED），成交数量为0，且撤单时间与下单时间间隔小于等于2.5秒的委托单
数据范围取当周期、当交易对创建的所有GTC委托单
4）24小时禁用次数
24小时禁用次数 = 近24小时内被API风控系统禁用的次数
 
2.指标参数表
 
指标	指标触发值	触发条件	计算周期	禁用时间
未成交率UFR	＞0.999	委托单数量≥300	每10分钟	5分钟
过期率IFER	＞0.99	FOK及IOC委托单数量≥150	每10分钟	5分钟
撤单率GCR	＞0.99	GTC委托单数量≥150	每10分钟	5分钟
24小时禁用次数	>10		每10分钟	24小时
 
3.禁用执行
被API风控系统禁用期间，用户无法创建新的API及使用API在任意交易对挂单，其他客户端挂撤单以及API撤单不受影响，每次禁用会以邮件形式通知。
4.指标查询
API用户可以通过《接口文档》进行指标参数查询，查看每个交易对各指标的状态。
币安会定期根据市场情况对参数指标进行优化
更新日期：2019/01/18
相关链接
API文档说明：https://github.com/binance-exchange/binance-official-api-docs
API示例代码：https://github.com/binance-exchange
API交易参数指标查询： Account API Trading Status
API中文TG群：https://t.me/Binance_api_Chinese 




BitMEX REST API限制
 
请求频率限制
 
我们对 REST API 请求通过一个或多个限制器以分层的方式进行频率限制。 限制器实现了 Token Bucket 机制，并且 Token 不断被填充。
当前，存在两个限制器：
对于所有线路，每分钟 120 次请求（未经身份验证时减少为 30 次）
某些线路上每秒 10 次请求（请参阅下文）
**请特别注意你的程序抛出的错误数目！**如果在短时间内产生大量的响应（如 400 或 500），你的 IP 地址可能被禁用一小时。 在短时间内的多个禁用将导致为期一周的禁用。
 
查看您的频率限制
 
对每个 API 的请求，以下标头将被返回︰
"x-ratelimit-limit": 120
"x-ratelimit-remaining": 118
"x-ratelimit-reset": 1489791662
利用这些标头数据来确定你目前的频率限制以及剩余的请求数。 在指定的 UNIX 时间戳 x-ratelimit-reset 时，你将有足够的频率限制余额来完成你的当前请求。 如果你尚未超过你的频率限制，该数值永远等于当前的时间戳。
如果你已经被限制频率，你将收到 429 响应，以及一个额外的标头 Retry-After，它显示你在重试前需要等待的时间。
 
第二层频率限制
 
除了第一层速率限制外，某些线路还具有一个额外的限制器，将请求限制为每秒 10 个请求的速率。 此限制在以下线路中共享：
POST /api/v1/order
PUT /api/v1/order
DELETE /api/v1/order
DELETE /api/v1/order/all
POST /api/v1/position/isolate
POST /api/v1/position/leverage
POST /api/v1/position/transferMargin
在对这些线路的每次请求中，将返回 x-ratelimit-remaining-1s 标头以及第一层频率限制标头。
当超过此频率限制时， x-ratelimit-remaining-1s 标头的值将是 0，你将收到 429 响应以及 retry-after 标头。
 
提高你的频率限制
 
如果你已超过频率限制，并且认为这是合理的需求，请发联系客服来讨论提高你的频率限制。
提高你的频率限制之前，我们需要你的程序至少满足下列要求︰
使用 WebSocket 数据源来避免轮询数据。
使用我们的 批量取消 功能来减少 系统负载。
批量取消操作，无论取消多少委托，都被计算为一次请求。
当你发送提高频率限制的邮件给我们时，请包括︰
您的应用程序的目的和预期的增长
您所需的速率限制
确认您的程序如上述有效的使用 API
 
频率限制降低
如果账户涉及恶意行为，则可以降低单个账户的频率限制。
 
委托数量限制
为了保持有序的市场，BitMEX 就每个账户的待交易委托数量设置上限。这些上限是： 这些限制是：
Maximum 200 open orders per symbol per account;
Maximum 10 stop orders per symbol per account;
当发出超过这些上限的新交易委托时，该交易将被拒绝，并显示“太多 [open | stop] 交易委托”。
 
委托最小交易限制
我们有意将 BitMEX 产品的合约规模设定为较低值，以鼓励机构和个人交易员在 BitMEX 上进行交易。 但是，一些交易员滥用这种机制，并通过发送很多小量委托来破坏委托列表。
如果账户的未成交委托过多且总值低于 0.0001 XBT ，则每个账户都会被标记为垃圾账户。
如果您被标记为垃圾账户：
低于 0.0001 XBT 的委托将自动成为隐藏委托。
隐藏委托不会显示在委托列表上，并且总是需要支付提取流动性费用。
被动委托的垃圾委托将被拒绝而不是被隐藏。
太多的垃圾委托可能导致账户暂时被禁止交易。
如果用户的行为发生变化，垃圾账户标记将每 24 小时自动重新评估和解除。
 
WebSocket 限制
WebSocket 限制记录在 WebSocket API 的页面上 。





事前、事中、事后风控方案
 
9.一个合格的量化团队他的整体风险控制流程是怎么样的呢？
每个严谨的机构，都会有一套完整的，事前、事中和事后风控方案。
专业的量化参与者，会把所有可能的风险都列出来，然后告诉你，每个风险出现的时候，是怎么应对的。应对是事后的措施，控制是事前的措施。
 
首先事前风控，顾名思义就是在策略实盘进行前，对风险事件进行控制和预测。
事前风控包括策略过拟合检验，就是通过一系列的检验，避免刚才提到的数据过度挖掘，和前视偏差的风险。
事中风控就是提前对在策略实盘执行当中的情况进行控制，比如说仓位控制和杠杆控制，做多做空的仓位是什么比例、不同的主流币种是什么样的比例，什么样的行情搭配什么样的杠杆能得到最优的效果。
事后风控，指的是风险事件发生了之后的反省风控，一般包括策略容量的检测和在一些基本面事件发生了之后的反省。
 
事中风控
比如仓位的集中度的控制，仓位集中度的控制体现在几个维度。
首先是仓位中，不同方向的交易比例，比如套利策略中，买和卖的仓位是对冲的，那这个比例是需要控制的，套利策略一般就尽量会控制这两个比例是差不多的，使得整体仓位不会因为一个单方向的大行情使得整体资金大幅亏损。
另一就是控制仓位中，流动性差的合约仓位，比如当季的合约，或者一些流动性不太好的数字货币，都要事先确定好占整个仓位的比例，比如流动性不好的合约或者现货占比不能超过整体仓位20%，那样极端行情发生，不会因为流动性导致大幅亏损，因为流动性差的品种，会出现滑点过大造成巨大交易成本的风险。
同样的分散原则，整个仓位单个交易品种也应该被限制仓位比例，尽量避免整个资金仓位集中在一两个品种上面，比如整个资金仓位只交易一个币种，甚至是同一个策略，那样整个仓位的容错率就很低，一旦策略在单个品种中判断错误，就使得资金整体亏损。
除了在事中进行仓位集中度控制外，还需要对杠杆进行监控。杠杆控制乍一听很容易，开仓的时候杠杆控制确实很简单，但在实际中，由于仓位是逐步建起来的，所以单笔资金的开仓杠杆好控制，实际整体的杠杆并不见得简单。
整个资金的杠杆其实是需要事先就决定好，在不同情况下的杠杆率的，特别是在整体资金处在浮亏的情况，是继续开仓增加杠杆，还是减少杠杆，什么时候开始降低杠杆都是一个动态的过程。
举个例子来说。套利策略，在满足阈值的时候开仓，比如火币上的BTC现货和OKEX上BTC的季度合约达到了3.6价差，我们的策略判断这个时候就应该开仓了，但一般来说都是会逐步开仓的。
比如这时候使用25%的仓位开仓，但假如价差继续扩大，超过了3.6比如说到了4.6，按道理来说，这个时候更大的偏离价差程度。对于套利策略来说是更好的事儿，因为如果价差回归的话，预期收益更大了。
但是另一方面，之前开的仓位已经处于浮亏了，如果继续开仓的话，亏损的速度会更快，因为仓位更大了，如果一直开满仓，可能杠杆总体能控制在某个数值，但亏损已经累积了不少了，怎么平衡这个杠杆比例以及累计亏损，有点像是个微积分的过程，在什么情况下，开多少仓，杠杆过大就是事先需要决定和在事中需要监控调整的。






策略

交易模式

每一种数字资产，只有能够流通才具备市场价值。想要得到更好得流动，并且让它持续升值，那就需要登陆交易所。
区块链交易所系统平台中常见的开发模式有哪些？
(1)限价交易模式介绍：
限价买入/卖出是指用户设置一个买/卖出币的价格和数量，生成委托单，系统会自动最合市场上的买单和卖单，一旦达到用户设置的价格便按照价格优先时间优先顺序自动成交。
(2)币币交易模式介绍：
币币交易主要是针对虚拟数字资产和虚拟数字资产之间的交易，以其中一种币作为计价单位去购买其他币种，币币交易规则同样是按照价格优先时间优先顺序完成合交易。
(3)量化交易模式介绍：
量化交易是指以先进的数学模型替代人为的主观判断，利用计算机技术从庞大的历史数据中海选能带来超额收益的多种“大概率”事件以制定策略，极大地减少了投资者情绪波动的影响，避免在市场极度狂热或悲观的情况下作出非理性的投资决策。
(4)市价交易模式介绍：
市价买是指用户设置一个总金额，生成委托单，从卖一开始撮合直到总金额成交完成。市价卖是指用户设置要卖的总币数，生成委托单，从买一开始撮合直到总币数交易完成。
(5)杠杆交易模式介绍：
杠杆交易，就是利用小额的资金来进行数倍于原始金额的投资。以期望获取相对投资标的物波动的数倍收益率，抑或亏损。由于保证金(该笔小额资金)的增减不以标的资产的波动比例来运动，风险很高。


开发模式

数字货币交易所量化交易系统开发模式：
系统化交易指用户将交易思路量化为交易系统，根据系统指标进行交易；
算法交易是利用电子平台，输入涉及算法的交易指令，以执行预先设定好的交易策略，指令中包含变量，包括时间，价格，交易量等，广泛应用于大宗交易；
程序化交易就是将用户复杂的交易思路转变为能简单操作的智能交易系统，便于用户的严格执行。
一、常见的入场模式
一般常用的入场模式不外乎两种，一种是事先确定一个价格，当盘中最新价格达到或者超过这个价格，系统开仓又叫做突破进场。还有一个是在盘中计算一些指标，当这些指标达到所设定的开仓条件后，在下一个时间采样区间的开盘价系统开仓。
(1)突破信号：
突破信号一般包括两种，一种是根据昨天或者N天前的价格所计算的一个用于今天的固定不变的价格点，采用此类信号的策略为波幅突破策略，固定时间突破策略，以及枢轴线突破策略。波幅突破策略采用昨天高点减去低点计算出的一个波幅值，然后在今天开盘价基础上加上或者减去这个波幅值来确定一个固定区间，当当天最新价格突破上面区间或者下面区间时入场。固定时间突破策略是通过确定今天开盘后一段时间内的高低点，当这段时间后的价格突破了这段时间内的高低点价格后入场。枢轴线突破策略则是根据枢轴线计算方法使用昨天高点，开盘价，收盘价来计算三条阻力线和支撑线，当今天价格突破其中的某条阻力线和支撑线时入场。
还有一种突破信号是根据盘中价格即时更新的，也叫做动态带突破，其中比较经典的策略主要为唐奇安通道突破和波动率通道突破系统。其中唐奇安通道突破采用的是前一段时间的最高价和最低价作为一个动态的区间，当当前价格突破这个区间时开仓，而波动率通道则是采用统计学计算前一段时间收盘价的标准差然后在收盘价的均线上加减这个标准差来组成一个动态的标准差带，当当前价格突破这个标准差带时开仓。
(2)开盘价指标信号：
开盘价指标信号通常有三种类型的策略，一种就是均线类。均线类策略主要是使用两个或者多个不同周期的收盘价的均线，短周期的均线向上穿越长周期或者下穿时，在一根k线的开盘价开仓。
一种是指标类策略。指标类策略通常采用一些设定好的高低点的指标值作为开仓点，比如RSI指标等，该指标盘中根据之前的价格进行实时计算，当该指标值达到预设值时在下一根k线的开盘价开仓。
还有一种是形态类策略。形态类策略通常采用事先定义好的一种形态，当当前价格形态满足这种定义好的形态时，在下一根k线的开盘价开仓。形态类策略简单的比如红三兵策略，当出现连续三根红色阳线或者三根绿色阴线时开仓。还有复杂的比如采用形态识别的策略，事先定义一种胜率相对较高的形态，然后在盘中通过形态识别的方法来计算，当当前价格形态与定义的价格形态近似度到达一定时，则在下一根k线的开盘价进场。
二、常见的过滤指标
过滤指标通常在系统设计中起到画龙点睛的作用，一个胜率相对较高的进场信号结合一个过滤指标通常会起到更加提高胜率的效果。不过过滤通常也是以牺牲进场交易次数为代价的，因减少的交易次数而进而牺牲更早的进场交易利润。常见的过滤条件包括指标类过滤，时间类过滤，以及统计型过滤。
指标类过滤：
指标类过滤通常是采用结合各类技术指标，在原有进场信号的基础上，叠加一个技术指标来进一步减少进场信号。
时间类过滤：
时间类过滤通常指因为在特定时间段开仓胜率较低，因此该段时间不开仓。
统计型过滤：
统计型过滤通常是根据历史统计，交易时只有在统计胜率较高的区间才交易。
三、常见的出场模式
趋势跟随类策略通常采用跟踪止盈型出场，而其他类型策略通常也会采用主动型出场比如固定时间出场或者反向信号出场。
跟踪止盈型出场
跟踪止盈型出场主要是通过进场盈利以后，当价格朝着不利的方向移动时，利润回吐到一定百分比时出场。还有一种吊灯出场跟跟踪止盈出场类似，只不过不管进场后是否盈利，只要价格偏离进场后的最高点（最低点）一定幅度以后即出场。
主动型出场
主动型出场多用于震荡策略中，通常有在持仓到一定时间后即出场，利润到达一定后即出场，以及出现反向信号时即出场。
何谓量化交易
量化交易是指用定量的方法拟定行动方案，进行交易。在交易过程中，采用先进的数学模型量化盘面数据，替代人为的主观判断，通过历史数据反复验证寻找未来能够继续盈利的“大概率”策略，利用计算机快速处理技术，极大地减少了投资者情绪波动的影响，避免在市场极度狂热或悲观的情况下作出非理性的投资决策。
市场将量化交易分为以下类别：系统化交易、算法交易、程序化交易和机械式交易等，其中前三种模式在市场比较常见，系统化交易指投资者将交易思路量化为交易系统，根据系统指标进行交易；算法交易是利用电子平台，输入涉及算法的交易指令，以执行预先设定好的交易策略，指令中包含变量，包括时间，价格，交易量等，广泛应用于大宗交易；程序化交易就是将投资者复杂的交易思路转变为能简单操作的智能交易系统，便于投资者的严格执行。这三者区别在于：程序化交易通过数据回测获得大概率盈利预期，全自动下单；系统化交易在于系统指标量化，不需要全自动交易；算法交易主要目的是完全大宗交易，把大额交易分割为许多小额交易来应付市场风险和冲击。




数字货币资金费策略

什么是资金费
永续合约是数字货币市场特有的一类期货，它是永远不会到期交割的期货。而资金费是跟随永续合约产生的特有的名词。 因为永续合约没有到期或交割，所以需要通过“资金费用机制”来让合约价格锚定现货价格。
永续合约每8小时为一期，每期结束时进行结算，永续合约每天结算3期（次）。即00:00-8:00为一期，结算时间为8:00；8:00-16:00为一期，结算时间为16:00；16:00-次日00:00为一期，结算时间为00:00。以上时间均为GMT+8时间。
结算时，用户应当收取还是支付资金费用，由本期的资金费率以及该用户的持仓情况决定。当资金费率为正值时，多仓将支付资金费用，空仓将收取资金费用；当资金费率为负值时，多仓将收取资金费用，空仓将支付资金费用。
介绍完资金费的概念，我们再来看资金费的计算方式。
首先，资金费率有一个重要的特征：延时性。 即当期的资金费率，由上一期的数据进行计算而得，在本期开始时已经确定，期内不会改变，并应用于本期结束时的资金费用结算。 而与此同时，交易所一般还会计算一个下一期的预测资金费率，这个预测资金费率一般每分钟更新， 本期最后一次计算的预测资金费率，就是下一期的资金费率。
比如， 8:00-16:00这一期的资金费率，是通过上一期00:00-8:00的数据计算而得，在8:00的时候已经确定，在16:00进行结算时使用。同时，8:00-16:00这段时间内，每分钟会计算一个预测资金费率，预测的是16:00-次日00:00这一期的资金费率，并将最后一次计算的预测资金费率，作为16:00-次日00:00这一期的资金费率。
其次，资金费的计算，与两个变量相关，一是综合利率，二是溢价。我们可以这样来理解，以正资金费率为例，综合利率决定资金费率的底，溢价决定资金费率的顶。当资金费率为正，且永续合约相对于现货的溢价很小时，资金费率等于综合利率，目前大部分平台的值都是0.01%；而当永续合约相对于现货的溢价超过一定比率时，资金费率是由溢价率作为输入的公式计算出来的，我们不需要去完整的理解这个公式，只需要有大致的概念，资金费与溢价率高度相关，溢价越大，资金费率相应的也越高。
之所以不需要去理解这个公式，是因为资金费率、下一期预测资金费率，我们都可以在交易所的K线界面看到，同时API中也有相关计算好的字段，能够很容易的读取到相应数值。

永续合约有两类，一类是币本位合约，以交易的币种作为保证金、盈亏计价，另一类是U本位合约，以USDT作为保证金和盈亏计价。不论是U本位，还是币本位，只要是永续合约，都有资金费率存在。我们也可以通过交易所的合约信息，查询到两类永续合约分别的实时资金费率、预测资金费率。


资金费策略原理
资金费率有一个显著的特征：其正负分布是极度有偏的，我们以最近大热的狗狗币（doge/usdt）为例，可以看到的是，资金费>0的次数远远多于资金费<0的次数，也就是说，在大部分行情下，永续合约的空头都在赚取永续合约多头的资金费。

看到这里，严谨的朋友可能会问，那么是否是因为你举了狗狗币这个最近多头大热的例子，所造成的幸存者偏差？其实多头、空头在更长时间赚取资金费率的几率应该是大致相等的呢？
我们以币安交易所U本位永续合约BTCUSDT为例，绘制出过去3年BTC U本位永续合约所有时间的资金费，可以看到，仍然和近期的狗狗币那样，大部分时间资金费率都是正值，只有在深度熊市（例如2020年3月），资金费率才会短暂的打到负值。

于是，我们可以总结一下数字货币永续市场的规律：资金费率常年为正，牛市时期幅度极大，只有在深度熊市，才频繁出现负值。换句话说：在永续合约市场，由于资金费率的存在，空头的长期优势是大于多头的。那么，我们如何既在永续市场做空头赚取资金费，又不承担标的资产的方向性波动？许多老交易员第一时间就能想到：我们在现货市场开多，在永续市场上开空，就能完美做到上述两点。
而我们的这个资金费策略，在获取资金费收益的同时，还期望能赚取市场一部分的价差波动。还是以近期的狗狗币为例，下图的溢价指数k线，可以理解为是永续合约与现货之间的价差。尽管这个价差在大部分时间为正（永续>现货），但在分钟甚至Tick级别上，价差会出现短时间的负值（永续<现货）。我们在价差达到较大正值时建仓（买现货同时卖空永续），而在价差达到较小负值时平仓，就能够赚取到市场中的价差波动。

因此，我们的资金费策略原理，是将收取资金费与赚取价差波动结合起来，当某个币种资金费率高，同时现货合约价差高，我们进场开仓（买现货同时卖空永续），如果现货合约价差不收敛到0以下，我们就在场内持续吃资金费的利润，如果现货合约价差到0以下，我们平仓（卖现货同时买平仓永续）以获取价差收益；同时在平仓之后，继续寻找下一次高资金费率、高价差的进场机会，并如此循环往复。




无风险套利策略

数字货币基金量化主要进行无风险套利和趋势套利两类操作，其中
无风险套利主要包括：
1、比特币在不同交易所的价差搬砖
2、流通性比较开发模式好的代币的三角套利
3、盘口价差很大，交易活跃的盘口套利
4、期货对冲套利。
趋势套利主要包括
5、杠杆策略交易
下面，我将就具体如何执行做个阐述，涉及商业机密，只讲述操作逻辑，不讲具体算法。
第1个策略：搬砖套利
由于比特币是全球货币，不同国家有多个交易所在进行交易。目前来看，印度卢比（INR）买比特币价格最高（可以在Koinex进行BTC/INR交易），其次为韩元，美元价格最稳定。同一个BTC在不同交易所的不同货币计价单位之间存在套利空间。
因此具备以下几个先决条件：
1、 在印度、韩国、美国等比特币交易所开设账号，并存有对应该国的法币、BTC和USDT。
2、 交易平台的活跃度很大，支持随时存取币。当BTC出现不同交易所价格背离时，只要利润差超过手续费就可以进行如下循环：通过机器自动判断，同时执行第一步，第二步和第三步。
第2个策略：三角套利
一般选取流通性比较好的代币，以太坊和比特币进行三角交易，完成一次三角循环后，币的数量没有发生变化，手中现金增多。
需要具备以下几个先决条件：
1、 代币的流通性要足够好。
2、 要计算买一到买十全部的金额，控制流转头寸的金额。当出现三角循环一圈，利润差超过手续费，就可以按照如下步骤进行。
第3个策略：盘口套利
由于ICO项目上盘很多，而一般项目都有私募轮，私募的投资方希望尽快获利了结，而没有参加私募的人看好币会主动买币，所以有人很想卖，有人很想买。所以通过持有一定的底仓，自动保持永远在买一和卖一价格机器自动交易，截取中间利润，只要超过手续费，机器会自动交易。此模式在开盘和币的价格有大范围波动的时候，效果明显，在交易疲软和波动不大时，效果较弱。
需要具备以下几个先决条件
1、 大家对一个币的看法出现了很大的差异，有人强烈看多，有人强烈看空
2、 流通性一定要足够大，最好做多个交易所都上市的，可以再多个交易所共同实现盘口套利。
当出现盘口价差，利润差超过手续费，就可以按照如下步骤进行。
买一价格为57.22，卖一价格为57.64，买卖任意一笔交易手续费是千分之二，因此我们，可以在57.23挂买一买卖一的6.4511数量，在57.63挂卖一卖买一的6.4511数量。如果有人把自己手中的币卖给了我们买一57.23，同时有人把自己手中的钱买币，买了我们卖一57.63，中间就每一个就产生了0.41的利差。而交易买卖一笔双向是千分之四，所以如果都交易6.4511个，那么我们币的数量不变，额外产生了：
（57.63-57.23）*6.4511-（57.63+57.23）6.45110.002=1.098美元
第4个策略：对冲套利
主要通过购买自己持仓货币的对应期货，或者相反逻辑的货币。例如，持有比特币，就应该购买做空比特币的期货，用来对冲风险。持有比特币，应该购买比特币现金（BCH）进行对冲风险。由于只是策略持仓来锁定利润，所以没有实际操作步骤。
第5个策略：趋势套利
本模式需要进行判断未来1分钟到一天的价格走势，通过保证金制度，进行杠杆交易。这部分的策略是最难的，也是最考验程序员算法能力的。前面4个部分，都是无风险套利，只要API接到交易所，算法和策略足够快，服务器节点足够近，就可以实现套利。但是杠杆策略交易，是需要机器进行自行判断未来交易的走势，并作出相应的做多或者做空策略。目前，很多团队都是通过人为进行判断的，通过听消息，通过人为感知盘口交易数据，进行人为做多或者做空。由于目前数字货币波动很大，杠杆策略交易很容易因为做出相反的判断而直接爆仓被平仓，所以这部分人为操作有很大的基金净值回撤和浮盈，收益振幅非常大。